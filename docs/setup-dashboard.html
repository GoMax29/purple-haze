<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Setup Dashboard - Ultime Météo</title>

    <!-- Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      :root {
        --primary: #2563eb;
        --primary-dark: #1d4ed8;
        --secondary: #64748b;
        --accent: #06b6d4;
        --success: #059669;
        --warning: #d97706;
        --danger: #dc2626;
        --background: #f8fafc;
        --surface: #ffffff;
        --border: #e2e8f0;
        --text: #1e293b;
        --text-muted: #64748b;
        --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
        --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1),
          0 4px 6px -4px rgb(0 0 0 / 0.1);
      }

      body {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background-color: var(--background);
        color: var(--text);
        line-height: 1.6;
      }

      .container {
        max-width: 1600px;
        margin: 0 auto;
        padding: 20px;
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
        padding: 20px;
        background: linear-gradient(
          135deg,
          var(--primary) 0%,
          var(--accent) 100%
        );
        border-radius: 16px;
        color: white;
        box-shadow: var(--shadow-lg);
      }

      .header h1 {
        font-size: 2.5rem;
        font-weight: 700;
        margin-bottom: 8px;
      }

      .header p {
        font-size: 1.1rem;
        opacity: 0.9;
      }

      /* City Selector */
      .city-selector {
        background: var(--surface);
        border-radius: 12px;
        padding: 24px;
        margin-bottom: 24px;
        box-shadow: var(--shadow);
        border: 1px solid var(--border);
      }

      .city-selector h2 {
        font-size: 1.5rem;
        margin-bottom: 16px;
        color: var(--text);
      }

      .cities-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 12px;
      }

      .city-btn {
        padding: 12px 16px;
        border: 2px solid var(--border);
        background: var(--surface);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: center;
        font-weight: 500;
        font-size: 0.9rem;
      }

      .city-btn:hover {
        border-color: var(--primary);
        background: var(--primary);
        color: white;
        transform: translateY(-1px);
      }

      .city-btn.active {
        background: var(--primary);
        border-color: var(--primary);
        color: white;
        box-shadow: var(--shadow);
      }

      /* Special styling for Biarritz and Cap-Corse */
      .city-btn[data-city="Biarritz"].active,
      .city-btn[data-city="Cap-Corse"].active {
        font-weight: 700;
      }

      /* Parameters Tabs */
      .parameters-section {
        background: var(--surface);
        border-radius: 12px;
        padding: 24px;
        margin-bottom: 24px;
        box-shadow: var(--shadow);
        border: 1px solid var(--border);
      }

      .tabs-container {
        border-bottom: 1px solid var(--border);
        margin-bottom: 24px;
      }

      .tabs-nav {
        display: flex;
        overflow-x: auto;
        gap: 4px;
      }

      .tab-btn {
        padding: 12px 20px;
        border: none;
        background: transparent;
        border-radius: 8px 8px 0 0;
        cursor: pointer;
        transition: all 0.2s ease;
        font-weight: 500;
        white-space: nowrap;
        color: var(--text-muted);
      }

      .tab-btn:hover {
        background: var(--background);
        color: var(--text);
      }

      .tab-btn.active {
        background: var(--primary);
        color: white;
      }

      .tab-content {
        display: none;
      }

      .tab-content.active {
        display: block;
      }

      /* Layout optimisé avec catégories à gauche */
      .models-columns {
        display: flex;
        flex-direction: column;
        gap: 16px;
        margin-bottom: 20px;
      }

      .models-column {
        display: flex;
        align-items: flex-start;
        gap: 16px;
        border: 2px solid var(--border);
        border-radius: 12px;
        padding: 16px;
        background: var(--background);
        min-height: 120px;
      }

      .column-header {
        flex-shrink: 0;
        width: 150px;
        font-weight: 700;
        font-size: 0.9rem;
        padding: 8px;
        border-radius: 8px;
        color: white;
        text-align: center;
        writing-mode: horizontal-tb;
        display: flex;
        align-items: center;
        justify-content: center;
        line-height: 1;
      }

      .models-row {
        flex: 1;
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: flex-start;
      }

      .column-header.short-term {
        background: linear-gradient(135deg, #ff6b6b, #ee5a24);
      }

      .column-header.medium-term {
        background: linear-gradient(135deg, #4834d4, #686de0);
      }

      .column-header.long-term {
        background: linear-gradient(135deg, #00d2d3, #01a3a4);
      }

      .model-card {
        border: 2px solid;
        border-radius: 8px;
        padding: 12px;
        background: var(--surface);
        transition: all 0.2s ease;
        flex: 0 0 280px;
        min-height: 80px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }

      .model-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 12px;
      }

      .model-checkbox {
        width: 18px;
        height: 18px;
        accent-color: var(--primary);
      }

      .model-name {
        font-weight: 600;
        color: var(--text);
        font-size: 0.9rem;
      }

      .time-range {
        display: grid;
        grid-template-columns: 1fr auto 1fr;
        gap: 8px;
        align-items: center;
        margin-top: 8px;
      }

      .time-select {
        padding: 6px;
        border: 1px solid var(--border);
        border-radius: 4px;
        background: var(--surface);
        font-size: 0.8rem;
      }

      /* Quick Action Buttons */
      .quick-actions {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 12px;
        margin: 20px 0;
      }

      .quick-btn {
        padding: 10px 16px;
        border: 2px solid;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        font-size: 0.9rem;
        transition: all 0.2s ease;
        background: var(--surface);
      }

      .quick-btn.reset {
        border-color: var(--success);
        color: var(--success);
      }

      .quick-btn.deselect {
        border-color: var(--danger);
        color: var(--danger);
      }

      .quick-btn.progressive {
        border-color: var(--warning);
        color: var(--warning);
      }

      .quick-btn.premium {
        border-color: #8e44ad;
        color: #8e44ad;
        background: linear-gradient(
          45deg,
          transparent 0%,
          rgba(142, 68, 173, 0.1) 100%
        );
      }

      .quick-btn:hover {
        background-color: currentColor;
        color: white;
        transform: translateY(-1px);
      }

      /* Action Buttons */
      .action-buttons {
        text-align: center;
        margin: 24px 0;
      }

      .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.2s ease;
        font-size: 1rem;
      }

      .btn-primary {
        background: var(--primary);
        color: white;
      }

      .btn-primary:hover {
        background: var(--primary-dark);
        transform: translateY(-1px);
        box-shadow: var(--shadow);
      }

      /* Charts Section */
      .charts-section {
        background: var(--surface);
        border-radius: 12px;
        padding: 24px;
        margin-bottom: 24px;
        box-shadow: var(--shadow);
        border: 1px solid var(--border);
      }

      .chart-container {
        position: relative;
        height: 500px;
        margin-bottom: 20px;
      }

      .zoom-reset-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 1000;
        padding: 8px 16px;
        background: var(--primary);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.875rem;
        font-weight: 600;
        display: none;
        transition: all 0.2s ease;
      }

      .zoom-reset-btn:hover {
        background: var(--primary-dark);
        transform: translateY(-1px);
      }

      .precipitation-mode-btn {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 1000;
        padding: 8px 16px;
        background: var(--warning);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.875rem;
        font-weight: 600;
        display: none;
        transition: all 0.2s ease;
      }

      .precipitation-mode-btn:hover {
        background: #b45309;
        transform: translateY(-1px);
      }

      .wind-direction-mode-btn {
        position: absolute;
        top: 10px;
        left: 120px;
        z-index: 1000;
        padding: 8px 16px;
        background: var(--accent);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.875rem;
        font-weight: 600;
        display: none;
        transition: all 0.2s ease;
      }

      .wind-direction-mode-btn:hover {
        background: #0891b2;
        transform: translateY(-1px);
      }

      /* Fine-Tune Rain Parameters Panel */
      .rain-params-section {
        background: var(--surface);
        border-radius: 12px;
        border: 1px solid var(--border);
        box-shadow: var(--shadow);
        overflow: hidden;
      }

      .rain-params-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 16px 20px;
        background: linear-gradient(135deg, #8b5cf6 0%, #a855f7 100%);
        color: white;
        border-bottom: 1px solid var(--border);
      }

      .rain-params-header h3 {
        margin: 0;
        font-size: 1.2rem;
        font-weight: 600;
      }

      .rain-params-toggle {
        background: rgba(255, 255, 255, 0.2);
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .rain-params-toggle:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: translateY(-1px);
      }

      .rain-params-content {
        padding: 24px;
      }

      .params-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 24px;
        margin-bottom: 24px;
      }

      .param-group {
        background: #f8fafc;
        border-radius: 8px;
        padding: 16px;
        border: 1px solid #e2e8f0;
      }

      .param-group h4 {
        margin: 0 0 16px 0;
        font-size: 1rem;
        font-weight: 600;
        color: var(--primary);
      }

      .param-item {
        margin-bottom: 16px;
      }

      .param-item:last-child {
        margin-bottom: 0;
      }

      .param-item label {
        display: block;
        margin-bottom: 8px;
        font-size: 0.9rem;
        font-weight: 500;
        color: var(--text);
      }

      .param-item input[type="checkbox"] {
        margin-right: 8px;
      }

      .slider-container {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .slider-container input[type="range"] {
        flex: 1;
        height: 6px;
        border-radius: 3px;
        background: #e2e8f0;
        outline: none;
        -webkit-appearance: none;
      }

      .slider-container input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--primary);
        cursor: pointer;
        border: 2px solid white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .slider-container input[type="range"]::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--primary);
        cursor: pointer;
        border: 2px solid white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .slider-value {
        min-width: 60px;
        text-align: right;
        font-size: 0.85rem;
        font-weight: 600;
        color: var(--primary);
        background: white;
        padding: 4px 8px;
        border-radius: 4px;
        border: 1px solid #e2e8f0;
      }

      .param-item select {
        width: 100%;
        padding: 8px 12px;
        border: 1px solid var(--border);
        border-radius: 6px;
        background: white;
        font-size: 0.9rem;
        color: var(--text);
      }

      .custom-weights-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 8px;
        margin-top: 8px;
      }

      .weight-input {
        text-align: center;
      }

      .weight-input label {
        display: block;
        font-size: 0.8rem;
        margin-bottom: 4px;
        color: var(--text-muted);
      }

      .weight-input input {
        width: 100%;
        padding: 4px;
        border: 1px solid var(--border);
        border-radius: 4px;
        text-align: center;
        font-size: 0.8rem;
      }

      .rain-params-actions {
        display: flex;
        gap: 12px;
        padding: 16px 0;
        border-top: 1px solid var(--border);
        margin-top: 16px;
        flex-wrap: wrap;
      }

      .btn-primary {
        background: var(--primary);
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 6px;
        font-size: 0.9rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .btn-primary:hover {
        background: var(--primary-dark);
        transform: translateY(-1px);
      }

      .btn-secondary {
        background: white;
        color: var(--text);
        border: 1px solid var(--border);
        padding: 10px 20px;
        border-radius: 6px;
        font-size: 0.9rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .btn-secondary:hover {
        background: #f8fafc;
        border-color: var(--primary);
        color: var(--primary);
        transform: translateY(-1px);
      }

      .param-visualization {
        background: white;
        border-radius: 8px;
        padding: 16px;
        border: 1px solid var(--border);
        margin-top: 16px;
      }

      .param-visualization h4 {
        margin: 0 0 12px 0;
        font-size: 1rem;
        font-weight: 600;
        color: var(--text);
      }

      .viz-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 12px;
      }

      .stat-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        background: #f8fafc;
        border-radius: 6px;
        border: 1px solid #e2e8f0;
      }

      .stat-label {
        font-size: 0.85rem;
        color: var(--text-muted);
      }

      .stat-value {
        font-size: 0.9rem;
        font-weight: 600;
        color: var(--primary);
      }

      /* Tooltips pour les paramètres */
      .param-tooltip {
        position: relative;
        display: inline-block;
        margin-left: 8px;
        cursor: help;
      }

      .param-tooltip .tooltip-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--primary);
        color: white;
        font-size: 11px;
        font-weight: bold;
      }

      .param-tooltip .tooltip-content {
        visibility: hidden;
        opacity: 0;
        position: absolute;
        z-index: 1000;
        bottom: 125%;
        left: 50%;
        transform: translateX(-50%);
        background: #333;
        color: white;
        text-align: left;
        padding: 12px;
        border-radius: 8px;
        width: 280px;
        font-size: 0.8rem;
        line-height: 1.4;
        transition: opacity 0.3s ease;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .param-tooltip .tooltip-content::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border: 6px solid transparent;
        border-top-color: #333;
      }

      .param-tooltip:hover .tooltip-content {
        visibility: visible;
        opacity: 1;
      }

      .tooltip-content .tooltip-title {
        font-weight: bold;
        margin-bottom: 6px;
        color: #4ade80;
      }

      .tooltip-content .tooltip-effect {
        margin-bottom: 6px;
        color: #fbbf24;
      }

      .tooltip-content .tooltip-example {
        font-style: italic;
        color: #a3a3a3;
      }

      /* Nouveaux éléments d'interface */
      .temporal-mode-buttons {
        display: flex;
        gap: 12px;
        margin-top: 8px;
      }

      .radio-label {
        display: flex;
        align-items: center;
        cursor: pointer;
        padding: 6px 12px;
        border: 1px solid var(--border);
        border-radius: 6px;
        background: white;
        transition: all 0.2s ease;
      }

      .radio-label:hover {
        border-color: var(--primary);
        background: #f8fafc;
      }

      .radio-label input[type="radio"] {
        margin-right: 6px;
      }

      .radio-label input[type="radio"]:checked + span {
        color: var(--primary);
        font-weight: 600;
      }

      .weights-display {
        margin-top: 8px;
        padding: 8px 12px;
        background: #f0f9ff;
        border: 1px solid #0ea5e9;
        border-radius: 6px;
        text-align: center;
      }

      .weight-badge {
        font-family: monospace;
        font-size: 0.9rem;
        font-weight: 600;
        color: #0369a1;
      }

      .param-item h5 {
        margin: 0 0 8px 0;
        font-size: 1rem;
        color: var(--primary);
        font-weight: 600;
      }

      .chart-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 16px;
        padding: 16px;
        background: var(--background);
        border-radius: 8px;
      }

      .model-toggle {
        padding: 6px 12px;
        border: 1px solid var(--border);
        background: var(--surface);
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.875rem;
        transition: all 0.2s ease;
      }

      .model-toggle.active {
        font-style: italic;
        border-width: 2px;
      }

      .model-toggle.emphasized {
        font-weight: 700;
        font-style: normal;
        border-width: 3px;
        box-shadow: 0 0 8px currentColor;
      }

      .model-toggle.hidden {
        text-decoration: line-through;
        opacity: 0.4;
        background-color: #f5f5f5;
        color: #999;
      }

      /* Aggregation Section */
      .aggregation-section {
        background: var(--surface);
        border-radius: 12px;
        padding: 24px;
        margin-bottom: 24px;
        box-shadow: var(--shadow);
        border: 1px solid var(--border);
      }

      .strategy-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 16px;
        margin-bottom: 20px;
        max-width: 900px;
        margin-left: auto;
        margin-right: auto;
      }

      .strategy-card {
        border: 2px solid;
        border-radius: 8px;
        padding: 16px;
        background: var(--surface);
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: center;
        min-height: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        font-size: 0.9rem;
      }

      .strategy-card:hover {
        border-color: var(--primary);
        background: var(--surface);
      }

      .strategy-card.active {
        border-color: var(--primary);
        background: var(--primary);
        color: white;
      }

      /* Didactic Mode */
      .didactic-mode {
        margin-top: 20px;
        padding: 20px;
        background: var(--background);
        border-radius: 12px;
        border: 1px solid var(--border);
      }

      .didactic-title {
        font-size: 1.2rem;
        font-weight: 700;
        margin-bottom: 16px;
        color: var(--primary);
      }

      .didactic-content {
        display: none;
      }

      .didactic-content.active {
        display: block;
      }

      .math-formula {
        background: #f8f9fa;
        padding: 12px;
        border-radius: 6px;
        font-family: "Courier New", monospace;
        margin: 8px 0;
        border-left: 4px solid var(--primary);
      }

      .example-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin: 16px 0;
      }

      .example-card {
        background: var(--surface);
        padding: 12px;
        border-radius: 8px;
        border: 1px solid var(--border);
      }

      .example-title {
        font-weight: 600;
        margin-bottom: 8px;
        color: var(--primary);
      }

      .example-values {
        font-family: "Courier New", monospace;
        margin: 4px 0;
      }

      .use-cases {
        margin-top: 12px;
        padding: 12px;
        background: #e3f2fd;
        border-radius: 6px;
      }

      .use-cases-title {
        font-weight: 600;
        margin-bottom: 8px;
        color: #1976d2;
      }

      /* Loading State */
      .loading {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 40px;
        color: var(--text-muted);
      }

      .spinner {
        width: 20px;
        height: 20px;
        border: 2px solid var(--border);
        border-top: 2px solid var(--primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 8px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Responsive */
      @media (max-width: 768px) {
        .container {
          padding: 12px;
        }

        .header h1 {
          font-size: 1.8rem;
        }

        .cities-grid {
          grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        }

        .models-column {
          flex-direction: column;
        }

        .column-header {
          width: 100%;
          margin-bottom: 12px;
        }

        .model-card {
          flex: 1 1 100%;
        }

        .quick-actions {
          flex-direction: column;
          align-items: center;
        }

        .strategy-grid {
          grid-template-columns: 1fr;
          gap: 12px;
        }
      }

      /* Hover tooltip */
      .hover-info {
        position: absolute;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 0.875rem;
        pointer-events: none;
        z-index: 1000;
        white-space: nowrap;
      }

      .analysis-btn {
        background: #f1f5f9 !important;
        color: #374151 !important;
        border: 1px solid #cbd5e1 !important;
        font-size: 12px !important;
      }
      .analysis-btn.active {
        background: #3b82f6 !important;
        border-color: #2563eb !important;
        color: #ffffff !important;
      }
      .analysis-btn:hover {
        background: #e2e8f0 !important;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Header -->
      <header class="header">
        <h1>⚡ Setup Dashboard Météo</h1>
        <p>Configuration avancée des modèles et stratégies d'agrégation</p>
      </header>

      <!-- City Selector -->
      <section class="city-selector">
        <h2>🌍 Sélection de la ville</h2>
        <div class="cities-grid" id="citiesGrid">
          <!-- Cities will be populated by JavaScript -->
        </div>
        <div id="selectedCityInfo" style="display: none">
          <span id="cityName" style="display: none"></span><br />

          <span id="cityCoords" style="display: none"></span>
        </div>
      </section>

      <!-- Parameters Tabs -->
      <section class="parameters-section">
        <h2>📊 Configuration des paramètres</h2>
        <div class="tabs-container">
          <nav class="tabs-nav" id="tabsNav">
            <!-- Tabs will be populated by JavaScript -->
          </nav>
        </div>
        <div id="tabsContent">
          <!-- Tab contents will be populated by JavaScript -->
        </div>

        <!-- Quick Actions -->
        <div class="quick-actions">
          <button class="quick-btn reset" id="resetBtn">
            🔄 Reset paramètres
          </button>
          <button class="quick-btn deselect" id="deselectBtn">
            ❌ Désélectionner tout
          </button>
          <button class="quick-btn progressive" id="progressiveBtn">
            📈 Algo progressif
          </button>
          <button class="quick-btn premium" id="premiumBtn">
            💎 Modèles Premium
          </button>
        </div>
      </section>

      <!-- Action Button -->
      <div class="action-buttons">
        <button class="btn btn-primary" id="updateGraphic">
          📈 Mettre à jour le graphique
        </button>
      </div>

      <!-- Charts Section -->
      <section class="charts-section" id="chartsSection" style="display: none">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
          "
        >
          <h2 style="margin: 0">📈 Visualisation des données</h2>
          <div
            id="chartCityInfo"
            style="font-size: 0.9rem; color: var(--text-muted)"
          >
            <!-- City info will be populated by JavaScript -->
          </div>
        </div>
        <div class="chart-controls" id="chartControls">
          <!-- Model toggles will be populated by JavaScript -->
        </div>
        <div class="chart-container">
          <button class="zoom-reset-btn" id="zoomResetBtn">Reset Zoom</button>
          <button class="precipitation-mode-btn" id="precipitationModeBtn">
            Stacked
          </button>
          <button class="wind-direction-mode-btn" id="windDirectionModeBtn">
            Points
          </button>
          <canvas id="mainChart"></canvas>
        </div>

        <!-- Fine-Tune Rain Parameters Panel -->
        <div
          class="rain-params-section"
          id="rainParamsSection"
          style="display: none; margin-top: 24px"
        >
          <div class="rain-params-header">
            <h3>🎛️ Fine-Tune Rain Parameters</h3>
            <button class="rain-params-toggle" id="rainParamsToggle">
              ▼ Masquer
            </button>
          </div>

          <div class="rain-params-content" id="rainParamsContent">
            <!-- Paramètres principaux -->
            <div class="params-grid">
              <div class="param-group">
                <h4>🔹 Paramètres principaux</h4>

                <div class="param-item">
                  <h5>🔹 Pondération par palliers de précipitation</h5>
                  <p
                    style="font-size: 0.8rem; color: #666; margin-bottom: 12px"
                  >
                    Définit l'influence de chaque niveau de précipitation sur la
                    probabilité finale. ≥0.4mm = toujours 100%.
                  </p>
                </div>

                <div class="param-item">
                  <label for="weightPallier01"
                    >Pondération 0.1mm
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">
                          Poids des faibles précipitations
                        </div>
                        <div class="tooltip-effect">
                          Influence des modèles prévoyant exactement 0.1mm. Plus
                          haut = plus d'impact sur la probabilité.
                        </div>
                        <div class="tooltip-example">
                          Ex: 0.3 = modérément pris en compte, 0.8 = fortement
                          pris en compte. Idéal pour détecter signaux faibles
                          cohérents.
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="weightPallier01"
                      min="0.0"
                      max="1.0"
                      step="0.1"
                      value="0.3"
                    />
                    <span class="slider-value" id="weightPallier01Value"
                      >0.3</span
                    >
                  </div>
                </div>

                <div class="param-item">
                  <label for="weightPallier02"
                    >Pondération 0.2mm
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">
                          Poids des précipitations légères
                        </div>
                        <div class="tooltip-effect">
                          Influence des modèles prévoyant exactement 0.2mm.
                        </div>
                        <div class="tooltip-example">
                          Ex: 0.6 = pris en compte modérément fort. Généralement
                          plus élevé que 0.1mm.
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="weightPallier02"
                      min="0.0"
                      max="1.0"
                      step="0.1"
                      value="0.6"
                    />
                    <span class="slider-value" id="weightPallier02Value"
                      >0.6</span
                    >
                  </div>
                </div>

                <div class="param-item">
                  <label for="weightPallier03"
                    >Pondération 0.3mm
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">
                          Poids des précipitations modérées
                        </div>
                        <div class="tooltip-effect">
                          Influence des modèles prévoyant exactement 0.3mm.
                        </div>
                        <div class="tooltip-example">
                          Ex: 0.8 = fortement pris en compte. Proche du poids
                          maximum (1.0 pour ≥0.4mm).
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="weightPallier03"
                      min="0.0"
                      max="1.0"
                      step="0.1"
                      value="0.8"
                    />
                    <span class="slider-value" id="weightPallier03Value"
                      >0.8</span
                    >
                  </div>
                </div>

                <div class="param-item">
                  <label for="sigmaRef"
                    >Variance de référence (σ_ref)
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">Référence de dispersion</div>
                        <div class="tooltip-effect">
                          Définit ce qui est considéré comme "normal" pour la
                          dispersion des modèles. Plus haut = plus tolérant.
                        </div>
                        <div class="tooltip-example">
                          Ex: 4.0 = standard, 2.0 = strict (pénalise forte
                          dispersion), 8.0 = permissif. Idéal pour zones
                          orographiques complexes.
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="sigmaRef"
                      min="1.0"
                      max="10.0"
                      step="0.5"
                      value="4.0"
                    />
                    <span class="slider-value" id="sigmaRefValue">4.0</span>
                  </div>
                </div>

                <div class="param-item">
                  <label for="alphaAggressive"
                    >Agressivité de l'ajustement (α)
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">Force des corrections</div>
                        <div class="tooltip-effect">
                          Contrôle l'intensité des ajustements de probabilité.
                          Plus bas = courbe plus lisse.
                        </div>
                        <div class="tooltip-example">
                          Ex: 0.1 = corrections douces, 0.3 = corrections
                          agressives. Réduire si courbe trop "nerveuse".
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="alphaAggressive"
                      min="0.05"
                      max="0.5"
                      step="0.05"
                      value="0.2"
                    />
                    <span class="slider-value" id="alphaAggressiveValue"
                      >0.2</span
                    >
                  </div>
                </div>

                <div class="param-item">
                  <label for="gamma"
                    >Facteur d'agressivité variance (γ)
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">
                          Sensibilité à la variance
                        </div>
                        <div class="tooltip-effect">
                          Détermine l'influence de la dispersion des modèles sur
                          les corrections. Plus haut = plus réactif.
                        </div>
                        <div class="tooltip-example">
                          Ex: 0.05 = peu d'influence, 0.2 = forte influence.
                          Augmenter en montagne, réduire en plaine.
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="gamma"
                      min="0.05"
                      max="0.3"
                      step="0.05"
                      value="0.1"
                    />
                    <span class="slider-value" id="gammaValue">0.1</span>
                  </div>
                </div>
              </div>

              <div class="param-group">
                <h4>🔹 Pondération temporelle</h4>

                <div class="param-item">
                  <label
                    >Mode de pondération temporelle
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">Lissage temporel avancé</div>
                        <div class="tooltip-effect">
                          Contrôle la répartition des poids sur les heures
                          adjacentes avec 2 sliders : centre + concentration.
                        </div>
                        <div class="tooltip-example">
                          Ex: Centre=80%, Concentration=50% → [10%, 80%, 10%] en
                          mode 3j. Plus de concentration = plus focalisé sur H.
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="temporal-mode-buttons">
                    <label class="radio-label">
                      <input
                        type="radio"
                        name="temporalMode"
                        value="none"
                        id="temporalModeNone"
                      />
                      <span>Aucun</span>
                    </label>
                    <label class="radio-label">
                      <input
                        type="radio"
                        name="temporalMode"
                        value="3days"
                        id="temporalMode3days"
                        checked
                      />
                      <span>3 jours</span>
                    </label>
                    <label class="radio-label">
                      <input
                        type="radio"
                        name="temporalMode"
                        value="5days"
                        id="temporalMode5days"
                      />
                      <span>5 jours</span>
                    </label>
                  </div>
                </div>

                <div class="param-item" id="temporalControls">
                  <label for="temporalCenterWeight"
                    >Valeur centrale (H)
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">
                          Poids de l'heure actuelle
                        </div>
                        <div class="tooltip-effect">
                          Définit le pourcentage de poids attribué à l'heure
                          centrale H.
                        </div>
                        <div class="tooltip-example">
                          Ex: 80% → l'heure H aura 80% du poids total, le reste
                          sera réparti sur H±1 ou H±1±2.
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="temporalCenterWeight"
                      min="20"
                      max="95"
                      step="5"
                      value="80"
                    />
                    <span class="slider-value" id="temporalCenterWeightValue"
                      >80%</span
                    >
                  </div>
                </div>

                <div class="param-item" id="temporalConcentrationControl">
                  <label for="temporalConcentration"
                    >Concentration autour de H
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">Focus temporal</div>
                        <div class="tooltip-effect">
                          Plus élevé = poids plus concentrés près de H. Plus bas
                          = poids plus étalés.
                        </div>
                        <div class="tooltip-example">
                          Ex: 20% → poids étalés [15%,70%,15%], 80% → poids
                          concentrés [5%,90%,5%].
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="temporalConcentration"
                      min="10"
                      max="90"
                      step="10"
                      value="50"
                    />
                    <span class="slider-value" id="temporalConcentrationValue"
                      >50%</span
                    >
                  </div>
                </div>

                <div class="param-item" id="temporalWeightsDisplay">
                  <label>Pondérations calculées :</label>
                  <div class="weights-display" id="weightsDisplay">
                    <span class="weight-badge" id="weightDisplay"
                      >10% - 80% - 10%</span
                    >
                  </div>
                </div>
              </div>

              <div class="param-group">
                <h4>🔹 Gestion des pics isolés</h4>

                <div class="param-item">
                  <label>
                    <input type="checkbox" id="detectIsolatedPeaks" checked />
                    Activer détection de pic isolé
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">
                          Détection des orages isolés
                        </div>
                        <div class="tooltip-effect">
                          Identifie les pics de précipitation entourés de
                          périodes sèches (T > 2×(T-1+T+1)).
                        </div>
                        <div class="tooltip-example">
                          Ex: Détecte orage de 15h entre 2 périodes sans pluie.
                          Utile pour averses convectives été.
                        </div>
                      </div>
                    </div>
                  </label>
                </div>

                <div class="param-item">
                  <label for="kFactor"
                    >Renforcement des pics isolés (k)
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">Force du boost de pic</div>
                        <div class="tooltip-effect">
                          Intensité de renforcement appliquée aux pics isolés
                          détectés. Plus haut = boost plus fort.
                        </div>
                        <div class="tooltip-example">
                          Ex: 0.2 = boost modéré, 0.5 = boost fort. Augmenter en
                          été (orages), réduire en hiver.
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="kFactor"
                      min="0.0"
                      max="1.0"
                      step="0.05"
                      value="0.35"
                    />
                    <span class="slider-value" id="kFactorValue">0.35</span>
                  </div>
                </div>

                <div class="param-item">
                  <label for="minWetModels"
                    >Seuil de modèles mouillants pour garder un pic
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">Validation de consensus</div>
                        <div class="tooltip-effect">
                          % minimum de modèles qui doivent prévoir de la pluie
                          pour valider un pic isolé.
                        </div>
                        <div class="tooltip-example">
                          Ex: 30% = 3 modèles sur 10 minimum. Augmenter (50%)
                          pour être plus strict, réduire (20%) pour plus de
                          sensibilité.
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="minWetModels"
                      min="0.0"
                      max="1.0"
                      step="0.1"
                      value="0.3"
                    />
                    <span class="slider-value" id="minWetModelsValue">30%</span>
                  </div>
                </div>
              </div>

              <div class="param-group">
                <h4>🔹 Paramètres avancés</h4>

                <div class="param-item">
                  <label for="boostMalus"
                    >Bonus/malus selon modèles mouillants
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">
                          Ajustement par consensus
                        </div>
                        <div class="tooltip-effect">
                          Augmente la probabilité si beaucoup de modèles
                          d'accord, la réduit si peu d'accord.
                        </div>
                        <div class="tooltip-example">
                          Ex: 8 modèles sur 10 d'accord = boost +10%, 2 modèles
                          sur 10 = malus -10%. Expérimental.
                        </div>
                      </div>
                    </div>
                  </label>
                  <label>
                    <input type="checkbox" id="enableBoostMalus" />
                    Activer
                  </label>
                </div>

                <div class="param-item">
                  <label for="neutralModels"
                    >Seuil de neutralité (nb modèles)</label
                  >
                  <div class="slider-container">
                    <input
                      type="range"
                      id="neutralModels"
                      min="3"
                      max="10"
                      step="1"
                      value="6"
                    />
                    <span class="slider-value" id="neutralModelsValue">6</span>
                  </div>
                </div>

                <div class="param-item">
                  <label for="boostCoeff">Coefficient de boost/malus</label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="boostCoeff"
                      min="0.01"
                      max="0.05"
                      step="0.005"
                      value="0.02"
                    />
                    <span class="slider-value" id="boostCoeffValue">0.02</span>
                  </div>
                </div>

                <div class="param-item">
                  <label for="probCap"
                    >Cap de proba finale
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">Limite maximum</div>
                        <div class="tooltip-effect">
                          Limite la probabilité maximale que peut atteindre
                          l'algorithme, même avec tous les modèles d'accord.
                        </div>
                        <div class="tooltip-example">
                          Ex: 90% évite sur-confiance, 100% garde pleine gamme.
                          Utiliser 90% si surestimation fréquente.
                        </div>
                      </div>
                    </div>
                  </label>
                  <select id="probCap">
                    <option value="0.9">90%</option>
                    <option value="1.0" selected>100%</option>
                    <option value="unlimited">Illimité</option>
                  </select>
                </div>
              </div>
            </div>

            <!-- Boutons d'action -->
            <div class="rain-params-actions">
              <button class="btn-primary" id="applyParams">
                🚀 Appliquer paramètres
              </button>
              <button class="btn-secondary" id="resetParams">
                🔄 Reset défaut
              </button>
              <button class="btn-secondary" id="savePreset">
                💾 Sauver preset
              </button>
              <button class="btn-secondary" id="loadPreset">
                📂 Charger preset
              </button>
            </div>

            <!-- Visualisation en temps réel -->
            <div class="param-visualization">
              <h4>📊 Visualisation paramètres</h4>
              <div class="viz-stats">
                <div class="stat-item">
                  <span class="stat-label">Proba moyenne:</span>
                  <span class="stat-value" id="avgProba">--</span>
                </div>
                <div class="stat-item">
                  <span class="stat-label">Pics détectés:</span>
                  <span class="stat-value" id="peaksDetected">--</span>
                </div>
                <div class="stat-item">
                  <span class="stat-label">Lissage appliqué:</span>
                  <span class="stat-value" id="smoothingApplied">--</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Wind Radar Chart Section -->
        <div
          class="wind-radar-section"
          id="windRadarSection"
          style="display: none"
        >
          <div
            style="
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 16px;
            "
          >
            <h3 style="margin: 0">🌪️ Rose des vents</h3>
          </div>
          <div
            class="radar-container"
            style="position: relative; height: 600px; margin-bottom: 20px"
          >
            <canvas id="windRadarChart"></canvas>
          </div>
          <div
            class="time-slider-container"
            style="
              padding: 16px;
              background: var(--background);
              border-radius: 8px;
            "
          >
            <label
              for="timeSlider"
              style="font-weight: 600; margin-bottom: 8px; display: block"
            >
              <span id="currentTimeLabel">Heure: 0H</span>
            </label>
            <input
              type="range"
              id="timeSlider"
              min="0"
              max="167"
              value="0"
              style="width: 100%; margin-bottom: 8px"
            />
            <div
              style="
                display: flex;
                justify-content: space-between;
                font-size: 0.8rem;
                color: var(--text-muted);
              "
            >
              <span>0H</span>
              <span>167H</span>
            </div>
          </div>
        </div>
      </section>

      <!-- Analysis Panel Section -->
      <div class="container">
        <section
          class="analysis-section"
          id="analysisSection"
          style="
            display: none;
            background: #ffffff;
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
            margin-bottom: 24px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
          "
        >
          <h2
            style="
              margin: 0 0 16px 0;
              color: #1f2937;
              font-size: 1.4rem;
              font-weight: 600;
              position: relative;
              display: inline-flex;
              align-items: center;
            "
          >
            🎯 Analyse de Corrélation des Modèles
            <span
              class="tooltip-trigger"
              style="margin-left: 6px; cursor: help; font-size: 16px"
              >ℹ️</span
            >
            <div
              class="tooltip-content"
              style="
                position: absolute;
                top: 100%;
                left: 0;
                width: 400px;
                background: #1a1a1a;
                border: 1px solid #333;
                border-radius: 8px;
                padding: 16px;
                color: #fff;
                font-size: 14px;
                line-height: 1.4;
                z-index: 1000;
                display: none;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
              "
            >
              <!-- same explanatory content -->
              <strong
                >La proximité d'un modèle à la moyenne des autres : un bon
                indicateur de fiabilité ?</strong
              ><br /><br />
              ✅ <strong>Oui, mais avec précautions :</strong><br />
              Un modèle proche de la moyenne agrégée (quelle que soit la
              stratégie : médiane, pondérée, gaussienne…) est généralement plus
              "consensuel".<br /><br />

              Cela n'implique pas directement qu'il est "meilleur". Il peut être
              proche de la moyenne par chance ou parce que tous les modèles se
              trompent ensemble.<br /><br />

              En météo, certains modèles "déclencheurs" ou très réactifs (ex.
              ICON, AROME) peuvent sortir de la moyenne mais parfois captent une
              réalité que les autres lissent.<br /><br />

              🔍 <strong>Limite :</strong> La moyenne peut elle-même être fausse
              si tous les modèles convergent vers une erreur (cas d'un front mal
              positionné, etc.).<br /><br />

              🧭 <strong>Ce que ça mesure vraiment :</strong><br />
              Une proximité statistique, utile pour :<br />
              • Identifier les modèles stables<br />
              • Mesurer la cohérence temporelle<br />
              • Éliminer les modèles erratiques (grandes oscillations non
              justifiées)<br /><br />

              🟢 Donc oui, utiliser l'écart-type moyen par rapport à la moyenne
              est un bon critère de "confiance relative".<br /><br />

              📊
              <strong
                >Si un modèle domine 72 fois (8 paramètres × 9 villes) : est-ce
                le n°1 ?</strong
              ><br />
              ✅ Oui, tu peux le valoriser fortement :<br />
              Cela montre une cohérence globale, multi-paramètre et
              multi-locale.<br /><br />

              ⚠️ <strong>Mais attention :</strong><br />
              Ce score est corrélé à ta méthode de moyenne.<br />
              Si tu choisis une moyenne gaussienne, tu favorises les modèles
              centrés, parfois au détriment des modèles plus extrêmes mais
              justes.<br />
              Ce modèle n'est pas forcément le plus précis localement : il est
              le plus consensuel.
            </div>
          </h2>

          <!-- Panel d'analyse des gagnants/perdants 
          <div
            class="analysis-panel"
            style="
              padding: 16px;
              background: #f8fafc;
              border-radius: 8px;
              border: 1px solid #e2e8f0;
            "
          >-->
          <div
            style="
              display: flex;
              align-items: center;
              gap: 8px;
              margin-bottom: 16px;
            "
          ></div>

          <div id="analysisResults" style="color: #130535">
            <div style="margin-bottom: 12px; font-size: 14px">
              <strong style="color: #1f2937">Agrégation :</strong>
              <span
                id="aggregationName"
                style="color: #059669; font-weight: 500"
                >-</span
              >
              |
              <strong style="color: #1f2937">Écart-type moyen :</strong>
              <span
                id="aggregationStdDev"
                style="color: #dc2626; font-weight: 500"
                >-</span
              >
            </div>

            <!-- Tableau de comparaison des valeurs -->
            <div
              style="
                background: #f8fafc;
                border-radius: 8px;
                padding: 16px;
                margin-bottom: 16px;
                border: 1px solid #e5e7eb;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
              "
            >
              <h4
                style="
                  margin: 0 0 12px 0;
                  color: #1f2937;
                  font-size: 16px;
                  font-weight: 600;
                "
              >
                📊 Comparaison des 28 valeurs
              </h4>
              <div id="comparisonTable" style="overflow-x: auto">
                <table
                  style="
                    width: 100%;
                    border-collapse: collapse;
                    font-size: 11px;
                    background: #ffffff;
                  "
                >
                  <thead>
                    <tr id="tableHeaders" style="background: #f1f5f9">
                      <th
                        style="
                          padding: 8px;
                          border: 1px solid #e2e8f0;
                          color: #475569;
                          text-align: left;
                          font-weight: 600;
                        "
                      >
                        Modèle
                      </th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr id="aggregationRow" style="background: #ecfdf5"></tr>
                    <tr id="winnerRow" style="background: #f0fdf4"></tr>
                    <tr id="loserRow" style="background: #fef2f2"></tr>
                  </tbody>
                </table>
              </div>
            </div>

            <div style="margin-bottom: 16px">
              <strong>Stratégie d'analyse :</strong>
              <div
                style="
                  display: flex;
                  gap: 8px;
                  margin-top: 8px;
                  flex-wrap: wrap;
                  justify-content: center;
                "
              >
                <button
                  class="analysis-btn active"
                  data-range="short"
                  style="
                    padding: 6px 12px;
                    background: #666;
                    color: #fff;
                    border: 1px solid #888;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                  "
                >
                  0-48h (Court terme)
                </button>
                <button
                  class="analysis-btn"
                  data-range="medium"
                  style="
                    padding: 6px 12px;
                    background: #333;
                    color: #fff;
                    border: 1px solid #555;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                  "
                >
                  48-96h (Moyen terme)
                </button>
                <button
                  class="analysis-btn"
                  data-range="long"
                  style="
                    padding: 6px 12px;
                    background: #333;
                    color: #fff;
                    border: 1px solid #555;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                  "
                >
                  96-168h (Long terme)
                </button>
                <button
                  class="analysis-btn"
                  data-range="prorated"
                  style="
                    padding: 6px 12px;
                    background: #444;
                    color: #fff;
                    border: 1px solid #666;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                  "
                >
                  Proratisé
                </button>
                <button
                  class="analysis-btn"
                  data-range="weighted"
                  style="
                    padding: 6px 12px;
                    background: #444;
                    color: #fff;
                    border: 1px solid #666;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                  "
                >
                  Pondéré temporel
                </button>
                <button
                  class="analysis-btn"
                  data-range="composite"
                  style="
                    padding: 6px 12px;
                    background: #444;
                    color: #fff;
                    border: 1px solid #666;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                  "
                >
                  Score mixte
                </button>
              </div>
            </div>

            <div
              id="analysisExplanation"
              style="
                font-size: 13px;
                color: #ccc;
                background: rgba(255, 255, 255, 0.03);
                padding: 12px;
                border-radius: 6px;
                margin-top: 12px;
              "
            >
              Pour utiliser ce panel :<br />
              1️⃣ Sélectionnez des modèles météo<br />
              2️⃣ Allez dans "🔧 Stratégies d'agrégation"<br />
              3️⃣ Cliquez "⚡ Appliquer la stratégie"<br />
              4️⃣ L'analyse s'affichera automatiquement ici !
            </div>
            <!-- </div> -->
          </div>
        </section>
      </div>

      <!-- Aggregation Section -->
      <section
        class="aggregation-section"
        id="aggregationSection"
        style="display: none"
      >
        <h2>🔧 Stratégies d'agrégation</h2>
        <div class="strategy-grid" id="strategyGrid">
          <!-- Strategies will be populated by JavaScript -->
        </div>

        <!-- Didactic Mode -->
        <div class="didactic-mode">
          <div class="didactic-title">📚 Mode didactique</div>
          <div id="didacticContent">
            <!-- Content will be populated by JavaScript -->
          </div>
        </div>

        <div class="action-buttons">
          <button class="btn btn-primary" id="applyStrategy">
            ⚡ Appliquer la stratégie
          </button>
        </div>
        <div class="chart-container" style="margin-top: 24px">
          <canvas id="aggregatedChart"></canvas>
        </div>
      </section>
    </div>

    <script>
      // Configuration des villes
      const CITIES = {
        Plomeur: { lat: 47.8322, lng: -4.3486 },
        Surzur: { lat: 47.5669, lng: -2.6219 },
        Biarritz: { lat: 43.4832, lng: -1.5586 },
        Paris: { lat: 48.8566, lng: 2.3522 },
        Colmar: { lat: 48.0793, lng: 7.355 },
        "Cap-Corse": { lat: 42.9667, lng: 9.4167 },
        Annecy: { lat: 45.8992, lng: 6.1289 },
        Brest: { lat: 48.3904, lng: -4.4861 },
        Cherbourg: { lat: 49.6337, lng: -1.6222 },
      };

      // Configuration des paramètres
      const PARAMETERS = {
        temperature: {
          label: "🌡️ Température",
          unit: "°C",
          apiParams: ["temperature_2m"],
        },
        apparent_temperature: {
          label: "🌡️ Température apparente",
          unit: "°C",
          apiParams: ["apparent_temperature"],
        },
        humidity: {
          label: "💧 Humidité",
          unit: "%",
          apiParams: ["relative_humidity_2m"],
        },
        precipitation_probability: {
          label: "☔ Précipitation %",
          unit: "%",
          apiParams: ["precipitation_probability"],
        },
        precipitation: {
          label: "🌧️ Précipitation mm",
          unit: "mm",
          apiParams: ["precipitation"],
        },
        wind_speed: {
          label: "💨 Force du vent",
          unit: "km/h",
          apiParams: ["wind_speed_10m"],
        },
        wind_gusts: {
          label: "💨 Rafales",
          unit: "km/h",
          apiParams: ["wind_gusts_10m"],
        },
        wind_direction: {
          label: "🧭 Direction du vent",
          unit: "°",
          apiParams: ["wind_direction_10m"],
        },
      };

      // Configuration des modèles par terme
      const MODEL_GROUPS = {
        "short-term": {
          label: "⚡ Court terme",
          models: [
            "meteofrance_arome_france",
            "meteofrance_arome_france_hd",
            "knmi_harmonie_arome_europe",
            "ukmo_uk_deterministic_2km",
          ],
        },
        "medium-term": {
          label: "🌤️ Moyen terme",
          models: [
            "meteofrance_arpege_europe",
            "icon_eu",
            "ukmo_global_deterministic_10km",
          ],
        },
        "long-term": {
          label: "🌍 Long terme",
          models: [
            "gfs_global",
            "gfs_graphcast025",
            "ecmwf_ifs025",
            "icon_global",
          ],
        },
      };

      // Configuration des modèles (base)
      const MODELS_BASE = [
        "icon_eu",
        "icon_global",
        "meteofrance_arome_france",
        "meteofrance_arome_france_hd",
        "meteofrance_arpege_europe",
        "ukmo_global_deterministic_10km",
        "ukmo_uk_deterministic_2km",
        "gfs_graphcast025",
        "gfs_global",
        "ecmwf_ifs025",
        "knmi_harmonie_arome_europe",
      ];

      // Mapping des noms de modèles courts
      const MODEL_DISPLAY_NAMES = {
        meteofrance_arome_france: "MF AROME FRANCE",
        meteofrance_arome_france_hd: "MF AROME FRANCE HD",
        knmi_harmonie_arome_europe: "KNMI HARMONIE AROME EU",
        ukmo_uk_deterministic_2km: "UKMO DETERM 2KM",
        meteofrance_arpege_europe: "MF ARPEGE EU",
        icon_eu: "ICON EU",
        ukmo_global_deterministic_10km: "UKMO GLOBAL DETERM 10KM",
        gfs_global: "GFS GLOBAL 0.11°/0.25°",
        gfs_graphcast025: "GFS GRAPHCAST",
        ecmwf_ifs025: "ECMWF IFS 0.25°",
        icon_global: "ICON GLOBAL",
      };

      // Liste réellement utilisée ; sera mise à jour par ville
      let MODELS = [...MODELS_BASE];

      // Couleurs dédiées par modèle (contraste élevé)
      const MODEL_COLORS = {
        meteofrance_arome_france: "#3498DB", // AROME FRANCE
        meteofrance_arome_france_hd: "#A3C6FF", // AROME FRANCE HD
        meteofrance_arpege_europe: "#BBDEFB", // ARPEGE EUROPE
        icon_eu: "#FFFF6B", // ICON EU
        icon_global: "#F39C12", // ICON GLOBAL
        ukmo_global_deterministic_10km: "#58D68D", // UKMO GLOBAL 10KM
        ukmo_uk_deterministic_2km: "#A3E4D7", // UKMO UK 2KM
        gfs_graphcast025: "#FF7E79", // GFS GRAPHCAST025 - Rouge corail
        gfs_global: "#FFB3AB", // GFS GLOBAL - Rose clair
        ecmwf_ifs025: "#b17652", // ECMWF IFS025
        knmi_harmonie_arome_europe: "#CE93D8", // KNMI HARMONIE
      };

      function getTextColorForBg(hex) {
        // Calculate luminance to decide black or white text
        hex = hex.replace("#", "");
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
        return luminance > 0.6 ? "#000" : "#fff";
      }

      // Stratégies d'agrégation avec mode didactique
      const STRATEGIES = {
        mean: {
          label: "Moyenne arithmétique",
          color: "#e74c3c",
          description: "Moyenne simple, sensible aux valeurs extrêmes.",
          formula:
            "(15+16+17)/3 = 16.0 | (10+12+50+13)/4 = 21.25 | (5+6+7+100+8)/5 = 25.2",
          explanation:
            "Très simple à calculer mais peu robuste. Dès qu'une valeur extrême est présente, la moyenne est fortement déformée.",
          useCases: [
            "Température",
            "Humidité",
            "Précipitations mm",
            "Force du vent",
          ],
          examples: {
            values3: [15, 16, 17],
            values4: [10, 12, 50, 13],
            values5: [5, 6, 7, 100, 8],
          },
        },
        median: {
          label: "Médiane",
          color: "#3498db",
          description:
            "Valeur centrale d'un ensemble trié, robuste aux extrêmes.",
          formula: "16 | (12+13)/2 = 12.5 | 7",
          explanation:
            "Robuste face aux valeurs extrêmes. Pertinente pour décrire une 'valeur typique' dans des distributions asymétriques.",
          useCases: ["Température", "Précipitations mm", "Rafale de vent"],
          examples: {
            values3: [15, 16, 17],
            values4: [10, 12, 50, 13],
            values5: [5, 6, 7, 100, 8],
          },
        },
        trimmed_mean: {
          label: "Moyenne tronquée",
          color: "#f39c12",
          description: "On enlève les extrêmes avant de faire la moyenne.",
          formula: "16.0 | (12+13)/2 = 12.5 | (6+7+8)/3 = 7.0",
          explanation:
            "Bonne alternative à la moyenne classique en présence d'outliers. Nécessite un nombre suffisant de données pour fonctionner.",
          useCases: ["Température", "Précipitations mm", "Rafales de vent"],
          examples: {
            values3: [15, 16, 17],
            values4: [10, 12, 50, 13],
            values5: [5, 6, 7, 100, 8],
          },
        },
        precipitation_algo: {
          label: "Algo Précipitation",
          color: "#9b59b6",
          description:
            "Algorithme spécialisé pour les précipitations avec probabilité corrigée et pondération gaussienne.",
          formula:
            "P_corrected = P_raw × (1 + α × (variance_ratio - 1) × log(1 + mm_moyenne))",
          explanation:
            "Algorithme avancé spécialement conçu pour les précipitations. Calcule une probabilité corrigée basée sur la variance des modèles et applique une pondération gaussienne pour la pluviométrie avec traitement des pics isolés.",
          useCases: ["Précipitations %", "Précipitations mm"],
          examples: {
            values3: [0.1, 2.5, 0.8],
            values4: [0.0, 1.2, 15.0, 0.5],
            values5: [0.2, 0.8, 1.5, 25.0, 0.3],
          },
        },
        winsorized_mean: {
          label: "Winsorized Mean",
          color: "#1abc9c",
          description:
            "Remplace les extrêmes par les valeurs les plus proches restantes.",
          formula: "16.0 | (10+12+13+13)/4 = 12.0 | (6+6+7+8+8)/5 = 7.0",
          explanation:
            "Utile si l'on souhaite garder toutes les données sans supprimer mais limiter l'effet des extrêmes.",
          useCases: [
            "Température",
            "Humidité",
            "Précipitations mm",
            "Rafales de vent",
          ],
          examples: {
            values3: [15, 16, 17],
            values4: [10, 12, 50, 13],
            values5: [5, 6, 7, 100, 8],
          },
        },
        gaussian_weighted: {
          label: "Pondération gaussienne",
          color: "#34495e",
          description:
            "On pondère les valeurs selon leur proximité avec la moyenne.",
          formula: "≈ 16.0 | ≈ 13.4 | ≈ 7.4",
          explanation:
            "Méthode élégante et souple pour lisser les effets extrêmes. Elle réduit l'influence des outliers sans les supprimer.",
          useCases: ["Température", "Précipitation mm", "Rafale de vent"],
          examples: {
            values3: [15, 16, 17],
            values4: [10, 12, 50, 13],
            values5: [5, 6, 7, 100, 8],
          },
        },
      };

      // Variables globales
      let selectedCity = null;
      let weatherData = null;
      let weatherDataCache = {}; // Cache des données par ville
      let currentChart = null;
      let aggregatedChart = null;
      let selectedModels = {};
      let selectedStrategy = "mean";
      let isInitializing = false;
      let precipitationMode = "stacked"; // "stacked" or "behind"
      let windDirectionMode = "points"; // "points" or "lines"
      let windRadarChart = null;
      let currentTimeIndex = 0;
      let windChartType = "radar"; // Always radar now
      let maxWindSpeedInData = 50; // Will be calculated from the full dataset

      // Register Chart.js plugins - simplified version (no time scale)
      Chart.register(
        Chart.LineController,
        Chart.BarController,
        Chart.ScatterController,
        Chart.RadarController,

        Chart.LineElement,
        Chart.BarElement,
        Chart.PointElement,
        Chart.ArcElement,
        Chart.RadialLinearScale,
        Chart.LinearScale,
        Chart.CategoryScale,
        Chart.Title,
        Chart.Tooltip,
        Chart.Legend
      );

      // Register zoom plugin if available
      if (typeof ChartZoom !== "undefined") {
        Chart.register(ChartZoom);
      }

      // Initialisation
      document.addEventListener("DOMContentLoaded", async function () {
        initializeCities();
        initializeTabs();
        initializeStrategies();
        setupEventListeners();
        setupQuickActions();
        initRainParamsEventListeners();
        updateRainParamsUI();

        // Auto-sélectionner Plomeur et charger ses données
        await autoInitializeWithPlomeur();
      });

      function initializeCities() {
        const citiesGrid = document.getElementById("citiesGrid");

        Object.entries(CITIES).forEach(([cityName, coords]) => {
          const cityBtn = document.createElement("button");
          cityBtn.className = "city-btn";
          cityBtn.textContent = cityName;
          cityBtn.dataset.city = cityName;
          cityBtn.addEventListener(
            "click",
            async () => await selectCity(cityName, coords)
          );
          citiesGrid.appendChild(cityBtn);
        });
      }

      async function selectCity(cityName, coords) {
        selectedCity = { name: cityName, ...coords };

        /* Mettre à jour la liste MODELS selon la ville (exclure UKMO 2 km hors Royaume-Uni) */
        if (["Biarritz", "Cap-Corse"].includes(cityName)) {
          MODELS = MODELS_BASE.filter((m) => m !== "ukmo_uk_deterministic_2km");
        } else {
          MODELS = [...MODELS_BASE];
        }

        // Update UI
        document.querySelectorAll(".city-btn").forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.city === cityName);
        });

        // Update city info in both locations
        const cityInfo = document.getElementById("selectedCityInfo");
        const chartCityInfo = document.getElementById("chartCityInfo");
        document.getElementById("cityName").textContent = cityName;
        document.getElementById(
          "cityCoords"
        ).textContent = `${coords.lat.toFixed(4)}, ${coords.lng.toFixed(4)}`;
        cityInfo.style.display = "block";

        // Update chart city info
        if (chartCityInfo) {
          chartCityInfo.innerHTML = `<strong>Ville sélectionnée:</strong> ${cityName} <strong>Coordonnées:</strong> ${coords.lat.toFixed(
            4
          )}, ${coords.lng.toFixed(4)}°`;
        }

        // Si pas en cours d'initialisation et pas de données en cache, charger les données
        if (!isInitializing && !weatherDataCache[cityName]) {
          try {
            showLoading(`Chargement des données pour ${cityName}...`);
            await loadCityData(cityName);

            // Mettre à jour le graphique si les données existent
            if (weatherData) {
              await populateModelSelections();
              updateChartControls();
              createMainChart();
              updateMainChart();

              // Afficher les sections
              document.getElementById("chartsSection").style.display = "block";
              document.getElementById("aggregationSection").style.display =
                "block";
            }
          } catch (error) {
            console.error(
              `Erreur lors du chargement des données pour ${cityName}:`,
              error
            );
            alert(`Erreur lors du chargement des données pour ${cityName}`);
          }
        } else if (weatherDataCache[cityName]) {
          // Utiliser les données du cache
          weatherData = weatherDataCache[cityName];

          if (!isInitializing) {
            await populateModelSelections();
            updateChartControls();
            createMainChart();
            updateMainChart();

            // Afficher les sections
            document.getElementById("chartsSection").style.display = "block";
            document.getElementById("aggregationSection").style.display =
              "block";
          }
        }
      }

      function initializeTabs() {
        const tabsNav = document.getElementById("tabsNav");
        const tabsContent = document.getElementById("tabsContent");

        Object.entries(PARAMETERS).forEach(([paramKey, paramConfig], index) => {
          // Create tab button
          const tabBtn = document.createElement("button");
          tabBtn.className = `tab-btn ${index === 0 ? "active" : ""}`;
          tabBtn.textContent = paramConfig.label;
          tabBtn.dataset.param = paramKey;
          tabBtn.addEventListener("click", () => switchTab(paramKey));
          tabsNav.appendChild(tabBtn);

          // Create tab content with new column layout
          const tabContent = document.createElement("div");
          tabContent.className = `tab-content ${index === 0 ? "active" : ""}`;
          tabContent.id = `tab-${paramKey}`;
          tabContent.innerHTML = createTabContent(paramKey, paramConfig);
          tabsContent.appendChild(tabContent);
        });

        // Initialize selected models
        Object.keys(PARAMETERS).forEach((paramKey) => {
          selectedModels[paramKey] = {};
        });
      }

      function createTabContent(paramKey, paramConfig) {
        return `
          <div class="models-columns" id="models-${paramKey}">
            <div class="loading">
              <div class="spinner"></div>
              Chargement des modèles disponibles...
            </div>
          </div>
        `;
      }

      function switchTab(paramKey) {
        // Update tab buttons
        document.querySelectorAll(".tab-btn").forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.param === paramKey);
        });

        // Update tab content
        document.querySelectorAll(".tab-content").forEach((content) => {
          content.classList.toggle("active", content.id === `tab-${paramKey}`);
        });

        // Update strategy didactic content
        updateDidacticContent();

        // Show/hide precipitation mode button
        const precipitationBtn = document.getElementById(
          "precipitationModeBtn"
        );
        if (precipitationBtn) {
          precipitationBtn.style.display =
            paramKey === "precipitation" ? "block" : "none";
        }

        // Show/hide rain parameters panel
        const isRainParam =
          paramKey === "precipitation" ||
          paramKey === "precipitation_probability";
        toggleRainParamsPanel(isRainParam);

        // Show/hide wind direction mode button
        const windDirectionBtn = document.getElementById(
          "windDirectionModeBtn"
        );
        if (windDirectionBtn) {
          windDirectionBtn.style.display =
            paramKey === "wind_direction" ? "block" : "none";
        }

        // Show/hide wind radar section
        const windRadarSection = document.getElementById("windRadarSection");
        if (windRadarSection) {
          const shouldShow =
            paramKey === "wind_speed" || paramKey === "wind_direction";
          windRadarSection.style.display = shouldShow ? "block" : "none";

          if (shouldShow) {
            createWindRadarChart(); // Always recreate to recalculate scale
          }
        }

        // Update chart controls and recreate chart for the new parameter (sans appel API)
        if (
          weatherData &&
          document.getElementById("chartsSection").style.display !== "none"
        ) {
          updateChartControls();
          createMainChart();
          updateMainChart();
        }
      }

      function initializeStrategies() {
        const strategyGrid = document.getElementById("strategyGrid");

        Object.entries(STRATEGIES).forEach(([strategyKey, strategyConfig]) => {
          const strategyCard = document.createElement("div");
          strategyCard.className = `strategy-card ${
            strategyKey === selectedStrategy ? "active" : ""
          }`;
          strategyCard.dataset.strategy = strategyKey;
          strategyCard.style.borderColor = strategyConfig.color;
          strategyCard.style.color = strategyConfig.color;
          strategyCard.textContent = strategyConfig.label;

          if (strategyKey === selectedStrategy) {
            strategyCard.style.backgroundColor = strategyConfig.color;
            strategyCard.style.color = "white";
          }

          strategyCard.addEventListener("click", () =>
            selectStrategy(strategyKey)
          );
          strategyGrid.appendChild(strategyCard);
        });

        // Initialize didactic content
        updateDidacticContent();
      }

      function selectStrategy(strategyKey) {
        selectedStrategy = strategyKey;
        document.querySelectorAll(".strategy-card").forEach((card) => {
          const isActive = card.dataset.strategy === strategyKey;
          const strategyData = STRATEGIES[card.dataset.strategy];

          card.classList.toggle("active", isActive);

          if (isActive) {
            card.style.backgroundColor = strategyData.color;
            card.style.color = "white";
          } else {
            card.style.backgroundColor = "var(--surface)";
            card.style.color = strategyData.color;
          }
        });

        // Update didactic content
        updateDidacticContent();

        // Mettre à jour la ligne d'agrégation sur le graphique principal
        updateAggregateDataset();

        // Update wind radar if visible
        if (windRadarChart) {
          updateWindRadar();
        }

        // 🎯 Mettre à jour le panneau d'analyse automatiquement
        if (weatherData) {
          const aggregatedData = extractAggregationFromMainChart();
          if (aggregatedData) {
            updateAnalysisPanel(weatherData, aggregatedData);
            console.log(
              "🎯 Panel d'analyse mis à jour suite au changement de stratégie"
            );
          }
        }
      }

      function updateDidacticContent() {
        const strategyData = STRATEGIES[selectedStrategy];
        const didacticContent = document.getElementById("didacticContent");

        if (!strategyData) return;

        // Calculate example results
        const examples = strategyData.examples;
        const activeParam =
          document.querySelector(".tab-btn.active")?.dataset.param;
        const isWindDirection = activeParam === "wind_direction";

        // Use circular examples for wind direction
        const exampleValues = isWindDirection
          ? {
              values3: [301, 9],
              values4: [350, 10, 20, 30],
              values5: [340, 350, 10, 20, 30],
            }
          : examples;

        const result3 = applyAggregationStrategy(
          exampleValues.values3,
          selectedStrategy,
          isWindDirection
        );
        const result4 = applyAggregationStrategy(
          exampleValues.values4,
          selectedStrategy,
          isWindDirection
        );
        const result5 = applyAggregationStrategy(
          exampleValues.values5,
          selectedStrategy,
          isWindDirection
        );

        didacticContent.innerHTML = `
          <div class="didactic-content active" style="border-left: 4px solid ${
            strategyData.color
          };">
            <h3 style="color: ${strategyData.color};">${strategyData.label}</h3>
            <p><strong>Description:</strong> ${strategyData.description}</p>

            <div class="math-formula" style="border-left-color: ${
              strategyData.color
            };">
              <strong>Résultats:</strong> ${strategyData.formula}
            </div>

            <div class="example-grid">
              <div class="example-card">
                <div class="example-title" style="color: ${
                  strategyData.color
                };">Set 1 (${isWindDirection ? "2" : "3"} valeurs)</div>
                <div class="example-values">Données: [${exampleValues.values3.join(
                  ", "
                )}]${isWindDirection ? "°" : ""}</div>
                <div class="example-values"><strong>Résultat: ${result3.toFixed(
                  2
                )}${isWindDirection ? "°" : ""}</strong></div>
              </div>

              <div class="example-card">
                <div class="example-title" style="color: ${
                  strategyData.color
                };">Set 2 (4 valeurs)</div>
                <div class="example-values">Données: [${exampleValues.values4.join(
                  ", "
                )}]${isWindDirection ? "°" : ""}</div>
                <div class="example-values"><strong>Résultat: ${result4.toFixed(
                  2
                )}${isWindDirection ? "°" : ""}</strong></div>
              </div>

              <div class="example-card">
                <div class="example-title" style="color: ${
                  strategyData.color
                };">Set 3 (5 valeurs)</div>
                <div class="example-values">Données: [${exampleValues.values5.join(
                  ", "
                )}]${isWindDirection ? "°" : ""}</div>
                <div class="example-values"><strong>Résultat: ${result5.toFixed(
                  2
                )}${isWindDirection ? "°" : ""}</strong></div>
              </div>
            </div>

            <div class="use-cases">
              <div class="use-cases-title" style="color: ${
                strategyData.color
              };">📋 Paramètres pertinents:</div>
              <ul>
                ${strategyData.useCases
                  .map((useCase) => `<li>${useCase}</li>`)
                  .join("")}
              </ul>
            </div>

            <div class="use-cases" style="margin-top: 16px; background: ${
              strategyData.color
            }20; border: 1px solid ${strategyData.color};">
              <div class="use-cases-title" style="color: ${
                strategyData.color
              };">🎯 Conclusion:</div>
              <p style="margin: 8px 0; font-style: italic;">
                ${strategyData.explanation}
              </p>
              ${
                isWindDirection
                  ? `
                <div style="margin-top: 12px; padding: 8px; background: rgba(255, 193, 7, 0.2); border-radius: 4px; border-left: 4px solid #ffc107;">
                  <strong>🔁 Méthode circulaire adaptée:</strong> Les valeurs de direction du vent (0-360°) sont traitées avec des méthodes circulaires.
                  La moyenne de 350° et 10° donne bien 0° (et non 180°).
                </div>
              `
                  : ""
              }
            </div>
          </div>
        `;
      }

      function setupQuickActions() {
        document
          .getElementById("resetBtn")
          .addEventListener("click", resetParameters);
        document
          .getElementById("deselectBtn")
          .addEventListener("click", deselectAll);
        document
          .getElementById("progressiveBtn")
          .addEventListener("click", setProgressiveAlgo);
        document
          .getElementById("premiumBtn")
          .addEventListener("click", setPremiumModels);
      }

      function resetParameters() {
        // Sélectionner tous les modèles avec toutes les échéances
        selectAllModelsWithFullRange();
        syncInterfaceWithSelections();
        updateChartControls();
        if (currentChart) updateMainChart();
      }

      function deselectAll() {
        // Désélectionner tous les modèles
        Object.keys(PARAMETERS).forEach((paramKey) => {
          selectedModels[paramKey] = {};
        });
        syncInterfaceWithSelections();
        updateChartControls();
        if (currentChart) updateMainChart();
      }

      function setProgressiveAlgo() {
        // Configuration selon l'image 2 (algorithme progressif)
        const progressiveConfig = {
          meteofrance_arome_france: { start: 0, end: 60 },
          icon_eu: { start: 48, end: 134 },
          icon_global: { start: 96, end: 167 },
          meteofrance_arome_france_hd: { start: 0, end: 60 },
          meteofrance_arpege_europe: { start: 48, end: 116 },
          ukmo_global_deterministic_10km: { start: 48, end: 110 },
          ukmo_uk_deterministic_2km: { start: 0, end: 60 },
          gfs_graphcast025: { start: 96, end: 167 },
          gfs_global: { start: 96, end: 167 },
          ecmwf_ifs025: { start: 96, end: 167 },
          knmi_harmonie_arome_europe: { start: 0, end: 60 },
        };

        Object.keys(PARAMETERS).forEach((paramKey) => {
          selectedModels[paramKey] = {};
          Object.entries(progressiveConfig).forEach(([model, range]) => {
            if (
              MODELS.includes(model) &&
              checkModelHasData(model, PARAMETERS[paramKey].apiParams[0])
            ) {
              selectedModels[paramKey][model] = range;
            }
          });
        });

        syncInterfaceWithSelections();
        updateChartControls();
        if (currentChart) updateMainChart();
      }

      function setPremiumModels() {
        // Configuration Modèles Premium selon l'image 1
        const premiumConfig = {
          meteofrance_arome_france_hd: { start: 0, end: 60 },
          icon_eu: { start: 0, end: 134 },
          ukmo_global_deterministic_10km: { start: 0, end: 110 },
          gfs_graphcast025: { start: 0, end: 167 },
          ecmwf_ifs025: { start: 0, end: 167 },
          knmi_harmonie_arome_europe: { start: 0, end: 60 },
        };

        Object.keys(PARAMETERS).forEach((paramKey) => {
          selectedModels[paramKey] = {};
          Object.entries(premiumConfig).forEach(([model, range]) => {
            if (
              MODELS.includes(model) &&
              checkModelHasData(model, PARAMETERS[paramKey].apiParams[0])
            ) {
              selectedModels[paramKey][model] = range;
            }
          });
        });

        syncInterfaceWithSelections();
        updateChartControls();
        if (currentChart) updateMainChart();
      }

      function setupEventListeners() {
        document
          .getElementById("updateGraphic")
          .addEventListener("click", updateGraphic);
        document
          .getElementById("applyStrategy")
          .addEventListener("click", applyStrategy);
        document
          .getElementById("zoomResetBtn")
          .addEventListener("click", resetZoom);
        document
          .getElementById("precipitationModeBtn")
          .addEventListener("click", togglePrecipitationMode);
        document
          .getElementById("windDirectionModeBtn")
          .addEventListener("click", toggleWindDirectionMode);
        document
          .getElementById("timeSlider")
          .addEventListener("input", updateWindRadar);
      }

      function resetZoom() {
        if (currentChart) {
          currentChart.resetZoom();
          const zoomBtn = document.getElementById("zoomResetBtn");
          if (zoomBtn) {
            zoomBtn.style.display = "none";
          }
        }
      }

      function togglePrecipitationMode() {
        precipitationMode =
          precipitationMode === "stacked" ? "behind" : "stacked";
        const btn = document.getElementById("precipitationModeBtn");
        if (btn) {
          btn.textContent =
            precipitationMode === "stacked" ? "Stacked" : "Behind";
        }

        // Recreate chart with new mode
        const activeParam =
          document.querySelector(".tab-btn.active")?.dataset.param;
        if (activeParam === "precipitation") {
          createMainChart();
          updateMainChart();
        }
      }

      function toggleWindDirectionMode() {
        windDirectionMode = windDirectionMode === "points" ? "lines" : "points";
        const btn = document.getElementById("windDirectionModeBtn");
        if (btn) {
          btn.textContent =
            windDirectionMode === "points" ? "Points" : "Lignes";
        }

        // Recreate chart with new mode
        const activeParam =
          document.querySelector(".tab-btn.active")?.dataset.param;
        if (activeParam === "wind_direction") {
          createMainChart();
          updateMainChart();
        }
      }

      async function autoInitializeWithPlomeur() {
        try {
          console.log("🚀 Début de l'initialisation automatique avec Plomeur");
          isInitializing = true;

          // Sélectionner automatiquement Plomeur
          const plomeurCoords = CITIES["Plomeur"];
          await selectCity("Plomeur", plomeurCoords);

          // Charger les données pour Plomeur
          console.log("📡 Chargement des données pour Plomeur...");
          showLoading("Chargement initial des données pour Plomeur...");
          await loadCityData("Plomeur");
          console.log(
            "✅ Données chargées pour Plomeur:",
            weatherData ? "OK" : "ERREUR"
          );

          // Initialiser tous les modèles pour tous les paramètres
          console.log("🔧 Population des sélections de modèles...");
          await populateModelSelections();

          // Sélectionner TOUS les modèles avec TOUTES les échéances
          console.log(
            "📋 Sélection de tous les modèles avec échéances maximales..."
          );
          selectAllModelsWithFullRange();

          // Synchroniser l'interface avec les sélections
          console.log("🔄 Synchronisation de l'interface...");
          syncInterfaceWithSelections();

          isInitializing = false;

          // Créer le graphique automatiquement
          console.log("📊 Création du graphique...");
          updateChartControls();
          createMainChart();
          updateMainChart();

          // Afficher les sections
          document.getElementById("chartsSection").style.display = "block";
          document.getElementById("aggregationSection").style.display = "block";

          // Show/hide precipitation mode button
          const precipitationBtn = document.getElementById(
            "precipitationModeBtn"
          );
          if (precipitationBtn) {
            const activeParam =
              document.querySelector(".tab-btn.active")?.dataset.param;
            precipitationBtn.style.display =
              activeParam === "precipitation" ? "block" : "none";
          }

          console.log("✨ Initialisation automatique terminée pour Plomeur");
        } catch (error) {
          console.error(
            "❌ Erreur lors de l'initialisation automatique:",
            error
          );
          isInitializing = false;
        }
      }

      async function loadCityData(cityName) {
        if (!selectedCity) {
          throw new Error("Aucune ville sélectionnée");
        }

        // Vérifier si les données sont déjà en cache
        if (weatherDataCache[cityName]) {
          weatherData = weatherDataCache[cityName];
          console.log(`Données récupérées du cache pour ${cityName}`);
          return weatherData;
        }

        // Charger les données depuis l'API
        weatherData = await fetchWeatherData();

        // Stocker dans le cache
        weatherDataCache[cityName] = weatherData;
        console.log(`Données mises en cache pour ${cityName}`);

        return weatherData;
      }

      function selectAllModelsWithFullRange() {
        console.log("🎯 Début de selectAllModelsWithFullRange");

        Object.keys(PARAMETERS).forEach((paramKey) => {
          console.log(`🔧 Configuration pour paramètre: ${paramKey}`);
          selectedModels[paramKey] = {};

          MODELS.forEach((model) => {
            const hasData = checkModelHasData(
              model,
              PARAMETERS[paramKey].apiParams[0]
            );
            if (hasData) {
              const timeRange = getModelTimeRange(
                model,
                PARAMETERS[paramKey].apiParams[0]
              );
              selectedModels[paramKey][model] = {
                start: 0,
                end: timeRange.end,
              };
              console.log(
                `✅ ${model} configuré pour ${paramKey}: 0H - ${timeRange.end}H`
              );
            } else {
              console.log(`❌ ${model} pas de données pour ${paramKey}`);
            }
          });

          console.log(
            `📊 ${paramKey} - modèles configurés:`,
            Object.keys(selectedModels[paramKey])
          );
        });

        console.log(
          "✅ Tous les modèles sélectionnés avec échéances complètes"
        );
        console.log("📋 État final de selectedModels:", selectedModels);
      }

      async function updateGraphic() {
        console.log("🔄 updateGraphic - Début");
        if (!selectedCity) {
          alert("Veuillez sélectionner une ville");
          return;
        }

        try {
          console.log("📡 Chargement des données pour:", selectedCity.name);
          showLoading("Mise à jour du graphique...");

          // Charger les données si nécessaire
          await loadCityData(selectedCity.name);

          // NE PAS repopuler les sélections, garder les choix de l'utilisateur
          console.log(
            "📊 État actuel des modèles sélectionnés:",
            selectedModels
          );

          // Update chart controls after model selection
          updateChartControls();

          createMainChart();

          // Ensure chart controls are in sync with initial chart state
          updateMainChart();

          document.getElementById("chartsSection").style.display = "block";
          document.getElementById("aggregationSection").style.display = "block";

          // Show/hide precipitation mode button
          const precipitationBtn = document.getElementById(
            "precipitationModeBtn"
          );
          const windDirectionBtn = document.getElementById(
            "windDirectionModeBtn"
          );
          if (precipitationBtn || windDirectionBtn) {
            const activeParam =
              document.querySelector(".tab-btn.active")?.dataset.param;
            if (precipitationBtn) {
              precipitationBtn.style.display =
                activeParam === "precipitation" ? "block" : "none";
            }
            if (windDirectionBtn) {
              windDirectionBtn.style.display =
                activeParam === "wind_direction" ? "block" : "none";
            }

            // Show/hide wind radar section
            const windRadarSection =
              document.getElementById("windRadarSection");
            if (windRadarSection) {
              const shouldShow =
                activeParam === "wind_speed" ||
                activeParam === "wind_direction";
              windRadarSection.style.display = shouldShow ? "block" : "none";

              if (shouldShow) {
                createWindRadarChart(); // Always recreate to recalculate scale
              }
            }
          }

          console.log("✅ updateGraphic terminé avec succès");
        } catch (error) {
          console.error(
            "❌ Erreur lors de la récupération des données:",
            error
          );
          alert("Erreur lors de la récupération des données météo");
        }
      }

      async function fetchWeatherData() {
        const hourlyParams = [];
        Object.values(PARAMETERS).forEach((param) => {
          hourlyParams.push(...param.apiParams);
        });

        // Utiliser la liste MODELS (potentiellement filtrée) pour la requête
        const modelsForApi = [...MODELS];

        const url = new URL("https://api.open-meteo.com/v1/forecast");
        url.searchParams.set("latitude", selectedCity.lat);
        url.searchParams.set("longitude", selectedCity.lng);
        url.searchParams.set("timezone", "Europe/Berlin");
        url.searchParams.set("models", modelsForApi.join(","));
        url.searchParams.set("hourly", hourlyParams.join(","));

        const response = await fetch(url);
        if (!response.ok) {
          // 🔄 Fallback : réessayer sans paramètre "models" ou avec un sous-ensemble supporté
          console.warn("🌐 API Open-Meteo a renvoyé", response.status);
          // Liste blanche basique de modèles connus supportés par Open-Meteo
          const SUPPORTED_MODELS = [
            "gfs_global",
            "icon_global",
            "icon_eu",
            "ecmwf_ifs025",
            "meteofrance_arome_france",
            "meteofrance_arpege_europe",
          ];

          const filtered = modelsForApi.filter((m) =>
            SUPPORTED_MODELS.includes(m)
          );
          console.log("🔍 Modèles filtrés pour fallback:", filtered);

          const fallbackUrl = new URL(url);
          if (filtered.length > 0) {
            fallbackUrl.searchParams.set("models", filtered.join(","));
          } else {
            fallbackUrl.searchParams.delete("models");
          }
          const retry = await fetch(fallbackUrl);
          if (!retry.ok) {
            throw new Error(`HTTP error after retry! status: ${retry.status}`);
          }
          return await retry.json();
        }

        return await response.json();
      }

      function showLoading(message) {
        console.log(message);

        // Optionnel : afficher un indicateur visuel
        const button = document.getElementById("updateGraphic");
        if (button) {
          button.textContent = "⏳ " + message;
          button.disabled = true;

          // Remettre le texte original après 3 secondes
          setTimeout(() => {
            button.textContent = "📈 Mettre à jour le graphique";
            button.disabled = false;
          }, 3000);
        }
      }

      async function populateModelSelections() {
        console.log(
          "🔧 Début de populateModelSelections, isInitializing:",
          isInitializing
        );

        Object.entries(PARAMETERS).forEach(([paramKey, paramConfig]) => {
          console.log(`📋 Processing parameter: ${paramKey}`);
          const container = document.getElementById(`models-${paramKey}`);
          container.innerHTML = "";

          // Create the 3-row layout
          const rowsHtml = Object.entries(MODEL_GROUPS)
            .map(([groupKey, groupConfig]) => {
              return `
              <div class="models-column">
                <div class="column-header ${groupKey}">${groupConfig.label}</div>
                <div class="models-row" id="${paramKey}-${groupKey}-models"></div>
              </div>
            `;
            })
            .join("");

          container.innerHTML = `<div class="models-columns">${rowsHtml}</div>`;

          // Populate each row
          Object.entries(MODEL_GROUPS).forEach(([groupKey, groupConfig]) => {
            const rowContainer = document.getElementById(
              `${paramKey}-${groupKey}-models`
            );

            groupConfig.models.forEach((model) => {
              if (!MODELS.includes(model)) return; // Skip if model not available for this city

              const hasData = checkModelHasData(
                model,
                paramConfig.apiParams[0]
              );
              if (!hasData) return;

              const timeRange = getModelTimeRange(
                model,
                paramConfig.apiParams[0]
              );
              const modelCard = createModelCard(
                model,
                paramKey,
                timeRange,
                true,
                groupKey
              );
              rowContainer.appendChild(modelCard);
            });
          });
        });

        console.log("✅ populateModelSelections terminée");
      }

      function syncInterfaceWithSelections() {
        console.log("🔄 syncInterfaceWithSelections - Début");

        Object.entries(selectedModels).forEach(([paramKey, models]) => {
          console.log(
            `🔧 Synchronisation pour ${paramKey}:`,
            Object.keys(models)
          );

          // Décocher toutes les checkboxes d'abord
          document
            .querySelectorAll(`input[data-param="${paramKey}"]`)
            .forEach((checkbox) => {
              checkbox.checked = false;
            });

          Object.entries(models).forEach(([model, range]) => {
            console.log(
              `🔄 Synchronisation ${model}: ${range.start}H-${range.end}H`
            );

            // Trouver la checkbox correspondante
            const checkbox = document.querySelector(`#${model}-${paramKey}`);
            if (checkbox) {
              checkbox.checked = true;
              console.log(`✅ Checkbox cochée pour ${model}-${paramKey}`);
            } else {
              console.log(`❌ Checkbox non trouvée pour ${model}-${paramKey}`);
            }

            // Trouver les selects correspondants
            const card = checkbox?.closest(".model-card");
            if (card) {
              const startSelect = card.querySelector('[data-type="start"]');
              const endSelect = card.querySelector('[data-type="end"]');

              if (startSelect) {
                startSelect.value = range.start;
                console.log(
                  `📅 Start select mis à ${range.start}H pour ${model}`
                );
              }

              if (endSelect) {
                endSelect.value = range.end;
                console.log(`📅 End select mis à ${range.end}H pour ${model}`);
              }
            }
          });
        });

        console.log("✅ syncInterfaceWithSelections terminée");
      }

      function checkModelHasData(model, parameter) {
        const fullParamName = `${parameter}_${model}`;
        const data = weatherData.hourly[fullParamName];

        if (!data) return false;

        // Check if all values are null
        return data.some((value) => value !== null && value !== undefined);
      }

      function getModelTimeRange(model, parameter) {
        const fullParamName = `${parameter}_${model}`;
        const data = weatherData.hourly[fullParamName];

        if (!data) return { start: 0, end: 0 };

        let lastValidIndex = -1;
        for (let i = data.length - 1; i >= 0; i--) {
          if (data[i] !== null && data[i] !== undefined) {
            lastValidIndex = i;
            break;
          }
        }

        // Convertir en heures depuis le début
        const maxHours = lastValidIndex > 0 ? lastValidIndex : 0;
        return { start: 0, end: maxHours };
      }

      function createModelCard(
        model,
        paramKey,
        timeRange,
        preSelect = false,
        groupKey = ""
      ) {
        const card = document.createElement("div");
        card.className = "model-card";

        // Apply model color to border
        const modelColor = MODEL_COLORS[model] || "#999";
        card.style.borderColor = modelColor;

        const modelDisplayName =
          MODEL_DISPLAY_NAMES[model] || model.replace(/_/g, " ").toUpperCase();

        card.innerHTML = `
                <div class="model-header">
                    <input type="checkbox" class="model-checkbox"
                           id="${model}-${paramKey}"
                           data-model="${model}"
                           data-param="${paramKey}"
                           ${preSelect ? "checked" : ""}>
                    <label for="${model}-${paramKey}" class="model-name" style="color: ${modelColor};">${modelDisplayName}</label>
                </div>
                <div class="time-range">
                    <select class="time-select" data-type="start">
                        ${generateTimeOptions(0, timeRange.end, 0)}
                    </select>
                    <span>à</span>
                    <select class="time-select" data-type="end">
                        ${generateTimeOptions(
                          0,
                          timeRange.end,
                          timeRange.end // Toujours sélectionner l'échéance maximale
                        )}
                    </select>
                </div>
            `;

        // Setup event listeners
        const checkbox = card.querySelector(".model-checkbox");
        const startSelect = card.querySelector('[data-type="start"]');
        const endSelect = card.querySelector('[data-type="end"]');

        // If pre-selected, initialize the model selection
        if (preSelect) {
          updateModelSelection(
            model,
            paramKey,
            true,
            startSelect.value,
            endSelect.value
          );
        }

        checkbox.addEventListener("change", () => {
          updateModelSelection(
            model,
            paramKey,
            checkbox.checked,
            startSelect.value,
            endSelect.value
          );
          // Mettre à jour immédiatement le graphique si visible
          if (
            document.getElementById("chartsSection").style.display !== "none"
          ) {
            updateChartControls();
            updateMainChart();
          }
        });

        startSelect.addEventListener("change", () => {
          if (checkbox.checked) {
            updateModelSelection(
              model,
              paramKey,
              true,
              startSelect.value,
              endSelect.value
            );
            // Mettre à jour immédiatement le graphique si visible
            if (
              document.getElementById("chartsSection").style.display !== "none"
            ) {
              updateChartControls();
              updateMainChart();
            }
          }
        });

        endSelect.addEventListener("change", () => {
          if (checkbox.checked) {
            updateModelSelection(
              model,
              paramKey,
              true,
              startSelect.value,
              endSelect.value
            );
            // Mettre à jour immédiatement le graphique si visible
            if (
              document.getElementById("chartsSection").style.display !== "none"
            ) {
              updateChartControls();
              updateMainChart();
            }
          }
        });

        return card;
      }

      function generateTimeOptions(min, max, selected = min) {
        console.log(
          `⏰ generateTimeOptions: min=${min}, max=${max}, selected=${selected}`
        );
        let options = "";

        // Générer les échéances : 0H, 24H, 36H, 48H, 60H, 96H, puis de 24 en 24H jusqu'à 240H
        const timeSteps = [0, 24, 36, 48, 60, 96];

        // Ajouter les échéances de 24 en 24H après 96H
        for (let h = 120; h <= 240; h += 24) {
          timeSteps.push(h);
        }

        // Ajouter aussi la valeur max si elle n'est pas dans les timeSteps
        if (!timeSteps.includes(max) && max > 0) {
          timeSteps.push(max);
          timeSteps.sort((a, b) => a - b);
        }

        console.log(
          `⏰ Échéances disponibles: ${timeSteps.filter(
            (h) => h >= min && h <= max
          )}`
        );

        timeSteps.forEach((hours) => {
          if (hours >= min && hours <= max) {
            // Changé < en <= pour inclure max
            const isSelected = hours === selected ? "selected" : "";
            options += `<option value="${hours}" ${isSelected}>${hours}H</option>`;
          }
        });

        console.log(
          `⏰ Options générées: ${
            options.split("</option>").length - 1
          } options`
        );
        return options;
      }

      function updateModelSelection(
        model,
        paramKey,
        enabled,
        startHours,
        endHours
      ) {
        console.log(
          `🔄 updateModelSelection: ${model}, ${paramKey}, enabled:${enabled}, ${startHours}H-${endHours}H`
        );

        if (!selectedModels[paramKey]) {
          selectedModels[paramKey] = {};
        }

        if (enabled) {
          selectedModels[paramKey][model] = {
            start: parseInt(startHours),
            end: parseInt(endHours),
          };
          console.log(
            `✅ Modèle ${model} activé pour ${paramKey}:`,
            selectedModels[paramKey][model]
          );
        } else {
          delete selectedModels[paramKey][model];
          console.log(`❌ Modèle ${model} désactivé pour ${paramKey}`);
        }

        console.log(
          `📊 Modèles sélectionnés pour ${paramKey}:`,
          Object.keys(selectedModels[paramKey] || {})
        );

        // Only update controls if we're on the current active parameter
        const activeParam =
          document.querySelector(".tab-btn.active")?.dataset.param;
        if (activeParam === paramKey) {
          console.log(
            `🎯 Mise à jour des contrôles pour paramètre actif: ${activeParam}`
          );
          updateChartControls();
        }
      }

      function updateChartControls() {
        console.log("🎮 updateChartControls - Début");
        const controls = document.getElementById("chartControls");
        controls.innerHTML = "";

        // Get current active parameter
        const activeParam =
          document.querySelector(".tab-btn.active")?.dataset.param;
        console.log(`🎯 Paramètre actif: ${activeParam}`);

        if (!activeParam) {
          console.log("❌ Aucun paramètre actif trouvé");
          return;
        }

        const models = selectedModels[activeParam] || {};
        console.log(`🔍 Modèles pour ${activeParam}:`, Object.keys(models));

        // Add aggregation control button first
        const aggregationToggle = document.createElement("button");
        aggregationToggle.className = "model-toggle active";
        aggregationToggle.textContent = "AGRÉGATION";
        aggregationToggle.style.backgroundColor = "#000000";
        aggregationToggle.style.borderColor = "#000000";
        aggregationToggle.style.color = "#ffffff";
        aggregationToggle.dataset.model = "aggregation";

        aggregationToggle.addEventListener("click", () => {
          if (aggregationToggle.classList.contains("active")) {
            if (aggregationToggle.classList.contains("emphasized")) {
              // If emphasized, hide it
              aggregationToggle.classList.remove("active");
              aggregationToggle.classList.remove("emphasized");
              aggregationToggle.classList.add("hidden");
            } else {
              // If normal active, go to emphasized
              aggregationToggle.classList.add("emphasized");
            }
          } else {
            // If inactive, activate it
            aggregationToggle.classList.add("active");
            aggregationToggle.classList.remove("emphasized");
            aggregationToggle.classList.remove("hidden");
          }
          updateMainChart();
        });

        controls.appendChild(aggregationToggle);

        Object.keys(models).forEach((model, index) => {
          console.log(`🔘 Création du contrôle pour: ${model}`);
          const toggle = document.createElement("button");
          toggle.className = "model-toggle active";
          toggle.textContent =
            MODEL_DISPLAY_NAMES[model] ||
            model.replace(/_/g, " ").toUpperCase();

          // Appliquer la couleur dédiée
          const bgColor = MODEL_COLORS[model] || "#999";
          toggle.style.backgroundColor = bgColor;
          toggle.style.borderColor = bgColor;
          toggle.style.color = getTextColorForBg(bgColor);
          toggle.dataset.model = model;

          toggle.addEventListener("click", () => {
            console.log(`🖱️ Clic sur contrôle: ${model}`);
            if (toggle.classList.contains("active")) {
              if (toggle.classList.contains("emphasized")) {
                // If emphasized, hide it
                toggle.classList.remove("active");
                toggle.classList.remove("emphasized");
                toggle.classList.add("hidden");
                console.log(`👁️ ${model} masqué`);
              } else {
                // If normal active, go to emphasized
                toggle.classList.add("emphasized");
                console.log(`⭐ ${model} mis en évidence`);
              }
            } else {
              // If inactive, activate it
              toggle.classList.add("active");
              toggle.classList.remove("emphasized");
              toggle.classList.remove("hidden");
              console.log(`✅ ${model} activé`);
            }
            updateMainChart();
          });

          controls.appendChild(toggle);
        });

        console.log(`✅ ${Object.keys(models).length} contrôles créés`);
      }

      function createMainChart() {
        console.log("📊 createMainChart - Début");
        try {
          const canvas = document.getElementById("mainChart");
          if (!canvas) {
            throw new Error("Canvas mainChart non trouvé");
          }

          // Destroy existing chart properly
          if (currentChart) {
            console.log("🗑️ Destruction de l'ancien graphique");
            currentChart.destroy();
            currentChart = null;
          }

          // Clear canvas context
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const activeParam =
            document.querySelector(".tab-btn.active")?.dataset.param;

          console.log(`🎯 Paramètre actif pour création: ${activeParam}`);

          if (!activeParam) {
            throw new Error("Aucun paramètre actif trouvé");
          }

          console.log("🔧 Création des datasets...");
          const datasets = createDatasets(activeParam);

          if (!datasets || datasets.length === 0) {
            throw new Error("Aucun dataset disponible");
          }

          console.log(`✅ ${datasets.length} datasets créés`);

          // Create simple time labels
          console.log("🏷️ Création des labels de temps...");
          const timeLabels = weatherData.hourly.time.map((time, index) => {
            const date = new Date(time);
            if (index % 12 === 0) {
              // Show every 12 hours for date + 12h format
              const day = date.getDate();
              const month = date.toLocaleDateString("fr-FR", {
                month: "short",
              });
              return `${day} ${month}`;
            } else if (index % 12 === 6) {
              // Show just date for mid-day points
              const day = date.getDate();
              const month = date.toLocaleDateString("fr-FR", {
                month: "short",
              });
              return `${day} ${month}`;
            }
            return "";
          });

          console.log(`🏷️ ${timeLabels.filter((l) => l).length} labels créés`);

          // Determine chart type based on parameter
          let chartType = "line";
          if (activeParam === "precipitation") {
            chartType = "bar"; // Base type for precipitation combo chart
          } else if (
            activeParam === "wind_direction" &&
            windDirectionMode === "points"
          ) {
            chartType = "scatter";
          }
          console.log(`📊 Type de graphique: ${chartType}`);

          // Sort datasets for precipitation to create stacked effect (smallest to largest)
          if (activeParam === "precipitation") {
            console.log("🔄 Tri des datasets pour effet de superposition...");
            // Sort datasets by average value (excluding aggregation)
            const modelDatasets = datasets.filter((ds) => !ds.isAggregate);
            const aggregateDataset = datasets.find((ds) => ds.isAggregate);

            modelDatasets.sort((a, b) => {
              const avgA = a.data
                .filter((v) => v !== null)
                .reduce((sum, v, _, arr) => sum + v / arr.length, 0);
              const avgB = b.data
                .filter((v) => v !== null)
                .reduce((sum, v, _, arr) => sum + v / arr.length, 0);
              return avgA - avgB; // Smallest to largest
            });

            // Reconstruct datasets array with sorted models + aggregation at the end
            if (aggregateDataset) {
              datasets.length = 0;
              datasets.push(...modelDatasets, aggregateDataset);
            } else {
              datasets.length = 0;
              datasets.push(...modelDatasets);
            }
          }

          console.log("📈 Création du graphique Chart.js...");
          currentChart = new Chart(ctx, {
            type: chartType,
            data: {
              labels: timeLabels,
              datasets: datasets,
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                x: {
                  stacked:
                    activeParam === "precipitation" &&
                    precipitationMode === "stacked",
                  type: "category",
                  title: {
                    display: false,
                  },
                },
                y: {
                  stacked:
                    activeParam === "precipitation" &&
                    precipitationMode === "stacked",
                  title: {
                    display: true,
                    text: PARAMETERS[activeParam].unit,
                  },
                  position: "left",
                },
                // ➤ COMBO : Ajouter axe Y secondaire pour la probabilité lors des précipitations
                ...(activeParam === "precipitation" && {
                  y1: {
                    type: "linear",
                    display: true,
                    position: "right",
                    title: {
                      display: true,
                      text: "Probabilité (%)",
                    },
                    min: 0,
                    max: 100,
                    // grid lines only want to show for one axis to avoid clutter
                    grid: {
                      drawOnChartArea: false,
                    },
                  },
                }),
              },
              plugins: {
                legend: {
                  display: false,
                },
                tooltip: {
                  mode: "index",
                  intersect: false,
                  backgroundColor: "rgba(248, 249, 250, 0.95)",
                  titleColor: "#000000",
                  bodyColor: "#333333",
                  borderColor: "#dee2e6",
                  borderWidth: 1,
                  itemSort: (a, b) => {
                    // Trier du plus grand au plus petit
                    return b.parsed.y - a.parsed.y;
                  },
                  callbacks: {
                    title: function (context) {
                      const index = context[0].dataIndex;
                      const time = weatherData.hourly.time[index];
                      const date = new Date(time);
                      return date.toLocaleDateString("fr-FR", {
                        day: "2-digit",
                        month: "2-digit",
                        year: "numeric",
                        hour: "2-digit",
                        minute: "2-digit",
                      });
                    },
                    label: function (context) {
                      const modelName = context.dataset.label;
                      const value = context.parsed.y;
                      const color = context.dataset.borderColor;

                      if (value === null || value === undefined) return null;

                      // Skip precipitation models with 0.0mm in tooltip
                      const activeParam =
                        document.querySelector(".tab-btn.active")?.dataset
                          .param;
                      if (activeParam === "precipitation" && value === 0.0)
                        return null;

                      // Format with bold value
                      return `${modelName}: ${value.toFixed(2)} ${
                        PARAMETERS[activeParam].unit
                      }`;
                    },
                    labelColor: function (context) {
                      return {
                        backgroundColor: context.dataset.borderColor,
                        borderColor: context.dataset.borderColor,
                        borderWidth: 2,
                        borderRadius: 0, // Square instead of circle
                      };
                    },
                    labelTextColor: function (context) {
                      return context.dataset.borderColor;
                    },
                  },
                },
                zoom: {
                  zoom: {
                    wheel: {
                      enabled: false,
                    },
                    pinch: {
                      enabled: true,
                    },
                    drag: {
                      enabled: true,
                      backgroundColor: "rgba(37, 99, 235, 0.2)",
                    },
                    mode: "x",
                    onZoomComplete: function ({ chart }) {
                      const zoomBtn = document.getElementById("zoomResetBtn");
                      if (zoomBtn) {
                        zoomBtn.style.display = "block";
                      }
                    },
                  },
                  pan: {
                    enabled: true,
                    mode: "x",
                  },
                },
              },
              interaction: {
                intersect: false,
                mode: "index",
              },
            },
          });

          console.log("✅ Graphique principal créé avec succès");

          // Mettre à jour le panel d'analyse avec l'agrégation automatique
          setTimeout(() => {
            console.log("🎯 DEBUG PANEL - Trigger depuis createMainChart");
            updateAnalysisPanel(weatherData, null);
          }, 100);
        } catch (error) {
          console.error("❌ Erreur création graphique principal:", error);
          alert("Erreur lors de la création du graphique: " + error.message);
        }
      }

      function createDatasets(paramKey) {
        console.log(`📊 createDatasets pour paramètre: ${paramKey}`);
        const datasets = [];
        const models = selectedModels[paramKey] || {};
        const parameter = PARAMETERS[paramKey].apiParams[0];

        console.log(
          `🔍 Modèles disponibles pour ${paramKey}:`,
          Object.keys(models)
        );
        console.log(`📋 Configuration des modèles:`, models);

        Object.entries(models).forEach(([model, range], index) => {
          console.log(`🔧 Traitement du modèle: ${model}, range:`, range);
          const fullParamName = `${parameter}_${model}`;
          const data = weatherData.hourly[fullParamName];

          console.log(
            `📡 Données pour ${fullParamName}:`,
            data ? `${data.length} valeurs` : "PAS DE DONNÉES"
          );

          if (!data) {
            console.log(`❌ Pas de données pour ${fullParamName}`);
            return;
          }

          const color = MODEL_COLORS[model] || "#999";

          let processedData;
          const activeParam =
            document.querySelector(".tab-btn.active")?.dataset.param;

          if (
            activeParam === "wind_direction" &&
            windDirectionMode === "points"
          ) {
            // For scatter plot, create {x, y} objects
            processedData = data
              .map((value, i) => {
                const currentHour = i;
                if (currentHour < range.start || currentHour >= range.end)
                  return null;
                if (value === null || value === undefined) return null;
                return { x: i, y: value };
              })
              .filter((point) => point !== null);
          } else {
            // For line/bar charts, use simple array
            processedData = data.map((value, i) => {
              // Convertir l'index en heures depuis le début
              const currentHour = i;
              if (currentHour < range.start || currentHour >= range.end)
                return null;
              return value;
            });
          }

          console.log(
            `📈 Dataset créé pour ${model}: ${
              processedData.filter((v) => v !== null).length
            } points valides`
          );

          // Special case for Biarritz and Cap-Corse - make line bold
          const isBoldCity = ["Biarritz", "Cap-Corse"].includes(
            selectedCity?.name
          );

          // Different styling for bar vs line charts
          const isBarChart = paramKey === "precipitation";

          const datasetConfig = {
            label:
              MODEL_DISPLAY_NAMES[model] ||
              model.replace(/_/g, " ").toUpperCase(),
            data: processedData,
            borderColor: color,
            backgroundColor: isBarChart ? color + "80" : color + "20",
            hidden: false, // Explicitement pas caché
          };

          if (isBarChart) {
            // Bar chart specific options
            datasetConfig.borderWidth = 1;
            datasetConfig.barPercentage = 0.9;
            datasetConfig.categoryPercentage = 0.8;

            if (precipitationMode === "stacked") {
              datasetConfig.stack = "precipitation"; // Stack all precipitation bars together
            } else {
              // Behind mode: different stacks for layering effect
              datasetConfig.stack = `precipitation-${index}`;
              datasetConfig.barPercentage = 1.0;
              datasetConfig.categoryPercentage = 1.0;
            }
          } else if (
            activeParam === "wind_direction" &&
            windDirectionMode === "points"
          ) {
            // Scatter chart specific options
            datasetConfig.showLine = false;
            datasetConfig.pointRadius = 3;
            datasetConfig.pointHoverRadius = 6;
            datasetConfig.borderWidth = 0;
            datasetConfig.pointBorderColor = color;
            datasetConfig.pointBackgroundColor = color;
          } else {
            // Line chart specific options
            datasetConfig.fill = false;
            datasetConfig.tension = 0.1;
            datasetConfig.pointRadius = 0;
            datasetConfig.pointHoverRadius = 4;
            datasetConfig.borderWidth = isBoldCity ? 3 : 1; // Bold line for specific cities
          }

          datasets.push(datasetConfig);
        });

        console.log(`✅ ${datasets.length} datasets créés pour ${paramKey}`);

        /* ➕ COMBO : Ajout de la courbe de probabilité pour les précipitations */
        if (paramKey === "precipitation") {
          // ✅ CORRECTION : Calculer la probabilité à partir des données mm des modèles de précipitation
          // Utiliser les MÊMES modèles et échéances que pour les précipitations mm
          const precipitationProbabilityData = calculatePrecipitationAlgorithm(
            "precipitation_probability",
            models, // Utiliser les modèles de précipitation, pas ceux de precipitation_probability
            "precipitation", // Utiliser les données mm, pas precipitation_probability
            weatherData.hourly.time.length
          );

          if (
            precipitationProbabilityData &&
            precipitationProbabilityData.some((v) => v !== null)
          ) {
            const probabilityDataset = {
              label: "Probabilité de précipitation",
              data: precipitationProbabilityData,
              type: "line", // Line sur un graphique de base en barres = combo
              borderColor: "#8B0000", // Rouge foncé
              backgroundColor: "transparent",
              borderWidth: 3,
              fill: false,
              tension: 0.1,
              pointRadius: 0,
              pointHoverRadius: 4,
              yAxisID: "y1", // Utiliser l'axe Y secondaire
              order: 0, // Afficher au premier plan
              hidden: false,
            };

            datasets.push(probabilityDataset);
            console.log(
              "✅ Courbe de probabilité ajoutée au graphique combo (basée sur données mm)"
            );
          }
        }

        /* ➕ Ajout de la courbe d'agrégation */
        let aggregatedData = calculateAggregatedData(paramKey);
        const isBarChart = paramKey === "precipitation";
        const isScatterChart =
          paramKey === "wind_direction" && windDirectionMode === "points";

        // Convert aggregated data for scatter plot
        if (isScatterChart) {
          aggregatedData = aggregatedData
            .map((value, i) => {
              if (value === null || value === undefined) return null;
              return { x: i, y: value };
            })
            .filter((point) => point !== null);
        }

        const aggregateConfig = {
          label: STRATEGIES[selectedStrategy].label,
          data: aggregatedData,
          borderColor: "#000000",
          backgroundColor: isBarChart ? "#00000080" : "#00000020",
          hidden: false,
          isAggregate: true,
        };

        if (isBarChart) {
          // Bar chart specific options for aggregation
          aggregateConfig.borderWidth = 2;
          aggregateConfig.barPercentage = 0.9;
          aggregateConfig.categoryPercentage = 0.8;
          aggregateConfig.stack = "aggregation"; // Always separate stack for aggregation
          aggregateConfig.order = -1; // Render behind other bars

          if (precipitationMode === "behind") {
            aggregateConfig.barPercentage = 1.0;
            aggregateConfig.categoryPercentage = 1.0;
          }
        } else if (isScatterChart) {
          // Scatter chart specific options for aggregation
          aggregateConfig.showLine = false;
          aggregateConfig.pointRadius = 5;
          aggregateConfig.pointHoverRadius = 8;
          aggregateConfig.borderWidth = 0;
          aggregateConfig.pointBorderColor = "#000000";
          aggregateConfig.pointBackgroundColor = "#000000";
          aggregateConfig.pointBorderWidth = 2;
        } else {
          // Line chart specific options for aggregation
          aggregateConfig.borderWidth = 3;
          aggregateConfig.fill = false;
          aggregateConfig.tension = 0.1;
          aggregateConfig.pointRadius = 0;
          aggregateConfig.pointHoverRadius = 4;
        }

        datasets.push(aggregateConfig);

        return datasets;
      }

      // Met à jour uniquement la courbe d'agrégation lorsque la stratégie change
      function updateAggregateDataset() {
        if (!currentChart) return;

        const activeParam =
          document.querySelector(".tab-btn.active")?.dataset.param;
        if (!activeParam) return;

        let aggregatedData = calculateAggregatedData(activeParam);
        const label = STRATEGIES[selectedStrategy].label;
        const isBarChart = activeParam === "precipitation";
        const isScatterChart =
          activeParam === "wind_direction" && windDirectionMode === "points";

        // Convert aggregated data for scatter plot
        if (isScatterChart) {
          aggregatedData = aggregatedData
            .map((value, i) => {
              if (value === null || value === undefined) return null;
              return { x: i, y: value };
            })
            .filter((point) => point !== null);
        }

        let aggregateDs = currentChart.data.datasets.find(
          (ds) => ds.isAggregate
        );

        if (aggregateDs) {
          aggregateDs.data = aggregatedData;
          aggregateDs.label = label;
          // Update styling based on chart type
          aggregateDs.backgroundColor = isBarChart ? "#00000080" : "#00000020";

          if (isBarChart) {
            aggregateDs.borderWidth = 2;
            delete aggregateDs.fill;
            delete aggregateDs.tension;
            delete aggregateDs.pointRadius;
            delete aggregateDs.pointHoverRadius;
            delete aggregateDs.showLine;
            delete aggregateDs.pointBorderColor;
            delete aggregateDs.pointBackgroundColor;
            delete aggregateDs.pointBorderWidth;
            aggregateDs.barPercentage = 0.9;
            aggregateDs.categoryPercentage = 0.8;
            aggregateDs.stack = "aggregation"; // Always separate stack for aggregation
            aggregateDs.order = -1; // Render behind other bars

            if (precipitationMode === "behind") {
              aggregateDs.barPercentage = 1.0;
              aggregateDs.categoryPercentage = 1.0;
            }
          } else if (isScatterChart) {
            aggregateDs.borderWidth = 0;
            delete aggregateDs.fill;
            delete aggregateDs.tension;
            delete aggregateDs.barPercentage;
            delete aggregateDs.categoryPercentage;
            delete aggregateDs.stack;
            delete aggregateDs.order;
            aggregateDs.showLine = false;
            aggregateDs.pointRadius = 5;
            aggregateDs.pointHoverRadius = 8;
            aggregateDs.pointBorderColor = "#000000";
            aggregateDs.pointBackgroundColor = "#000000";
            aggregateDs.pointBorderWidth = 2;
          } else {
            aggregateDs.borderWidth = 3;
            delete aggregateDs.barPercentage;
            delete aggregateDs.categoryPercentage;
            delete aggregateDs.stack;
            delete aggregateDs.order;
            delete aggregateDs.showLine;
            delete aggregateDs.pointBorderColor;
            delete aggregateDs.pointBackgroundColor;
            delete aggregateDs.pointBorderWidth;
            aggregateDs.fill = false;
            aggregateDs.tension = 0.1;
            aggregateDs.pointRadius = 0;
            aggregateDs.pointHoverRadius = 4;
          }
        } else {
          const aggregateConfig = {
            label,
            data: aggregatedData,
            borderColor: "#000000",
            backgroundColor: isBarChart ? "#00000080" : "#00000020",
            hidden: false,
            isAggregate: true,
          };

          if (isBarChart) {
            aggregateConfig.borderWidth = 2;
            aggregateConfig.barPercentage = 0.9;
            aggregateConfig.categoryPercentage = 0.8;
            aggregateConfig.stack = "aggregation"; // Always separate stack for aggregation
            aggregateConfig.order = -1; // Render behind other bars

            if (precipitationMode === "behind") {
              aggregateConfig.barPercentage = 1.0;
              aggregateConfig.categoryPercentage = 1.0;
            }
          } else if (isScatterChart) {
            aggregateConfig.borderWidth = 0;
            aggregateConfig.showLine = false;
            aggregateConfig.pointRadius = 5;
            aggregateConfig.pointHoverRadius = 8;
            aggregateConfig.pointBorderColor = "#000000";
            aggregateConfig.pointBackgroundColor = "#000000";
            aggregateConfig.pointBorderWidth = 2;
          } else {
            aggregateConfig.borderWidth = 3;
            aggregateConfig.fill = false;
            aggregateConfig.tension = 0.1;
            aggregateConfig.pointRadius = 0;
            aggregateConfig.pointHoverRadius = 4;
          }

          currentChart.data.datasets.push(aggregateConfig);
        }

        currentChart.update();
      }

      function updateMainChart() {
        console.log("🔄 updateMainChart - Début");
        if (!currentChart) {
          console.log("❌ Pas de graphique currentChart");
          return;
        }

        try {
          const activeParam =
            document.querySelector(".tab-btn.active")?.dataset.param;
          console.log(`🎯 Paramètre actif pour mise à jour: ${activeParam}`);

          if (!activeParam) {
            console.log("❌ Aucun paramètre actif pour la mise à jour");
            return;
          }

          const models = selectedModels[activeParam] || {};
          console.log(`🔍 Modèles pour mise à jour:`, Object.keys(models));

          currentChart.data.datasets.forEach((dataset, index) => {
            const modelKeys = Object.keys(models);
            console.log(`📊 Dataset ${index}: ${dataset.label}`);

            // Handle aggregation dataset
            if (dataset.isAggregate) {
              const controlsContainer =
                document.getElementById("chartControls");
              const aggregationToggle = controlsContainer
                ? controlsContainer.querySelector(`[data-model="aggregation"]`)
                : null;

              if (aggregationToggle) {
                const wasHidden = dataset.hidden;
                const oldBorderWidth = dataset.borderWidth;

                dataset.hidden = aggregationToggle.classList.contains("hidden");

                // Handle border width based on state
                if (aggregationToggle.classList.contains("emphasized")) {
                  dataset.borderWidth = 6;
                } else if (aggregationToggle.classList.contains("active")) {
                  dataset.borderWidth = 3;
                } else {
                  dataset.borderWidth = 3;
                }

                console.log(
                  `📈 AGRÉGATION: hidden ${wasHidden} → ${dataset.hidden}, borderWidth ${oldBorderWidth} → ${dataset.borderWidth}`
                );
              }
            } else {
              // Find model by matching dataset label with model display names
              let matchedModel = null;
              const models = selectedModels[activeParam] || {};

              for (const model of Object.keys(models)) {
                const displayName =
                  MODEL_DISPLAY_NAMES[model] ||
                  model.replace(/_/g, " ").toUpperCase();
                if (dataset.label === displayName) {
                  matchedModel = model;
                  break;
                }
              }

              if (matchedModel) {
                const controlsContainer =
                  document.getElementById("chartControls");
                const toggle = controlsContainer
                  ? controlsContainer.querySelector(
                      `[data-model="${matchedModel}"]`
                    )
                  : null;

                console.log(
                  `🔘 Contrôle trouvé pour ${matchedModel}:`,
                  toggle ? "OUI" : "NON"
                );

                if (toggle) {
                  const wasHidden = dataset.hidden;
                  const oldBorderWidth = dataset.borderWidth;

                  dataset.hidden = toggle.classList.contains("hidden");

                  // Handle border width based on state
                  if (toggle.classList.contains("emphasized")) {
                    dataset.borderWidth = 4;
                  } else if (toggle.classList.contains("active")) {
                    dataset.borderWidth = 1;
                  } else {
                    dataset.borderWidth = 1;
                  }

                  console.log(
                    `📈 ${matchedModel}: hidden ${wasHidden} → ${dataset.hidden}, borderWidth ${oldBorderWidth} → ${dataset.borderWidth}`
                  );
                }
              } else {
                console.log(
                  `⚠️ Dataset ${index} sans modèle correspondant: ${dataset.label}`
                );
              }
            }
          });

          console.log("🔄 Mise à jour du graphique...");
          currentChart.update();
          console.log("✅ Graphique mis à jour");
        } catch (error) {
          console.error("❌ Erreur mise à jour graphique:", error);
        }
      }

      async function applyStrategy() {
        console.log("🚀 Début applyStrategy");
        if (!weatherData || !selectedModels) {
          alert("Veuillez d'abord mettre à jour le graphique");
          return;
        }

        const activeParam =
          document.querySelector(".tab-btn.active").dataset.param;
        console.log("📊 Paramètre actif:", activeParam);
        const aggregatedData = calculateAggregatedData(activeParam);
        console.log(
          "📈 Données agrégées calculées:",
          aggregatedData ? aggregatedData.length : 0,
          "points"
        );
        createAggregatedChart(aggregatedData, activeParam);
        console.log("✅ Fin applyStrategy");
      }

      // Fonctions utilitaires pour l'algorithme de précipitation
      function clamp(min, max, value) {
        return Math.min(max, Math.max(min, value));
      }

      function calculateVariance(values) {
        if (values.length <= 1) return 0;
        const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
        const variance =
          values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) /
          values.length;
        return Math.sqrt(variance);
      }

      function calculateMean(values) {
        if (values.length === 0) return 0;
        return values.reduce((sum, val) => sum + val, 0) / values.length;
      }

      function applyGaussianWeighting(values, beta = 1.618) {
        if (values.length === 0) return 0;
        if (values.length === 1) return values[0];

        const mu = calculateMean(values);
        const sigma = calculateVariance(values);

        if (sigma === 0) return mu;

        // Calculer les poids gaussiens
        const weights = values.map((val) => {
          return Math.exp(
            -Math.pow(val - mu, 2) / (2 * Math.pow(beta * sigma, 2))
          );
        });

        // Normaliser les poids
        const weightSum = weights.reduce((sum, w) => sum + w, 0);
        if (weightSum === 0) return mu;

        // Moyenne pondérée
        return (
          values.reduce((sum, val, i) => sum + val * weights[i], 0) / weightSum
        );
      }

      function isIsolatedPeak(
        currentValue,
        prevValue,
        nextValue,
        threshold = 2.0
      ) {
        if (prevValue === null && nextValue === null) return false;
        if (prevValue === null) prevValue = 0;
        if (nextValue === null) nextValue = 0;

        const avgNeighbors = (prevValue + nextValue) / 2;
        return currentValue > threshold * avgNeighbors;
      }

      function getSeasonalAlpha() {
        const now = new Date();
        const month = now.getMonth() + 1; // 1-12
        // Plus fort en été (juin-août = 6-8)
        if (month >= 6 && month <= 8) {
          return 0.3;
        } else {
          return 0.1;
        }
      }

      function getSeasonalK() {
        const now = new Date();
        const month = now.getMonth() + 1; // 1-12
        // Plus fort en été
        if (month >= 6 && month <= 8) {
          return 0.35;
        } else {
          return 0.2;
        }
      }

      function calculateAggregatedData(paramKey) {
        const models = selectedModels[paramKey] || {};
        const parameter = PARAMETERS[paramKey].apiParams[0];

        if (Object.keys(models).length === 0) {
          return [];
        }

        const timeLength = weatherData.hourly.time.length;

        // Cas spécial pour l'algorithme de précipitation
        if (
          selectedStrategy === "precipitation_algo" &&
          (paramKey === "precipitation" ||
            paramKey === "precipitation_probability")
        ) {
          // ✅ CORRECTION : Pour precipitation_probability, utiliser les modèles et données de precipitation mm
          if (paramKey === "precipitation_probability") {
            const precipitationModels = selectedModels["precipitation"] || {};
            return calculatePrecipitationAlgorithm(
              paramKey,
              precipitationModels, // Utiliser les modèles de précipitation mm
              "precipitation", // Utiliser les données de précipitation mm
              timeLength
            );
          } else {
            return calculatePrecipitationAlgorithm(
              paramKey,
              models,
              parameter,
              timeLength
            );
          }
        }

        const aggregatedData = [];

        for (let i = 0; i < timeLength; i++) {
          const values = [];

          Object.entries(models).forEach(([model, range]) => {
            // Convertir l'index en heures depuis le début
            const currentHour = i;
            if (currentHour >= range.start && currentHour < range.end) {
              const fullParamName = `${parameter}_${model}`;
              const paramArray = weatherData.hourly[fullParamName];
              if (!paramArray) return; // Pas de données pour ce modèle
              const value = paramArray[i];
              if (value !== null && value !== undefined) {
                values.push(value);
              }
            }
          });

          if (values.length > 0) {
            // Détecter si c'est la direction du vent pour utiliser les méthodes circulaires
            const isWindDirection = paramKey === "wind_direction";
            const aggregatedValue = applyAggregationStrategy(
              values,
              selectedStrategy,
              isWindDirection
            );
            aggregatedData.push(aggregatedValue);
          } else {
            aggregatedData.push(null);
          }
        }

        return aggregatedData;
      }

      // ===== CONFIGURATION PANNEAU DE CONTRÔLE PLUIE =====
      let rainParams = {
        // Nouvelle approche : pondération par palliers
        weightPallier01: 0.3, // Pondération pour 0.1mm
        weightPallier02: 0.6, // Pondération pour 0.2mm
        weightPallier03: 0.8, // Pondération pour 0.3mm
        // >= 0.4mm = automatiquement 1.0

        sigmaRef: 4.0,
        alphaAggressive: 0.2,
        gamma: 0.1,

        // Nouvelle pondération temporelle
        temporalMode: "3days", // "none", "3days", "5days"
        temporalCenterWeight: 80, // 0-100% pour le poids central H
        temporalConcentration: 50, // 0-100% pour la concentration autour de H

        detectIsolatedPeaks: true,
        kFactor: 0.35,
        minWetModels: 0.3,
        enableBoostMalus: false,
        neutralModels: 6,
        boostCoeff: 0.02,
        probCap: 1.0,
      };

      // Debounce timer pour éviter trop de mises à jour
      let updateChartTimer = null;

      // Gestion de l'affichage du panneau
      function toggleRainParamsPanel(show) {
        const panel = document.getElementById("rainParamsSection");
        if (panel) {
          panel.style.display = show ? "block" : "none";
        }
      }

      // Fonction pour mettre à jour la courbe de probabilité dans le graphique principal
      function updateProbabilityDatasetInMainChart(probabilityData) {
        if (!currentChart || !probabilityData) return;

        console.log(
          "🔄 Mise à jour de la courbe de probabilité dans le graphique principal"
        );

        // Chercher le dataset de probabilité (courbe rouge)
        const datasets = currentChart.data.datasets;
        let probabilityDataset = null;
        let probabilityIndex = -1;

        for (let i = 0; i < datasets.length; i++) {
          const dataset = datasets[i];
          if (
            dataset.label &&
            dataset.label.includes("Probabilité de précipitation")
          ) {
            probabilityDataset = dataset;
            probabilityIndex = i;
            break;
          }
        }

        if (probabilityDataset && probabilityIndex >= 0) {
          console.log(
            `📊 Dataset de probabilité trouvé à l'index ${probabilityIndex}`
          );

          // Mettre à jour les données
          probabilityDataset.data = probabilityData;

          // Mettre à jour le graphique
          currentChart.update("none");
          console.log("✅ Courbe de probabilité mise à jour");
        } else {
          console.log("⚠️ Courbe de probabilité non trouvée");
        }
      }

      // Fonction pour mettre à jour seulement le dataset d'agrégation dans le graphique principal
      function updateAggregationDatasetInMainChart(aggregatedData, paramKey) {
        if (!currentChart || !aggregatedData) return;

        console.log(
          "🔄 Mise à jour du dataset d'agrégation dans le graphique principal"
        );

        // Trouver le dataset d'agrégation (généralement le dernier)
        const datasets = currentChart.data.datasets;
        let aggregationDataset = null;
        let aggregationIndex = -1;

        // Chercher le dataset d'agrégation par son label ou par sa position
        for (let i = datasets.length - 1; i >= 0; i--) {
          const dataset = datasets[i];
          if (
            dataset.label &&
            (dataset.label.includes("Algo Précipitation") ||
              dataset.label.includes("Moyenne") ||
              dataset.label.includes("Médiane") ||
              dataset.label.includes("Pondération") ||
              dataset.order === 0) // Les datasets d'agrégation ont généralement order: 0
          ) {
            aggregationDataset = dataset;
            aggregationIndex = i;
            break;
          }
        }

        if (aggregationDataset && aggregationIndex >= 0) {
          console.log(
            `📊 Dataset d'agrégation trouvé à l'index ${aggregationIndex}: ${aggregationDataset.label}`
          );

          // Mettre à jour les données
          aggregationDataset.data = aggregatedData;

          // Mettre à jour le graphique
          currentChart.update("none"); // 'none' pour pas d'animation
          console.log("✅ Dataset d'agrégation mis à jour");
        } else {
          console.log("⚠️ Dataset d'agrégation non trouvé");
        }
      }

      // Fonction pour déclencher la mise à jour du graphique avec délai
      function triggerChartUpdate() {
        console.log("🎛️ triggerChartUpdate() appelée");
        if (updateChartTimer) {
          clearTimeout(updateChartTimer);
        }
        updateChartTimer = setTimeout(() => {
          console.log("⏰ Délai de 150ms écoulé, mise à jour du graphique...");
          if (currentChart) {
            // Recalculer les données d'agrégation avec les nouveaux paramètres
            const activeParam =
              document.querySelector(".tab-btn.active")?.dataset.param;
            console.log(`🎯 Paramètre actif détecté: ${activeParam}`);

            if (
              activeParam &&
              (activeParam === "precipitation" ||
                activeParam === "precipitation_probability")
            ) {
              console.log(
                "🔄 Recalcul des données de précipitation avec nouveaux paramètres"
              );

              // TOUJOURS recalculer la probabilité (même si on est sur l'onglet mm)
              const probabilityData = calculateAggregatedData(
                "precipitation_probability"
              );

              // Si on est sur l'onglet mm, recalculer aussi les mm
              if (activeParam === "precipitation") {
                const mmData = calculateAggregatedData("precipitation");
                updateAggregationDatasetInMainChart(mmData, "precipitation");
              }

              // Toujours mettre à jour la courbe de probabilité
              updateProbabilityDatasetInMainChart(probabilityData);
            }

            updateMainChart();
            updateParamVisualization();
          } else {
            console.log("⚠️ currentChart n'existe pas");
          }
        }, 150);
      }

      // Mise à jour des valeurs affichées
      function updateSliderValue(sliderId, value, unit = "") {
        const valueElement = document.getElementById(sliderId + "Value");
        if (valueElement) {
          valueElement.textContent = value + unit;
        }
      }

      // Initialisation des event listeners pour le panneau
      function initRainParamsEventListeners() {
        // Toggle du panneau
        const toggle = document.getElementById("rainParamsToggle");
        const content = document.getElementById("rainParamsContent");
        if (toggle && content) {
          toggle.addEventListener("click", () => {
            const isVisible = content.style.display !== "none";
            content.style.display = isVisible ? "none" : "block";
            toggle.textContent = isVisible ? "▼ Afficher" : "▲ Masquer";
          });
        }

        // Sliders principaux
        [
          "weightPallier01",
          "weightPallier02",
          "weightPallier03",
          "sigmaRef",
          "alphaAggressive",
          "gamma",
          "kFactor",
          "minWetModels",
          "neutralModels",
          "boostCoeff",
          "temporalCenterWeight",
          "temporalConcentration",
        ].forEach((param) => {
          const slider = document.getElementById(param);
          if (slider) {
            slider.addEventListener("input", (e) => {
              const value = parseFloat(e.target.value);
              console.log(
                `🎛️ Slider ${param} changé: ${rainParams[param]} → ${value}`
              );
              rainParams[param] = value;

              let unit = "";
              let displayValue = value;

              if (param === "minWetModels") {
                unit = "%";
                displayValue = Math.round(value * 100);
              } else if (
                param === "temporalCenterWeight" ||
                param === "temporalConcentration"
              ) {
                unit = "%";
              }

              updateSliderValue(param, displayValue, unit);

              // Mise à jour en temps réel de l'affichage des pondérations temporelles
              if (
                param === "temporalCenterWeight" ||
                param === "temporalConcentration"
              ) {
                updateTemporalWeightsDisplay();
              }

              // Mise à jour automatique du graphique
              triggerChartUpdate();
            });
          }
        });

        // Checkboxes
        ["detectIsolatedPeaks", "enableBoostMalus"].forEach((param) => {
          const checkbox = document.getElementById(param);
          if (checkbox) {
            checkbox.addEventListener("change", (e) => {
              rainParams[param] = e.target.checked;
              triggerChartUpdate();
            });
          }
        });

        // Selects
        ["probCap"].forEach((param) => {
          const select = document.getElementById(param);
          if (select) {
            select.addEventListener("change", (e) => {
              rainParams[param] =
                e.target.value === "unlimited"
                  ? Infinity
                  : parseFloat(e.target.value) || e.target.value;
              triggerChartUpdate();
            });
          }
        });

        // Boutons radio pour mode temporel
        document
          .querySelectorAll('input[name="temporalMode"]')
          .forEach((radio) => {
            radio.addEventListener("change", (e) => {
              rainParams.temporalMode = e.target.value;
              updateTemporalControlsVisibility();
              updateTemporalWeightsDisplay();
              triggerChartUpdate();
            });
          });

        // Initialiser la visibilité des contrôles temporels
        updateTemporalControlsVisibility();
        updateTemporalWeightsDisplay();

        // Boutons d'action
        const applyBtn = document.getElementById("applyParams");
        if (applyBtn) {
          applyBtn.addEventListener("click", () => {
            triggerChartUpdate();
          });
        }

        const resetBtn = document.getElementById("resetParams");
        if (resetBtn) {
          resetBtn.addEventListener("click", () => {
            resetRainParamsToDefault();
            triggerChartUpdate();
          });
        }

        const saveBtn = document.getElementById("savePreset");
        if (saveBtn) {
          saveBtn.addEventListener("click", saveRainParamsPreset);
        }

        const loadBtn = document.getElementById("loadPreset");
        if (loadBtn) {
          loadBtn.addEventListener("click", loadRainParamsPreset);
        }
      }

      // Fonctions pour la gestion temporelle
      function updateTemporalControlsVisibility() {
        const controls = document.getElementById("temporalControls");
        const concentrationControl = document.getElementById(
          "temporalConcentrationControl"
        );
        const weightsDisplay = document.getElementById(
          "temporalWeightsDisplay"
        );

        const isActive = rainParams.temporalMode !== "none";

        if (controls) controls.style.display = isActive ? "block" : "none";
        if (concentrationControl)
          concentrationControl.style.display = isActive ? "block" : "none";
        if (weightsDisplay)
          weightsDisplay.style.display = isActive ? "block" : "none";
      }

      function calculateTemporalWeights() {
        if (rainParams.temporalMode === "none") {
          return { T: 1.0 };
        }

        const centerWeight = rainParams.temporalCenterWeight / 100; // Convertir en décimal
        const concentration = rainParams.temporalConcentration / 100;

        if (rainParams.temporalMode === "3days") {
          // Répartir le reste (1 - centerWeight) entre T-1 et T+1
          const sideWeight = (1 - centerWeight) / 2;
          return {
            "T-1": sideWeight,
            T: centerWeight,
            "T+1": sideWeight,
          };
        } else if (rainParams.temporalMode === "5days") {
          // Répartir le reste entre T-2, T-1, T+1, T+2
          const totalSideWeight = 1 - centerWeight;

          // La concentration détermine comment répartir entre les côtés proches et éloignés
          const nearWeight = totalSideWeight * (0.3 + concentration * 0.4); // 30-70% pour T±1
          const farWeight = totalSideWeight - nearWeight; // Le reste pour T±2

          return {
            "T-2": farWeight / 2,
            "T-1": nearWeight / 2,
            T: centerWeight,
            "T+1": nearWeight / 2,
            "T+2": farWeight / 2,
          };
        }

        return { T: 1.0 };
      }

      function updateTemporalWeightsDisplay() {
        const weights = calculateTemporalWeights();
        const display = document.getElementById("weightDisplay");

        if (display) {
          if (rainParams.temporalMode === "none") {
            display.textContent = "Aucun lissage";
          } else {
            const weightStrings = Object.entries(weights)
              .map(([key, value]) => `${Math.round(value * 100)}%`)
              .join(" - ");
            display.textContent = weightStrings;
          }
        }
      }

      // Reset des paramètres par défaut
      function resetRainParamsToDefault() {
        rainParams = {
          weightPallier01: 0.3,
          weightPallier02: 0.6,
          weightPallier03: 0.8,
          sigmaRef: 4.0,
          alphaAggressive: 0.2,
          gamma: 0.1,
          temporalMode: "3days",
          temporalCenterWeight: 80,
          temporalConcentration: 50,
          detectIsolatedPeaks: true,
          kFactor: 0.35,
          minWetModels: 0.3,
          enableBoostMalus: false,
          neutralModels: 6,
          boostCoeff: 0.02,
          probCap: 1.0,
        };

        // Mettre à jour les contrôles UI
        updateRainParamsUI();
        updateTemporalControlsVisibility();
        updateTemporalWeightsDisplay();
      }

      // Mise à jour de l'UI avec les valeurs actuelles
      function updateRainParamsUI() {
        Object.keys(rainParams).forEach((param) => {
          if (param === "temporalMode") {
            // Gestion spéciale pour les boutons radio
            const radio = document.getElementById(
              `temporalMode${
                rainParams[param].charAt(0).toUpperCase() +
                rainParams[param].slice(1)
              }`
            );
            if (radio) radio.checked = true;
            return;
          }

          const element = document.getElementById(param);
          if (element) {
            if (element.type === "checkbox") {
              element.checked = rainParams[param];
            } else if (element.type === "range" || element.type === "number") {
              element.value = rainParams[param];
              let unit = "";
              let displayValue = rainParams[param];

              if (param === "minWetModels") {
                unit = "%";
                displayValue = Math.round(rainParams[param] * 100);
              } else if (
                param === "temporalCenterWeight" ||
                param === "temporalConcentration"
              ) {
                unit = "%";
              }

              updateSliderValue(param, displayValue, unit);
            } else if (element.tagName === "SELECT") {
              element.value =
                rainParams[param] === Infinity
                  ? "unlimited"
                  : rainParams[param];
            }
          }
        });
      }

      // Sauvegarde/chargement de presets
      function saveRainParamsPreset() {
        const presetName = prompt("Nom du preset:");
        if (presetName) {
          localStorage.setItem(
            `rainParams_${presetName}`,
            JSON.stringify(rainParams)
          );
          alert(`Preset "${presetName}" sauvegardé!`);
        }
      }

      function loadRainParamsPreset() {
        const presetName = prompt("Nom du preset à charger:");
        if (presetName) {
          const saved = localStorage.getItem(`rainParams_${presetName}`);
          if (saved) {
            rainParams = JSON.parse(saved);
            updateRainParamsUI();
            triggerChartUpdate();
            alert(`Preset "${presetName}" chargé!`);
          } else {
            alert("Preset non trouvé!");
          }
        }
      }

      // Fonction helper pour la pondération temporelle
      // Nouvelle fonction de pondération par palliers
      function getWeight(mm) {
        if (mm === 0) return 0;
        if (mm >= 0.4) return 1.0;

        // Pondération exacte par pallier
        if (Math.abs(mm - 0.1) < 0.001) return rainParams.weightPallier01;
        if (Math.abs(mm - 0.2) < 0.001) return rainParams.weightPallier02;
        if (Math.abs(mm - 0.3) < 0.001) return rainParams.weightPallier03;

        // Interpolation linéaire pour les valeurs intermédiaires
        if (mm < 0.1) return rainParams.weightPallier01 * (mm / 0.1);
        if (mm < 0.2)
          return (
            rainParams.weightPallier01 +
            (rainParams.weightPallier02 - rainParams.weightPallier01) *
              ((mm - 0.1) / 0.1)
          );
        if (mm < 0.3)
          return (
            rainParams.weightPallier02 +
            (rainParams.weightPallier03 - rainParams.weightPallier02) *
              ((mm - 0.2) / 0.1)
          );
        if (mm < 0.4)
          return (
            rainParams.weightPallier03 +
            (1.0 - rainParams.weightPallier03) * ((mm - 0.3) / 0.1)
          );

        return 1.0; // fallback
      }

      // Fonction pour appliquer la pondération temporelle
      function applyTemporalSmoothing(P_raw, i, allPrecipData, timeLength) {
        if (rainParams.temporalMode === "none") {
          return P_raw;
        }

        const weights = calculateTemporalWeights();
        let totalWeight = 0;
        let weightedSum = 0;

        Object.entries(weights).forEach(([timeOffset, weight]) => {
          let targetIndex = i;

          if (timeOffset === "T-2") targetIndex = i - 2;
          else if (timeOffset === "T-1") targetIndex = i - 1;
          else if (timeOffset === "T") targetIndex = i;
          else if (timeOffset === "T+1") targetIndex = i + 1;
          else if (timeOffset === "T+2") targetIndex = i + 2;

          if (
            targetIndex >= 0 &&
            targetIndex < timeLength &&
            allPrecipData[targetIndex] &&
            allPrecipData[targetIndex].length > 0
          ) {
            const values = allPrecipData[targetIndex];
            // NOUVEAU : Utiliser la pondération par palliers au lieu du seuil unique
            const P_t =
              values.reduce((sum, v) => sum + getWeight(v), 0) / values.length;
            weightedSum += P_t * weight;
            totalWeight += weight;
          }
        });

        return totalWeight > 0 ? weightedSum / totalWeight : P_raw;
      }

      // Fonction pour détecter les pics isolés
      function detectIsolatedPeak(
        currentValues,
        currentIndex,
        allPrecipData,
        timeLength
      ) {
        if (currentIndex === 0 || currentIndex === timeLength - 1) {
          return false; // Pas de détection en bordure
        }

        const prevValues = allPrecipData[currentIndex - 1] || [];
        const nextValues = allPrecipData[currentIndex + 1] || [];

        if (prevValues.length === 0 || nextValues.length === 0) {
          return false;
        }

        // Calculer les intensités moyennes
        const currentIntensity =
          currentValues.reduce((sum, v) => sum + v, 0) / currentValues.length;
        const prevIntensity =
          prevValues.reduce((sum, v) => sum + v, 0) / prevValues.length;
        const nextIntensity =
          nextValues.reduce((sum, v) => sum + v, 0) / nextValues.length;

        // Critère : T > 2 × (T-1 + T+1) ET intensité significative
        const threshold = 2 * (prevIntensity + nextIntensity);
        return (
          currentIntensity > threshold && currentIntensity > 0.1 // Seuil minimum pour considérer un pic significatif
        );
      }

      // Mise à jour des statistiques de visualisation
      function updateParamVisualization() {
        // Trouver le paramètre actuellement sélectionné depuis l'interface
        const currentParam = getCurrentParameterFromUI();

        // Calculer des statistiques sur les données actuelles
        if (
          currentParam === "precipitation" ||
          currentParam === "precipitation_probability"
        ) {
          const data = calculateAggregatedData(currentParam);
          if (data && data.length > 0) {
            const validData = data.filter((v) => v !== null && v !== undefined);
            if (validData.length > 0) {
              const avgProba =
                validData.reduce((sum, v) => sum + v, 0) / validData.length;
              const avgElement = document.getElementById("avgProba");
              if (avgElement) {
                avgElement.textContent = avgProba.toFixed(1) + "%";
              }
            }
          }
        }

        const smoothingElement = document.getElementById("smoothingApplied");
        if (smoothingElement) {
          smoothingElement.textContent = rainParams.temporalSmoothing;
        }
      }

      // Fonction helper pour trouver le paramètre actuellement sélectionné
      function getCurrentParameterFromUI() {
        // Chercher quel onglet est actuellement actif
        const activeTabs = document.querySelectorAll(".parameter-tab.active");
        if (activeTabs.length > 0) {
          return activeTabs[0].dataset.parameter;
        }
        return null;
      }

      function calculatePrecipitationAlgorithm(
        paramKey,
        models,
        parameter,
        timeLength
      ) {
        const aggregatedData = [];
        const alpha = rainParams.alphaAggressive;
        const k = rainParams.kFactor;
        const sigmaRef = rainParams.sigmaRef;
        const epsilon = 1e-6;

        // Pré-calculer toutes les données de précipitation par timestamp
        const allPrecipData = [];
        for (let i = 0; i < timeLength; i++) {
          const values = [];
          Object.entries(models).forEach(([model, range]) => {
            const currentHour = i;
            if (currentHour >= range.start && currentHour < range.end) {
              const fullParamName = `${parameter}_${model}`;
              const paramArray = weatherData.hourly[fullParamName];
              if (paramArray) {
                const value = paramArray[i];
                if (value !== null && value !== undefined) {
                  values.push(value);
                }
              }
            }
          });
          allPrecipData.push(values);
        }

        for (let i = 0; i < timeLength; i++) {
          const values = allPrecipData[i];

          if (values.length === 0) {
            aggregatedData.push(null);
            continue;
          }

          let result;

          if (paramKey === "precipitation_probability") {
            // ➤ NOUVEAU : Algorithme de probabilité selon nouvelle méthodologie

            // 1. NOUVELLE formule : P_raw = Σ(poids_i) / N_total avec pondération par palliers
            const P_raw =
              values.reduce((sum, v) => sum + getWeight(v), 0) / values.length;

            // 2. Lissage temporel configurable
            const P_smooth = applyTemporalSmoothing(
              P_raw,
              i,
              allPrecipData,
              timeLength
            );

            // 3. Ajouter boost/pénalité ±10% selon la variance (uniquement sur valeurs significatives)
            const significantValues = values.filter((v) => v > 0);
            let P_corrected = P_smooth;

            if (significantValues.length > 1) {
              const sigma_T = calculateVariance(significantValues);
              const sigma_ref = rainParams.sigmaRef;
              const gamma = rainParams.gamma; // facteur d'agressivité

              const variance_ratio = sigma_ref / (sigma_T + epsilon);
              const correction_factor = clamp(
                -0.1,
                0.1,
                gamma * Math.log(variance_ratio)
              );
              P_corrected = clamp(0.0, 1.0, P_smooth * (1 + correction_factor));
            }

            // 4. Boost/malus selon poids total des modèles
            if (rainParams.enableBoostMalus) {
              const totalWeight = values.reduce(
                (sum, v) => sum + getWeight(v),
                0
              );
              const avgWeight = totalWeight / values.length;
              // Comparer le poids moyen à un seuil de neutralité (ex: 0.5)
              const boost = clamp(
                -0.1,
                0.1,
                rainParams.boostCoeff * (avgWeight - 0.5) * 2 // Normaliser autour de 0.5
              );
              P_corrected = clamp(0.0, 1.0, P_corrected * (1 + boost));
            }

            // 5. Gestion des pics isolés
            if (rainParams.detectIsolatedPeaks && values.length > 0) {
              const hasIsolatedPeak = detectIsolatedPeak(
                values,
                i,
                allPrecipData,
                timeLength
              );
              if (hasIsolatedPeak) {
                const avgWeight =
                  values.reduce((sum, v) => sum + getWeight(v), 0) /
                  values.length;
                if (avgWeight >= rainParams.minWetModels) {
                  // Renforcer le pic
                  const avgIntensity =
                    values.reduce((sum, v) => sum + v, 0) / values.length;
                  const sigma_T = calculateVariance(
                    values.filter((v) => v > 0)
                  );
                  const peakBoost =
                    rainParams.kFactor * (avgIntensity / (sigma_T + epsilon));
                  P_corrected = clamp(0.0, 1.0, P_corrected * (1 + peakBoost));
                } else {
                  // Neutraliser le pic si pas assez de poids total
                  P_corrected = 0;
                }
              }
            }

            // 6. Appliquer le cap de probabilité finale
            if (rainParams.probCap !== Infinity) {
              P_corrected = clamp(0.0, rainParams.probCap, P_corrected);
            }

            result = P_corrected * 100; // Convertir en pourcentage

            // 🧪 LOG DEBUG : Tracer index et result avant push (dans la branche PROBA)
            console.log(
              `🧪 index ${i} (PROBA)`,
              "P_corrected:",
              P_corrected,
              "result:",
              result
            );
          } else {
            // Calcul de la pluviométrie pondérée pour precipitation (mm)
            // ➤ CORRECTION : Filtrer UNIQUEMENT les modèles à 0mm (pas de seuil complexe pour les mm)
            const wettingValues = values.filter((v) => v > 0);
            console.log("🥽 values", values);
            console.log("🥽🥽 wettingValues", wettingValues);
            let mm_weighted;

            if (wettingValues.length === 0) {
              // Aucun modèle ne mouille, résultat = 0
              mm_weighted = 0;
            } else {
              // Utiliser seulement les modèles mouillants (>0mm) pour la pondération gaussienne
              mm_weighted = applyGaussianWeighting(wettingValues);
              console.log("🥽🥽🥽 mm_weighted", mm_weighted);
            }

            // Pondération temporelle T-1, T, T+1
            let mm_final = mm_weighted;

            // Vérifier si T-1 et T+1 existent et ont des données
            const prevValues = i > 0 ? allPrecipData[i - 1] : [];
            const nextValues = i < timeLength - 1 ? allPrecipData[i + 1] : [];

            let temporalWeights = [0.8]; // Poids pour T
            let temporalValues = [mm_weighted];
            console.log("🥽🥽🥽 temporalWeights", temporalWeights);
            console.log("🥽🥽🥽 temporalValues", temporalValues);
            if (prevValues.length > 0) {
              const prevWettingValues = prevValues.filter((v) => v > 0);
              const mm_prev =
                prevWettingValues.length > 0
                  ? applyGaussianWeighting(prevWettingValues)
                  : 0;
              console.log("🥽🥽🥽 mm_prev", mm_prev);
              temporalWeights.unshift(0.1); // Ajouter poids pour T-1
              temporalValues.unshift(mm_prev);
            }

            if (nextValues.length > 0) {
              const nextWettingValues = nextValues.filter((v) => v > 0);
              const mm_next =
                nextWettingValues.length > 0
                  ? applyGaussianWeighting(nextWettingValues)
                  : 0;
              console.log("🥽🥽🥽 mm_next", mm_next);
              temporalWeights.push(0.1); // Ajouter poids pour T+1
              temporalValues.push(mm_next);
            }

            // Normaliser les poids si T-1 ou T+1 manquent
            const totalWeight = temporalWeights.reduce((sum, w) => sum + w, 0);
            const normalizedWeights = temporalWeights.map(
              (w) => w / totalWeight
            );
            console.log("🥽🥽🥽🥽 normalizedWeights", normalizedWeights);
            console.log("🥽🥽🥽🥽 temporalValues", temporalValues);
            console.log(
              "🥽🥽🥽🥽🥽🥽🥽🥽 mm_t-1",
              normalizedWeights[0] * temporalValues[0]
            );
            console.log(
              "🥽🥽🥽🥽🥽🥽🥽🥽 mm_t",
              normalizedWeights[1] * temporalValues[1]
            );
            console.log(
              "🥽🥽🥽🥽🥽🥽🥽🥽 mm_t+1",
              normalizedWeights[2] * temporalValues[2]
            );
            mm_final = temporalValues.reduce(
              (sum, val, idx) => sum + val * normalizedWeights[idx],
              0
            );
            console.log("🥽🥽🥽🥽🥽🥽🥽🥽🥽🥽🥽🥽 mm_final", mm_final);

            // ➤ SUPPRESSION : Plus de traitement des pics isolés pour les mm (gardé seulement pour proba)
            // Le calcul s'arrête ici avec mm_final du lissage temporel
            result = Math.max(0, mm_final);

            // 🧪 LOG DEBUG : Tracer index, mm_final et result avant push (dans la branche MM)
            console.log(
              `🧪 index ${i} (MM)`,
              "mm_final:",
              mm_final,
              "result:",
              result
            );
          }

          // 🧪 LOG DEBUG : Tracer index et result avant push (commun)
          console.log(`🧪 index ${i}`, "result:", result);
          aggregatedData.push(result);
        }

        // 🧪 LOG DEBUG : Afficher le tableau final pour comparaison avec le graphe
        console.log(
          "🧪🧪 aggregatedData FINAL pour",
          paramKey,
          ":",
          aggregatedData
        );
        return aggregatedData;
      }

      // Fonction pour gérer les valeurs circulaires (direction du vent)
      function applyCircularAggregationStrategy(values, strategy) {
        if (values.length === 0) return 0;
        if (values.length === 1) return values[0];

        // Étape 1 : Choix du pivot
        let pivot;
        const sorted = [...values].sort((a, b) => a - b);

        if (values.length === 2) {
          const [a, b] = sorted;
          const directDiff = Math.abs(b - a);
          const circularDiff = 360 - directDiff;
          pivot = (a + (directDiff < circularDiff ? b : b + 360)) / 2;
          if (pivot >= 360) pivot -= 360;
        } else {
          const mid = Math.floor(sorted.length / 2);
          pivot =
            sorted.length % 2 === 0
              ? (sorted[mid - 1] + sorted[mid]) / 2
              : sorted[mid];
        }

        // Étape 2 : Centrage dans [-180, +180] autour du pivot
        const centered = values.map((angle) => {
          let delta = angle - pivot;
          while (delta > 180) delta -= 360;
          while (delta <= -180) delta += 360;
          return delta;
        });

        const sortedCentered = [...centered].sort((a, b) => a - b);

        // Étape 3 : Application de la stratégie
        let result;
        switch (strategy) {
          case "mean":
            result =
              centered.reduce((sum, val) => sum + val, 0) / centered.length;
            break;

          case "median":
            const mid = Math.floor(sortedCentered.length / 2);
            result =
              sortedCentered.length % 2 === 0
                ? (sortedCentered[mid - 1] + sortedCentered[mid]) / 2
                : sortedCentered[mid];
            break;

          case "trimmed_mean":
            if (centered.length <= 2) {
              result =
                centered.reduce((sum, val) => sum + val, 0) / centered.length;
            } else {
              const trimmed = sortedCentered.slice(1, -1); // Enlève min & max
              result =
                trimmed.reduce((sum, val) => sum + val, 0) / trimmed.length;
            }
            break;

          case "weighted_mean":
            const mean =
              centered.reduce((sum, val) => sum + val, 0) / centered.length;
            const stdDev = Math.sqrt(
              centered.reduce((sum, val) => sum + (val - mean) ** 2, 0) /
                centered.length
            );
            if (stdDev === 0) {
              result = mean;
            } else {
              const weights = centered.map(
                (val) => 1 / (1 + Math.abs(val - mean) / stdDev)
              );
              const weightSum = weights.reduce((sum, w) => sum + w, 0);
              result =
                centered.reduce((sum, val, i) => sum + val * weights[i], 0) /
                weightSum;
            }
            break;

          case "winsorized_mean":
            if (centered.length <= 2) {
              result =
                centered.reduce((sum, val) => sum + val, 0) / centered.length;
            } else {
              const lower = sortedCentered[1];
              const upper = sortedCentered[sortedCentered.length - 2];
              const winsorized = centered.map((val) =>
                Math.min(Math.max(val, lower), upper)
              );
              result =
                winsorized.reduce((sum, val) => sum + val, 0) /
                winsorized.length;
            }
            break;

          case "gaussian_weighted":
            const gMean =
              centered.reduce((sum, val) => sum + val, 0) / centered.length;
            const gStdDev = Math.sqrt(
              centered.reduce((sum, val) => sum + (val - gMean) ** 2, 0) /
                centered.length
            );
            if (gStdDev === 0) {
              result = gMean;
            } else {
              const gWeights = centered.map((val) => {
                const z = (val - gMean) / gStdDev;
                return Math.exp(-0.5 * z * z);
              });
              const gWeightSum = gWeights.reduce((sum, w) => sum + w, 0);
              result =
                centered.reduce((sum, val, i) => sum + val * gWeights[i], 0) /
                gWeightSum;
            }
            break;

          default:
            result =
              centered.reduce((sum, val) => sum + val, 0) / centered.length;
        }

        // Étape 4 : Décalage du pivot + normalisation [0, 360)
        let final = result + pivot;
        while (final < 0) final += 360;
        while (final >= 360) final -= 360;

        return final;
      }

      function applyAggregationStrategy(values, strategy, isCircular = false) {
        if (isCircular) {
          return applyCircularAggregationStrategy(values, strategy);
        }

        const sortedValues = [...values].sort((a, b) => a - b);

        switch (strategy) {
          case "mean":
            return values.reduce((sum, val) => sum + val, 0) / values.length;

          case "median":
            const mid = Math.floor(sortedValues.length / 2);
            return sortedValues.length % 2 === 0
              ? (sortedValues[mid - 1] + sortedValues[mid]) / 2
              : sortedValues[mid];

          case "trimmed_mean":
            if (sortedValues.length <= 2)
              return applyAggregationStrategy(values, "mean");
            // Retirer la plus basse et la plus haute
            const trimmed = sortedValues.slice(1, -1);
            return trimmed.reduce((sum, val) => sum + val, 0) / trimmed.length;

          case "precipitation_algo":
            // L'algorithme de précipitation est complexe et nécessite des données contextuelles
            // Pour l'instant, on retourne la moyenne gaussienne pondérée comme fallback
            // L'implémentation complète sera gérée au niveau de calculateAggregatedData
            return applyAggregationStrategy(values, "gaussian_weighted");

          case "winsorized_mean":
            const p = 1; // nombre de valeurs extrêmes à "écraser"
            if (sortedValues.length <= 2 * p)
              return applyAggregationStrategy(values, "mean");

            const lowerBound = sortedValues[p];
            const upperBound = sortedValues[sortedValues.length - 1 - p];

            const winsorized = values.map((val) => {
              if (val < lowerBound) return lowerBound;
              if (val > upperBound) return upperBound;
              return val;
            });
            return (
              winsorized.reduce((sum, val) => sum + val, 0) / winsorized.length
            );

          case "gaussian_weighted":
            const gMean = applyAggregationStrategy(values, "mean");
            const gStdDev = Math.sqrt(
              values.reduce((sum, val) => sum + Math.pow(val - gMean, 2), 0) /
                values.length
            );
            if (gStdDev === 0) return gMean;

            const gWeights = values.map((val) => {
              const z = (val - gMean) / gStdDev;
              return Math.exp(-0.5 * z * z);
            });
            const gWeightSum = gWeights.reduce((sum, w) => sum + w, 0);
            return (
              values.reduce((sum, val, i) => sum + val * gWeights[i], 0) /
              gWeightSum
            );

          default:
            return values.reduce((sum, val) => sum + val, 0) / values.length;
        }
      }

      function createAggregatedChart(data, paramKey) {
        const canvas = document.getElementById("aggregatedChart");

        // Destroy existing chart properly
        if (aggregatedChart) {
          aggregatedChart.destroy();
          aggregatedChart = null;
        }

        // Clear canvas context
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Create simple time labels for aggregated chart
        const timeLabels = weatherData.hourly.time.map((time, index) => {
          const date = new Date(time);
          if (index % 12 === 0) {
            // Show every 12 hours for date + 12h format
            const day = date.getDate();
            const month = date.toLocaleDateString("fr-FR", { month: "short" });
            return `${day} ${month} 12h`;
          } else if (index % 12 === 6) {
            // Show just date for mid-day points
            const day = date.getDate();
            const month = date.toLocaleDateString("fr-FR", { month: "short" });
            return `${day} ${month}`;
          }
          return "";
        });

        aggregatedChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: timeLabels,
            datasets: [
              {
                label: `${PARAMETERS[paramKey].label} (${STRATEGIES[selectedStrategy].label})`,
                data: data,
                borderColor: "#059669",
                backgroundColor: "#05966920",
                fill: true,
                tension: 0.1,
                pointRadius: 1,
                pointHoverRadius: 4,
                borderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              tooltip: {
                callbacks: {
                  title: function (context) {
                    const index = context[0].dataIndex;
                    const time = weatherData.hourly.time[index];
                    const date = new Date(time);
                    return date.toLocaleDateString("fr-FR", {
                      day: "2-digit",
                      month: "2-digit",
                      year: "numeric",
                      hour: "2-digit",
                      minute: "2-digit",
                    });
                  },
                },
              },
            },
            scales: {
              x: {
                type: "category",
                title: {
                  display: false,
                },
              },
              y: {
                title: {
                  display: true,
                  text: PARAMETERS[paramKey].unit,
                },
              },
            },
          },
        });

        // Stocker les données agrégées et afficher le panel d'analyse
        currentAggregatedData = data;
        console.log(
          "🎯 Appel updateAnalysisPanel depuis createAggregatedChart"
        );
        console.log("📊 Données:", {
          weatherData: !!weatherData,
          data: data ? data.length : 0,
          selectedStrategy,
        });

        // Mettre à jour l'analyse avec les nouvelles données
        console.log("🎯 DEBUG PANEL - Trigger depuis createAggregatedChart", {
          hasData: !!(data && data.length > 0),
          dataLength: data ? data.length : 0,
        });
        updateAnalysisPanel(weatherData, data);
      }

      // Wind directions - 16 sectors based on the image
      const WIND_DIRECTIONS = [
        { name: "N", angle: 0, min: 348.75, max: 11.25 },
        { name: "NNE", angle: 22.5, min: 11.25, max: 33.75 },
        { name: "NE", angle: 45, min: 33.75, max: 56.25 },
        { name: "ENE", angle: 67.5, min: 56.25, max: 78.75 },
        { name: "E", angle: 90, min: 78.75, max: 101.25 },
        { name: "ESE", angle: 112.5, min: 101.25, max: 123.75 },
        { name: "SE", angle: 135, min: 123.75, max: 146.25 },
        { name: "SSE", angle: 157.5, min: 146.25, max: 168.75 },
        { name: "S", angle: 180, min: 168.75, max: 191.25 },
        { name: "SSO", angle: 202.5, min: 191.25, max: 213.75 },
        { name: "SO", angle: 225, min: 213.75, max: 236.25 },
        { name: "OSO", angle: 247.5, min: 236.25, max: 258.75 },
        { name: "O", angle: 270, min: 258.75, max: 281.25 },
        { name: "ONO", angle: 292.5, min: 281.25, max: 303.75 },
        { name: "NO", angle: 315, min: 303.75, max: 326.25 },
        { name: "NNO", angle: 337.5, min: 326.25, max: 348.75 },
      ];

      // Beaufort scale colors based on wind speed
      const BEAUFORT_COLORS = [
        { min: 0, max: 1, color: "#00BFFF", name: "Calme" },
        { min: 1, max: 11, color: "#7FFF00", name: "Très légère brise" },
        { min: 11, max: 19, color: "#32CD32", name: "Légère brise" },
        { min: 19, max: 28, color: "#FFFF00", name: "Petite brise" },
        { min: 28, max: 38, color: "#FFD700", name: "Jolie brise" },
        { min: 38, max: 49, color: "#FFA500", name: "Bonne brise" },
        { min: 49, max: 61, color: "#FF4500", name: "Vent frais" },
        { min: 61, max: 74, color: "#FF0000", name: "Grand frais" },
        { min: 74, max: 88, color: "#DC143C", name: "Coup de vent" },
        { min: 88, max: 102, color: "#8B008B", name: "Fort coup de vent" },
        { min: 102, max: 117, color: "#4B0082", name: "Tempête" },
        {
          min: 117,
          max: 999,
          color: "#2F2F2F",
          name: "Violente tempête/Ouragan",
        },
      ];

      function getBeaufortColor(windSpeed) {
        for (let scale of BEAUFORT_COLORS) {
          if (windSpeed >= scale.min && windSpeed < scale.max) {
            return scale.color;
          }
        }
        return BEAUFORT_COLORS[BEAUFORT_COLORS.length - 1].color; // Fallback to strongest
      }

      function getWindDirectionSector(degrees) {
        // Handle the special case of North (crosses 0°)
        if (degrees >= 348.75 || degrees < 11.25) {
          return WIND_DIRECTIONS[0]; // N
        }

        // Find the sector for other directions
        for (let i = 1; i < WIND_DIRECTIONS.length; i++) {
          const sector = WIND_DIRECTIONS[i];
          if (degrees >= sector.min && degrees < sector.max) {
            return sector;
          }
        }

        // Fallback to North if no match
        return WIND_DIRECTIONS[0];
      }

      function createWindRadarChart() {
        const canvas = document.getElementById("windRadarChart");
        if (!canvas) return;

        // Destroy existing chart
        if (windRadarChart) {
          windRadarChart.destroy();
          windRadarChart = null;
        }

        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Calculate maximum wind speed from the entire dataset for fixed scale
        const windSpeedData = calculateAggregatedData("wind_speed");
        maxWindSpeedInData = Math.max(
          ...windSpeedData.filter((v) => v !== null && v !== undefined)
        );
        const fixedMaxScale = Math.ceil((maxWindSpeedInData + 10) / 10) * 10; // Round up to nearest 10 + margin

        // Get current wind data for color calculation
        const windDirectionData = calculateAggregatedData("wind_direction");
        const currentSpeed = windSpeedData[currentTimeIndex] || 0;
        const beaufortColor = getBeaufortColor(currentSpeed);

        const chartConfig = {
          type: "radar",
          data: {
            labels: WIND_DIRECTIONS.map((d) => d.name),
            datasets: [
              {
                label: `Direction & Force (${STRATEGIES[selectedStrategy].label})`,
                data: new Array(16).fill(0),
                borderColor: beaufortColor,
                backgroundColor: beaufortColor + "80",
                borderWidth: 3,
                pointBackgroundColor: "#059669",
                pointBorderColor: "#ffffff",
                pointRadius: 0, // Hide individual points
                pointHoverRadius: 6,
                fill: true,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: {
              duration: 0, // Disable all animations
            },
            plugins: {
              legend: {
                position: "top",
              },
              tooltip: {
                callbacks: {
                  label: function (context) {
                    const direction = WIND_DIRECTIONS[context.dataIndex].name;
                    const speed = context.parsed.r.toFixed(1);

                    // Find Beaufort scale info
                    const beaufortInfo = BEAUFORT_COLORS.find(
                      (scale) =>
                        parseFloat(speed) >= scale.min &&
                        parseFloat(speed) < scale.max
                    );
                    const beaufortName = beaufortInfo
                      ? beaufortInfo.name
                      : "Inconnu";

                    return [
                      `${direction}: ${speed} km/h`,
                      `Beaufort: ${beaufortName}`,
                    ];
                  },
                },
              },
            },
            scales: {
              r: {
                beginAtZero: true,
                max: fixedMaxScale, // Fixed scale based on dataset maximum
                ticks: {
                  stepSize: Math.max(5, Math.ceil(fixedMaxScale / 10)),
                  // Custom callback to display actual wind speeds instead of transformed values
                  callback: function (value, index, values) {
                    // Convert back from display value to actual wind speed
                    // displayValue = sqrt(speed/max) * max
                    // So: speed = (displayValue/max)² * max = displayValue² / max
                    const actualSpeed = (value * value) / maxWindSpeedInData;

                    // Only show ticks at meaningful intervals
                    const meaningfulSpeeds = [
                      0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 60, 70, 80, 90,
                      100,
                    ];
                    const closest = meaningfulSpeeds.find(
                      (speed) => Math.abs(actualSpeed - speed) < 2
                    );

                    if (closest !== undefined) {
                      return closest + " km/h";
                    }
                    return "";
                  },
                },
                grid: {
                  color: "rgba(0, 0, 0, 0.1)",
                },
                angleLines: {
                  color: "rgba(0, 0, 0, 0.1)",
                },
                pointLabels: {
                  font: {
                    size: 12,
                    weight: "bold",
                  },
                },
              },
            },
          },
        };

        windRadarChart = new Chart(ctx, chartConfig);

        // Initialize with first time index
        updateWindRadar();
      }

      function updateWindRadar() {
        if (!windRadarChart || !weatherData) return;

        const timeSlider = document.getElementById("timeSlider");
        const currentTimeLabel = document.getElementById("currentTimeLabel");

        currentTimeIndex = parseInt(timeSlider.value);

        // Update time label
        const currentTime = weatherData.hourly.time[currentTimeIndex];
        if (currentTime) {
          const date = new Date(currentTime);
          const timeStr = date.toLocaleDateString("fr-FR", {
            day: "2-digit",
            month: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
          });
          currentTimeLabel.textContent = `Heure: ${timeStr} (${currentTimeIndex}H)`;
        }

        // Get aggregated wind data for current time
        const windSpeedData = calculateAggregatedData("wind_speed");
        const windDirectionData = calculateAggregatedData("wind_direction");

        if (
          !windSpeedData[currentTimeIndex] ||
          !windDirectionData[currentTimeIndex]
        ) {
          // No data for this time, set all sectors to 0
          windRadarChart.data.datasets[0].data = new Array(16).fill(0);
          windRadarChart.update();
          return;
        }

        const currentSpeed = windSpeedData[currentTimeIndex];
        const currentDirection = windDirectionData[currentTimeIndex];

        // Find the sector for current wind direction
        const sector = getWindDirectionSector(currentDirection);

        // Function to calculate display value for logarithmic scale
        // Surface of triangle proportional to wind speed
        function getDisplayValue(windSpeed) {
          if (windSpeed <= 0) return 0;
          // Use square root to make surface proportional to speed
          // Surface = base * height, if we control height by sqrt(speed), surface becomes proportional to speed
          return Math.sqrt(windSpeed / maxWindSpeedInData) * maxWindSpeedInData;
        }

        // Create triangular sector for radar chart
        const chartData = new Array(16).fill(0);
        const sectorIndex = WIND_DIRECTIONS.findIndex(
          (d) => d.name === sector.name
        );

        if (sectorIndex !== -1) {
          // Calculate display value for logarithmic scale
          const displayValue = getDisplayValue(currentSpeed);

          // Set the main sector and its immediate neighbors to create a triangle effect
          // The triangle base should be in the direction the wind comes FROM
          chartData[sectorIndex] = displayValue; // Center of the sector

          // Add the two adjacent sectors to form the triangle base
          const leftIndex = (sectorIndex - 1 + 16) % 16;
          const rightIndex = (sectorIndex + 1) % 16;

          chartData[leftIndex] = displayValue;
          chartData[rightIndex] = displayValue;
        }

        // Update chart data
        windRadarChart.data.datasets[0].data = chartData;
        windRadarChart.data.datasets[0].label = `Direction & Force (${
          STRATEGIES[selectedStrategy].label
        }) - ${currentSpeed.toFixed(1)} km/h`;

        // Update colors based on current wind speed
        const beaufortColor = getBeaufortColor(currentSpeed);
        windRadarChart.data.datasets[0].borderColor = beaufortColor;
        windRadarChart.data.datasets[0].backgroundColor = beaufortColor + "80";

        // Keep the fixed scale - no dynamic adjustment

        windRadarChart.update({ duration: 0 }); // Disable animation on update
      }
    </script>
    <script>
      /* Masquer bouton "Appliquer la stratégie" et le 2ᵉ graphique */
      document.addEventListener("DOMContentLoaded", () => {
        const btnApply = document.getElementById("applyStrategy");
        if (btnApply) btnApply.style.display = "none";

        const aggregatedCanvas = document.getElementById("aggregatedChart");
        if (aggregatedCanvas && aggregatedCanvas.parentElement) {
          aggregatedCanvas.parentElement.style.display = "none";
        }
      });

      /* Ajustement visuel : boutons de stratégie plus compacts */
      const styleTag = document.createElement("style");
      styleTag.textContent = `
        .strategy-card {
          padding: 6px 10px;
          font-size: 0.8rem;
          min-width: 120px;
        }
        
        .tooltip-trigger:hover + .tooltip-content,
        .tooltip-content:hover {
          display: block !important;
        }
        
        .analysis-btn:hover {
          background: #555 !important;
        }
        
        .analysis-btn.active {
          background: #666 !important;
          border-color: #888 !important;
        }
      `;
      document.head.appendChild(styleTag);

      // Variables globales pour l'analyse
      let currentAnalysisRange = "short";
      let cachedModelAnalysis = {};
      let currentAggregatedData = null;

      // Fonctions pour l'analyse des modèles
      function calculateStandardDeviation(values) {
        if (values.length === 0) return 0;
        const mean = values.reduce((a, b) => a + b, 0) / values.length;
        const variance =
          values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
        return Math.sqrt(variance);
      }

      function calculateModelDeviations(
        weatherData,
        aggregatedData,
        timeRange = [0, 48]
      ) {
        const modelDeviations = {};
        const [startHour, endHour] = timeRange;
        const currentParam = getActiveParam();

        console.log(
          `🔍 Calcul des déviations pour ${currentParam} sur la plage ${startHour}-${endHour}h`
        );

        // Extraire les données des modèles depuis le graphique principal
        if (
          !currentChart ||
          !currentChart.data ||
          !currentChart.data.datasets
        ) {
          console.log("❌ DEBUG PANEL - Pas de graphique principal disponible");
          return { models: [], standardDeviation: 0 };
        }

        // Pour chaque modèle (exclure l'agrégation)
        currentChart.data.datasets.forEach((dataset, index) => {
          // Filtrer: ignorer agrégation et modèles non autorisés selon la plage
          if (dataset.isAggregate || !isModelAllowed(dataset.label)) {
            return;
          }

          const modelData = dataset.data;
          const deviations = [];

          console.log(
            `🔍 DEBUG PANEL - Traitement modèle: ${dataset.label}, données: ${
              modelData ? modelData.length : "null"
            }`
          );

          // Calculer les déviations pour chaque point dans la plage temporelle
          for (
            let i = startHour;
            i < Math.min(endHour, aggregatedData.length, modelData.length);
            i++
          ) {
            if (
              modelData[i] !== null &&
              modelData[i] !== undefined &&
              aggregatedData[i] !== null &&
              aggregatedData[i] !== undefined
            ) {
              const deviation = Math.abs(modelData[i] - aggregatedData[i]);
              deviations.push(deviation);
            }
          }

          modelDeviations[dataset.label] = {
            deviations: deviations,
            avgDeviation:
              deviations.length > 0
                ? deviations.reduce((a, b) => a + b, 0) / deviations.length
                : 0,
            stdDev: calculateStandardDeviation(deviations),
            values: deviations.slice(0, 28), // 28 premières valeurs
          };

          console.log(
            `📊 ${dataset.label}: ${
              deviations.length
            } déviations, moyenne: ${modelDeviations[
              dataset.label
            ].avgDeviation.toFixed(2)}`
          );
        });

        return modelDeviations;
      }

      function updateAnalysisPanel(weatherData, aggregatedData) {
        console.log("🎯 DEBUG PANEL - updateAnalysisPanel called", {
          hasWeatherData: !!weatherData,
          hasAggregatedData: !!aggregatedData,
          aggregatedDataLength: aggregatedData ? aggregatedData.length : 0,
          aggregatedDataSample: aggregatedData
            ? aggregatedData.slice(0, 5)
            : null,
        });

        // Toujours afficher le panel d'analyse
        const analysisSection = document.getElementById("analysisSection");
        if (analysisSection) {
          analysisSection.style.display = "block";
        }

        // Si pas de données d'agrégation, essayer de récupérer celles du graphique principal
        if (!aggregatedData && weatherData) {
          console.log(
            "🔍 DEBUG PANEL - Tentative récupération agrégation du graphique principal"
          );
          aggregatedData = extractAggregationFromMainChart();
          console.log("🔍 DEBUG PANEL - Agrégation extraite:", {
            success: !!aggregatedData,
            length: aggregatedData ? aggregatedData.length : 0,
          });
        }

        if (!weatherData || !aggregatedData) {
          console.log("❌ DEBUG PANEL - Données insuffisantes", {
            weatherData: !!weatherData,
            aggregatedData: !!aggregatedData,
          });

          // Afficher un message d'instruction
          const explanationEl = document.getElementById("analysisExplanation");
          if (explanationEl) {
            explanationEl.innerHTML = `
              <strong style="color: #ff6b6b;">⚠️ Aucune donnée d'agrégation disponible</strong><br><br>
              Pour utiliser ce panel :<br>
              1️⃣ Sélectionnez des modèles météo dans la section visualisation<br>
              2️⃣ Allez dans "🔧 Stratégies d'agrégation"<br>
              3️⃣ Cliquez "⚡ Appliquer la stratégie"<br>
              4️⃣ L'analyse s'affichera automatiquement ici !
            `;
          }
          return;
        }

        console.log(
          "🎯 DEBUG PANEL - updateAnalysisPanel avec données valides"
        );

        const timeRanges = {
          short: [0, 48],
          medium: [48, 96],
          long: [96, 168],
          prorated: [0, 168],
          weighted: [0, 168],
          composite: [0, 168],
        };

        const range = timeRanges[currentAnalysisRange];
        const modelDeviations = calculateModelDeviations(
          weatherData,
          aggregatedData,
          range
        );

        // Trier les modèles par déviation moyenne
        const sortedModels = Object.entries(modelDeviations)
          .filter(([name, data]) => data.deviations.length > 0)
          .sort((a, b) => a[1].avgDeviation - b[1].avgDeviation);

        if (sortedModels.length === 0) {
          console.log("❌ Aucun modèle trouvé pour l'analyse");
          return;
        }

        const winner = sortedModels[0];
        const loser = sortedModels[sortedModels.length - 1];

        // Calculer l'écart-type de l'agrégation
        const aggregationStdDev = calculateStandardDeviation(
          aggregatedData.slice(range[0], range[1])
        );

        // Mettre à jour l'affichage
        const aggregationNameEl = document.getElementById("aggregationName");
        const aggregationStdDevEl =
          document.getElementById("aggregationStdDev");
        const winnerModelEl = document.getElementById("winnerModel");
        const winnerStdDevEl = document.getElementById("winnerStdDev");
        const loserModelEl = document.getElementById("loserModel");
        const loserStdDevEl = document.getElementById("loserStdDev");

        console.log(
          `🎯 DEBUG PANEL - Mise à jour affichage: gagnant=${winner[0]}, perdant=${loser[0]}`
        );
        console.log(
          `🎯 DEBUG PANEL - Éléments trouvés: aggregationName=${!!aggregationNameEl}, winnerModel=${!!winnerModelEl}, loserModel=${!!loserModelEl}`
        );

        // Utiliser "Moyenne arithmétique" par défaut si selectedStrategy n'est pas définie
        const strategyName =
          selectedStrategy && STRATEGIES[selectedStrategy]
            ? STRATEGIES[selectedStrategy].label
            : "Moyenne arithmétique";

        if (aggregationNameEl) aggregationNameEl.textContent = strategyName;
        if (aggregationStdDevEl)
          aggregationStdDevEl.textContent = aggregationStdDev.toFixed(2);
        if (winnerModelEl) winnerModelEl.textContent = winner[0];
        if (winnerStdDevEl)
          winnerStdDevEl.textContent = winner[1].avgDeviation.toFixed(2);
        if (loserModelEl) loserModelEl.textContent = loser[0];
        if (loserStdDevEl)
          loserStdDevEl.textContent = loser[1].avgDeviation.toFixed(2);

        console.log(
          `✅ DEBUG PANEL - Affichage mis à jour: ${strategyName}, gagnant: ${
            winner[0]
          } (${winner[1].avgDeviation.toFixed(2)}), perdant: ${
            loser[0]
          } (${loser[1].avgDeviation.toFixed(2)})`
        );

        // Mettre à jour le tableau de comparaison
        updateComparisonTable(
          weatherData,
          aggregatedData,
          winner,
          loser,
          range
        );

        // Mettre à jour l'explication
        updateAnalysisExplanation();

        console.log("✅ DEBUG PANEL - Panel d'analyse mis à jour avec", {
          vainqueur: winner[0],
          perdant: loser[0],
          ecartTypeAgg: aggregationStdDev.toFixed(2),
        });
      }

      function updateComparisonTable(
        weatherData,
        aggregatedData,
        winner,
        loser,
        range
      ) {
        const tableHeaders = document.getElementById("tableHeaders");
        const aggregationRow = document.getElementById("aggregationRow");
        const winnerRow = document.getElementById("winnerRow");
        const loserRow = document.getElementById("loserRow");

        if (!tableHeaders || !aggregationRow || !winnerRow || !loserRow) {
          console.log("❌ Éléments du tableau introuvables");
          return;
        }

        // Créer les en-têtes avec dates courtes - 28 valeurs toutes les 6 heures
        const headers = ["Modèle"];
        const aggregationValues = ["Agrégation"];
        const winnerLabel = `🏆 ${winner[0]} (σ ${winner[1].stdDev.toFixed(
          2
        )})`;
        const loserLabel = `📉 ${loser[0]} (σ ${loser[1].stdDev.toFixed(2)})`;
        const winnerValues = [winnerLabel];
        const loserValues = [loserLabel];

        // Générer exactement 28 valeurs toutes les 6 heures (28 * 6 = 168h = 7 jours)
        for (let i = 0; i < 28; i++) {
          const dataIndex = i * 6; // Toutes les 6 heures
          const date = new Date(
            weatherData.hourly.time[
              Math.min(dataIndex, weatherData.hourly.time.length - 1)
            ]
          );
          const day = String(date.getDate()).padStart(2, "0");
          const hour = String(date.getHours()).padStart(2, "0");
          const shortDate = `${day}-${hour}h`;

          if (dataIndex < range[0] || dataIndex >= range[1]) {
            headers.push(shortDate);
            aggregationValues.push("X");
            winnerValues.push("X");
            loserValues.push("X");
            continue;
          }

          if (dataIndex < weatherData.hourly.time.length) {
            headers.push(shortDate);

            // Valeur agrégée
            let aggRaw = aggregatedData[dataIndex];
            if (aggRaw && typeof aggRaw === "object") {
              aggRaw = aggRaw.y !== undefined ? aggRaw.y : null;
            }
            aggregationValues.push(
              aggRaw !== null && aggRaw !== undefined ? aggRaw.toFixed(1) : "X"
            );

            // Valeur du gagnant (extraire du graphique)
            const winnerDataset = currentChart.data.datasets.find(
              (dataset) => dataset.label === winner[0]
            );
            const winnerValue =
              winnerDataset &&
              winnerDataset.data[dataIndex] !== null &&
              winnerDataset.data[dataIndex] !== undefined
                ? winnerDataset.data[dataIndex]
                : null;
            winnerValues.push(
              winnerValue !== null ? winnerValue.toFixed(1) : "X"
            );

            // Valeur du perdant (extraire du graphique)
            const loserDataset = currentChart.data.datasets.find(
              (dataset) => dataset.label === loser[0]
            );
            const loserValue =
              loserDataset &&
              loserDataset.data[dataIndex] !== null &&
              loserDataset.data[dataIndex] !== undefined
                ? loserDataset.data[dataIndex]
                : null;
            loserValues.push(loserValue !== null ? loserValue.toFixed(1) : "X");
          } else {
            // Si on dépasse les données disponibles, mettre "X"
            headers.push("--");
            aggregationValues.push("X");
            winnerValues.push("X");
            loserValues.push("X");
          }
        }

        // Construire le tableau avec le nouveau style moderne
        tableHeaders.innerHTML = headers
          .map(
            (header) =>
              `<th style="padding: 6px 4px; border: 1px solid #e2e8f0; color: #475569; text-align: center; min-width: 45px; font-size: 10px; font-weight: 600;">${header}</th>`
          )
          .join("");

        aggregationRow.innerHTML = aggregationValues
          .map(
            (value, index) =>
              `<td style="padding: 6px 4px; border: 1px solid #e2e8f0; color: ${
                index === 0 ? "#059669" : "#374151"
              }; text-align: center;  ${
                index === 0
                  ? "font-weight: bold; font-size: 10px;"
                  : "font-weight: bold; font-size: 10px;"
              } ${value === "X" ? "color: #9ca3af;" : ""}">${value}</td>`
          )
          .join("");

        winnerRow.innerHTML = winnerValues
          .map(
            (value, index) =>
              `<td style="padding: 6px 4px; border: 1px solid #e2e8f0; color: ${
                index === 0 ? "#16a34a" : "#374151"
              }; text-align: center;  ${
                index === 0
                  ? "font-weight: bold; font-size: 10px;"
                  : "font-weight: bold; font-size: 10px;"
              } ${value === "X" ? "color: #9ca3af;" : ""}">${value}</td>`
          )
          .join("");

        loserRow.innerHTML = loserValues
          .map(
            (value, index) =>
              `<td style="padding: 6px 4px; border: 1px solid #e2e8f0; color: ${
                index === 0 ? "#dc2626" : "#374151"
              }; text-align: center;  ${
                index === 0
                  ? "font-weight: bold; font-size: 10px;"
                  : "font-weight: bold; font-size: 10px;"
              } ${value === "X" ? "color: #9ca3af;" : ""}">${value}</td>`
          )
          .join("");
      }

      function getActiveParam() {
        const activeTab = document.querySelector(".tab-btn.active");
        return activeTab ? activeTab.dataset.param : "temperature_2m";
      }

      function extractAggregationFromMainChart() {
        console.log("🔍 DEBUG PANEL - extractAggregationFromMainChart start");

        try {
          // Vérifier si le graphique principal existe
          if (
            !currentChart ||
            !currentChart.data ||
            !currentChart.data.datasets
          ) {
            console.log("❌ DEBUG PANEL - Pas de graphique principal");
            return null;
          }

          // Chercher le dataset d'agrégation (généralement le dernier avec "Moyenne" dans le nom)
          const datasets = currentChart.data.datasets;
          console.log(
            "🔍 DEBUG PANEL - Datasets disponibles:",
            datasets.map((d) => d.label)
          );

          let aggregationDataset = datasets.find((ds) => ds.isAggregate);
          if (!aggregationDataset) {
            aggregationDataset = datasets.find(
              (dataset) => dataset.label === STRATEGIES[selectedStrategy].label
            );
          }
          if (!aggregationDataset) {
            aggregationDataset = datasets.find(
              (dataset) =>
                dataset.label &&
                (dataset.label.includes("Moyenne") ||
                  dataset.label.includes("moyenne") ||
                  dataset.label.includes("Agrégation") ||
                  dataset.label.includes("agrégation"))
            );
          }

          if (!aggregationDataset) {
            console.log("❌ DEBUG PANEL - Pas de dataset d'agrégation trouvé");
            return null;
          }

          console.log(
            "✅ DEBUG PANEL - Dataset d'agrégation trouvé:",
            aggregationDataset.label
          );
          console.log("🔍 DEBUG PANEL - Données:", {
            length: aggregationDataset.data
              ? aggregationDataset.data.length
              : 0,
            sample: aggregationDataset.data
              ? aggregationDataset.data.slice(0, 10)
              : null,
          });

          // Filtrer les valeurs null/undefined
          const cleanData = aggregationDataset.data.filter(
            (value) => value !== null && value !== undefined
          );
          console.log(
            "✅ DEBUG PANEL - Données nettoyées:",
            cleanData.length,
            "valeurs"
          );

          return cleanData;
        } catch (error) {
          console.error("❌ DEBUG PANEL - Erreur extraction:", error);
          return null;
        }
      }

      function updateAnalysisExplanation() {
        const explanations = {
          short:
            "Analyse 0-48h : Comparaison des modèles court terme (GFS, ECMWF, ICON) pour les prévisions immédiates.",
          medium:
            "Analyse 48-96h : Comparaison des modèles moyen terme, période critique pour la fiabilité des prévisions.",
          long: "Analyse 96-168h : Comparaison long terme (7 jours), seuls certains modèles globaux sont disponibles.",
          prorated:
            "Analyse proratisée : Écart-type divisé par le nombre de points disponibles pour neutraliser la durée.",
          weighted:
            "Analyse pondérée temporelle : Points proches du T0 = poids 1, points lointains = poids réduit.",
          composite:
            "Score mixte : Combinaison de la moyenne des écarts-types, stabilité temporelle et couverture normalisée.",
        };

        document.getElementById("analysisExplanation").textContent =
          explanations[currentAnalysisRange] ||
          "Sélectionnez une stratégie d'analyse pour voir les détails.";
      }

      // Event listeners pour les boutons d'analyse
      document.addEventListener("DOMContentLoaded", function () {
        const analysisButtons = document.querySelectorAll(".analysis-btn");

        analysisButtons.forEach((button) => {
          button.addEventListener("click", function () {
            // Retirer la classe active de tous les boutons
            analysisButtons.forEach((btn) => btn.classList.remove("active"));

            // Ajouter la classe active au bouton cliqué
            this.classList.add("active");

            // Mettre à jour la plage d'analyse
            currentAnalysisRange = this.getAttribute("data-range");

            // Mettre à jour l'analyse avec stratégie changée
            console.log(
              "🎯 DEBUG PANEL - Bouton cliqué:",
              currentAnalysisRange
            );

            // Toujours essayer de mettre à jour, même sans currentAggregatedData
            if (typeof weatherData !== "undefined") {
              updateAnalysisPanel(weatherData, currentAggregatedData);
            } else {
              console.log("❌ DEBUG PANEL - Pas de weatherData");
            }
          });
        });

        // Initialiser l'explication par défaut
        updateAnalysisExplanation();

        // Afficher le panel d'analyse avec les instructions dès le chargement
        console.log("🎯 DEBUG PANEL - Initialisation du panel");
        updateAnalysisPanel(null, null);

        // Fonction de diagnostic du panel d'analyse
        window.debugAnalysisPanel = function () {
          console.log("🔧 DEBUG PANEL - État complet:", {
            analysisSection: !!document.getElementById("analysisSection"),
            currentChart: !!currentChart,
            currentChartDatasets: currentChart
              ? currentChart.data.datasets.length
              : 0,
            weatherData: !!weatherData,
            currentAggregatedData: !!currentAggregatedData,
            currentAnalysisRange,
            selectedStrategy,
          });

          if (currentChart) {
            console.log(
              "🔧 DEBUG PANEL - Datasets du graphique:",
              currentChart.data.datasets.map((d) => ({
                label: d.label,
                dataLength: d.data.length,
              }))
            );
          }

          // Test d'extraction d'agrégation
          const extracted = extractAggregationFromMainChart();
          console.log(
            "🔧 DEBUG PANEL - Test extraction:",
            !!extracted,
            extracted ? extracted.length : 0
          );

          // Test de mise à jour forcée
          updateAnalysisPanel(weatherData, extracted);
        };

        console.log(
          "🎯 DEBUG PANEL - Tapez debugAnalysisPanel() dans la console pour diagnostiquer"
        );

        // Gestion du tooltip
        const tooltipTrigger = document.querySelector(".tooltip-trigger");
        const tooltipContent = document.querySelector(".tooltip-content");

        if (tooltipTrigger && tooltipContent) {
          tooltipTrigger.addEventListener("mouseenter", () => {
            tooltipContent.style.display = "block";
          });

          tooltipTrigger.addEventListener("mouseleave", () => {
            setTimeout(() => {
              if (!tooltipContent.matches(":hover")) {
                tooltipContent.style.display = "none";
              }
            }, 100);
          });

          tooltipContent.addEventListener("mouseleave", () => {
            tooltipContent.style.display = "none";
          });
        }
      });

      // 🔍 Helper: check if a model should be included for current analysis range
      function isModelAllowed(modelLabel) {
        const disallowedMedium = [
          "MF AROME FRANCE",
          "MF AROME FRANCE HD",
          "KNMI HARMONIE AROME EU",
          "UKMO DETERM 2KM",
        ];
        const allowedLong = [
          "GFS GLOBAL 0.11°/0.25°",
          "GFS GRAPHCAST",
          "ECMWF IFS 0.25°",
          "ICON GLOBAL",
        ];
        if (currentAnalysisRange === "medium") {
          return !disallowedMedium.includes(modelLabel);
        }
        if (currentAnalysisRange === "long") {
          return allowedLong.includes(modelLabel);
        }
        return true; // short or other
      }
    </script>
  </body>
</html>
