<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Setup Dashboard - Ultime M√©t√©o</title>

    <!-- Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      :root {
        --primary: #2563eb;
        --primary-dark: #1d4ed8;
        --secondary: #64748b;
        --accent: #06b6d4;
        --success: #059669;
        --warning: #d97706;
        --danger: #dc2626;
        --background: #f8fafc;
        --surface: #ffffff;
        --border: #e2e8f0;
        --text: #1e293b;
        --text-muted: #64748b;
        --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
        --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1),
          0 4px 6px -4px rgb(0 0 0 / 0.1);
      }

      body {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background-color: var(--background);
        color: var(--text);
        line-height: 1.6;
      }

      .container {
        max-width: 1600px;
        margin: 0 auto;
        padding: 20px;
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
        padding: 20px;
        background: linear-gradient(
          135deg,
          var(--primary) 0%,
          var(--accent) 100%
        );
        border-radius: 16px;
        color: white;
        box-shadow: var(--shadow-lg);
      }

      .header h1 {
        font-size: 2.5rem;
        font-weight: 700;
        margin-bottom: 8px;
      }

      .header p {
        font-size: 1.1rem;
        opacity: 0.9;
      }

      /* City Selector */
      .city-selector {
        background: var(--surface);
        border-radius: 12px;
        padding: 24px;
        margin-bottom: 24px;
        box-shadow: var(--shadow);
        border: 1px solid var(--border);
      }

      .city-selector h2 {
        font-size: 1.5rem;
        margin-bottom: 16px;
        color: var(--text);
      }

      .cities-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 12px;
      }

      .city-btn {
        padding: 12px 16px;
        border: 2px solid var(--border);
        background: var(--surface);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: center;
        font-weight: 500;
        font-size: 0.9rem;
      }

      .city-btn:hover {
        border-color: var(--primary);
        background: var(--primary);
        color: white;
        transform: translateY(-1px);
      }

      .city-btn.active {
        background: var(--primary);
        border-color: var(--primary);
        color: white;
        box-shadow: var(--shadow);
      }

      /* Special styling for Biarritz and Cap-Corse */
      .city-btn[data-city="Biarritz"].active,
      .city-btn[data-city="Cap-Corse"].active {
        font-weight: 700;
      }

      /* Parameters Tabs */
      .parameters-section {
        background: var(--surface);
        border-radius: 12px;
        padding: 24px;
        margin-bottom: 24px;
        box-shadow: var(--shadow);
        border: 1px solid var(--border);
      }

      .tabs-container {
        border-bottom: 1px solid var(--border);
        margin-bottom: 24px;
      }

      .tabs-nav {
        display: flex;
        overflow-x: auto;
        gap: 4px;
      }

      .tab-btn {
        padding: 12px 20px;
        border: none;
        background: transparent;
        border-radius: 8px 8px 0 0;
        cursor: pointer;
        transition: all 0.2s ease;
        font-weight: 500;
        white-space: nowrap;
        color: var(--text-muted);
      }

      .tab-btn:hover {
        background: var(--background);
        color: var(--text);
      }

      .tab-btn.active {
        background: var(--primary);
        color: white;
      }

      .tab-content {
        display: none;
      }

      .tab-content.active {
        display: block;
      }

      /* Layout optimis√© avec cat√©gories √† gauche */
      .models-columns {
        display: flex;
        flex-direction: column;
        gap: 16px;
        margin-bottom: 20px;
      }

      .models-column {
        display: flex;
        align-items: flex-start;
        gap: 16px;
        border: 2px solid var(--border);
        border-radius: 12px;
        padding: 16px;
        background: var(--background);
        min-height: 120px;
      }

      .column-header {
        flex-shrink: 0;
        width: 150px;
        font-weight: 700;
        font-size: 0.9rem;
        padding: 8px;
        border-radius: 8px;
        color: white;
        text-align: center;
        writing-mode: horizontal-tb;
        display: flex;
        align-items: center;
        justify-content: center;
        line-height: 1;
      }

      .models-row {
        flex: 1;
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: flex-start;
      }

      .column-header.short-term {
        background: linear-gradient(135deg, #ff6b6b, #ee5a24);
      }

      .column-header.medium-term {
        background: linear-gradient(135deg, #4834d4, #686de0);
      }

      .column-header.long-term {
        background: linear-gradient(135deg, #00d2d3, #01a3a4);
      }

      .model-card {
        border: 2px solid;
        border-radius: 8px;
        padding: 12px;
        background: var(--surface);
        transition: all 0.2s ease;
        flex: 0 0 280px;
        min-height: 80px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }

      .model-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 12px;
      }

      .model-checkbox {
        width: 18px;
        height: 18px;
        accent-color: var(--primary);
      }

      .model-name {
        font-weight: 600;
        color: var(--text);
        font-size: 0.9rem;
      }

      .time-range {
        display: grid;
        grid-template-columns: 1fr auto 1fr;
        gap: 8px;
        align-items: center;
        margin-top: 8px;
      }

      .time-select {
        padding: 6px;
        border: 1px solid var(--border);
        border-radius: 4px;
        background: var(--surface);
        font-size: 0.8rem;
      }

      /* Quick Action Buttons */
      .quick-actions {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 12px;
        margin: 20px 0;
      }

      .quick-btn {
        padding: 10px 16px;
        border: 2px solid;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        font-size: 0.9rem;
        transition: all 0.2s ease;
        background: var(--surface);
      }

      .quick-btn.reset {
        border-color: var(--success);
        color: var(--success);
      }

      .quick-btn.deselect {
        border-color: var(--danger);
        color: var(--danger);
      }

      .quick-btn.progressive {
        border-color: var(--warning);
        color: var(--warning);
      }

      .quick-btn.premium {
        border-color: #8e44ad;
        color: #8e44ad;
        background: linear-gradient(
          45deg,
          transparent 0%,
          rgba(142, 68, 173, 0.1) 100%
        );
      }

      .quick-btn:hover {
        background-color: currentColor;
        color: white;
        transform: translateY(-1px);
      }

      /* Action Buttons */
      .action-buttons {
        text-align: center;
        margin: 24px 0;
      }

      .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.2s ease;
        font-size: 1rem;
      }

      .btn-primary {
        background: var(--primary);
        color: white;
      }

      .btn-primary:hover {
        background: var(--primary-dark);
        transform: translateY(-1px);
        box-shadow: var(--shadow);
      }

      /* Charts Section */
      .charts-section {
        background: var(--surface);
        border-radius: 12px;
        padding: 24px;
        margin-bottom: 24px;
        box-shadow: var(--shadow);
        border: 1px solid var(--border);
      }

      .chart-container {
        position: relative;
        height: 500px;
        margin-bottom: 20px;
      }

      .zoom-reset-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 1000;
        padding: 8px 16px;
        background: var(--primary);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.875rem;
        font-weight: 600;
        display: none;
        transition: all 0.2s ease;
      }

      .zoom-reset-btn:hover {
        background: var(--primary-dark);
        transform: translateY(-1px);
      }

      .precipitation-mode-btn {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 1000;
        padding: 8px 16px;
        background: var(--warning);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.875rem;
        font-weight: 600;
        display: none;
        transition: all 0.2s ease;
      }

      .precipitation-mode-btn:hover {
        background: #b45309;
        transform: translateY(-1px);
      }

      .wind-direction-mode-btn {
        position: absolute;
        top: 10px;
        left: 120px;
        z-index: 1000;
        padding: 8px 16px;
        background: var(--accent);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.875rem;
        font-weight: 600;
        display: none;
        transition: all 0.2s ease;
      }

      .wind-direction-mode-btn:hover {
        background: #0891b2;
        transform: translateY(-1px);
      }

      /* Fine-Tune Rain Parameters Panel */
      .rain-params-section {
        background: var(--surface);
        border-radius: 12px;
        border: 1px solid var(--border);
        box-shadow: var(--shadow);
        overflow: hidden;
      }

      .rain-params-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 16px 20px;
        background: linear-gradient(135deg, #8b5cf6 0%, #a855f7 100%);
        color: white;
        border-bottom: 1px solid var(--border);
      }

      .rain-params-header h3 {
        margin: 0;
        font-size: 1.2rem;
        font-weight: 600;
      }

      .rain-params-toggle {
        background: rgba(255, 255, 255, 0.2);
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .rain-params-toggle:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: translateY(-1px);
      }

      .rain-params-content {
        padding: 24px;
      }

      .params-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 24px;
        margin-bottom: 24px;
      }

      .param-group {
        background: #f8fafc;
        border-radius: 8px;
        padding: 16px;
        border: 1px solid #e2e8f0;
      }

      .param-group h4 {
        margin: 0 0 16px 0;
        font-size: 1rem;
        font-weight: 600;
        color: var(--primary);
      }

      .param-item {
        margin-bottom: 16px;
      }

      .param-item:last-child {
        margin-bottom: 0;
      }

      .param-item label {
        display: block;
        margin-bottom: 8px;
        font-size: 0.9rem;
        font-weight: 500;
        color: var(--text);
      }

      .param-item input[type="checkbox"] {
        margin-right: 8px;
      }

      .slider-container {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .slider-container input[type="range"] {
        flex: 1;
        height: 6px;
        border-radius: 3px;
        background: #e2e8f0;
        outline: none;
        -webkit-appearance: none;
      }

      .slider-container input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--primary);
        cursor: pointer;
        border: 2px solid white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .slider-container input[type="range"]::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--primary);
        cursor: pointer;
        border: 2px solid white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .slider-value {
        min-width: 60px;
        text-align: right;
        font-size: 0.85rem;
        font-weight: 600;
        color: var(--primary);
        background: white;
        padding: 4px 8px;
        border-radius: 4px;
        border: 1px solid #e2e8f0;
      }

      .param-item select {
        width: 100%;
        padding: 8px 12px;
        border: 1px solid var(--border);
        border-radius: 6px;
        background: white;
        font-size: 0.9rem;
        color: var(--text);
      }

      .custom-weights-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 8px;
        margin-top: 8px;
      }

      .weight-input {
        text-align: center;
      }

      .weight-input label {
        display: block;
        font-size: 0.8rem;
        margin-bottom: 4px;
        color: var(--text-muted);
      }

      .weight-input input {
        width: 100%;
        padding: 4px;
        border: 1px solid var(--border);
        border-radius: 4px;
        text-align: center;
        font-size: 0.8rem;
      }

      .rain-params-actions {
        display: flex;
        gap: 12px;
        padding: 16px 0;
        border-top: 1px solid var(--border);
        margin-top: 16px;
        flex-wrap: wrap;
      }

      .btn-primary {
        background: var(--primary);
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 6px;
        font-size: 0.9rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .btn-primary:hover {
        background: var(--primary-dark);
        transform: translateY(-1px);
      }

      .btn-secondary {
        background: white;
        color: var(--text);
        border: 1px solid var(--border);
        padding: 10px 20px;
        border-radius: 6px;
        font-size: 0.9rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .btn-secondary:hover {
        background: #f8fafc;
        border-color: var(--primary);
        color: var(--primary);
        transform: translateY(-1px);
      }

      .param-visualization {
        background: white;
        border-radius: 8px;
        padding: 16px;
        border: 1px solid var(--border);
        margin-top: 16px;
      }

      .param-visualization h4 {
        margin: 0 0 12px 0;
        font-size: 1rem;
        font-weight: 600;
        color: var(--text);
      }

      .viz-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 12px;
      }

      .stat-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        background: #f8fafc;
        border-radius: 6px;
        border: 1px solid #e2e8f0;
      }

      .stat-label {
        font-size: 0.85rem;
        color: var(--text-muted);
      }

      .stat-value {
        font-size: 0.9rem;
        font-weight: 600;
        color: var(--primary);
      }

      /* Tooltips pour les param√®tres */
      .param-tooltip {
        position: relative;
        display: inline-block;
        margin-left: 8px;
        cursor: help;
      }

      .param-tooltip .tooltip-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--primary);
        color: white;
        font-size: 11px;
        font-weight: bold;
      }

      .param-tooltip .tooltip-content {
        visibility: hidden;
        opacity: 0;
        position: absolute;
        z-index: 1000;
        bottom: 125%;
        left: 50%;
        transform: translateX(-50%);
        background: #333;
        color: white;
        text-align: left;
        padding: 12px;
        border-radius: 8px;
        width: 280px;
        font-size: 0.8rem;
        line-height: 1.4;
        transition: opacity 0.3s ease;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .param-tooltip .tooltip-content::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border: 6px solid transparent;
        border-top-color: #333;
      }

      .param-tooltip:hover .tooltip-content {
        visibility: visible;
        opacity: 1;
      }

      .tooltip-content .tooltip-title {
        font-weight: bold;
        margin-bottom: 6px;
        color: #4ade80;
      }

      .tooltip-content .tooltip-effect {
        margin-bottom: 6px;
        color: #fbbf24;
      }

      .tooltip-content .tooltip-example {
        font-style: italic;
        color: #a3a3a3;
      }

      /* Nouveaux √©l√©ments d'interface */
      .temporal-mode-buttons {
        display: flex;
        gap: 12px;
        margin-top: 8px;
      }

      .radio-label {
        display: flex;
        align-items: center;
        cursor: pointer;
        padding: 6px 12px;
        border: 1px solid var(--border);
        border-radius: 6px;
        background: white;
        transition: all 0.2s ease;
      }

      .radio-label:hover {
        border-color: var(--primary);
        background: #f8fafc;
      }

      .radio-label input[type="radio"] {
        margin-right: 6px;
      }

      .radio-label input[type="radio"]:checked + span {
        color: var(--primary);
        font-weight: 600;
      }

      .weights-display {
        margin-top: 8px;
        padding: 8px 12px;
        background: #f0f9ff;
        border: 1px solid #0ea5e9;
        border-radius: 6px;
        text-align: center;
      }

      .weight-badge {
        font-family: monospace;
        font-size: 0.9rem;
        font-weight: 600;
        color: #0369a1;
      }

      .param-item h5 {
        margin: 0 0 8px 0;
        font-size: 1rem;
        color: var(--primary);
        font-weight: 600;
      }

      .chart-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 16px;
        padding: 16px;
        background: var(--background);
        border-radius: 8px;
      }

      .model-toggle {
        padding: 6px 12px;
        border: 1px solid var(--border);
        background: var(--surface);
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.875rem;
        transition: all 0.2s ease;
      }

      .model-toggle.active {
        font-style: italic;
        border-width: 2px;
      }

      .model-toggle.emphasized {
        font-weight: 700;
        font-style: normal;
        border-width: 3px;
        box-shadow: 0 0 8px currentColor;
      }

      .model-toggle.hidden {
        text-decoration: line-through;
        opacity: 0.4;
        background-color: #f5f5f5;
        color: #999;
      }

      /* Aggregation Section */
      .aggregation-section {
        background: var(--surface);
        border-radius: 12px;
        padding: 24px;
        margin-bottom: 24px;
        box-shadow: var(--shadow);
        border: 1px solid var(--border);
      }

      .strategy-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 16px;
        margin-bottom: 20px;
        max-width: 900px;
        margin-left: auto;
        margin-right: auto;
      }

      .strategy-card {
        border: 2px solid;
        border-radius: 8px;
        padding: 16px;
        background: var(--surface);
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: center;
        min-height: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        font-size: 0.9rem;
      }

      .strategy-card:hover {
        border-color: var(--primary);
        background: var(--surface);
      }

      .strategy-card.active {
        border-color: var(--primary);
        background: var(--primary);
        color: white;
      }

      /* Didactic Mode */
      .didactic-mode {
        margin-top: 20px;
        padding: 20px;
        background: var(--background);
        border-radius: 12px;
        border: 1px solid var(--border);
      }

      .didactic-title {
        font-size: 1.2rem;
        font-weight: 700;
        margin-bottom: 16px;
        color: var(--primary);
      }

      .didactic-content {
        display: none;
      }

      .didactic-content.active {
        display: block;
      }

      .math-formula {
        background: #f8f9fa;
        padding: 12px;
        border-radius: 6px;
        font-family: "Courier New", monospace;
        margin: 8px 0;
        border-left: 4px solid var(--primary);
      }

      .example-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin: 16px 0;
      }

      .example-card {
        background: var(--surface);
        padding: 12px;
        border-radius: 8px;
        border: 1px solid var(--border);
      }

      .example-title {
        font-weight: 600;
        margin-bottom: 8px;
        color: var(--primary);
      }

      .example-values {
        font-family: "Courier New", monospace;
        margin: 4px 0;
      }

      .use-cases {
        margin-top: 12px;
        padding: 12px;
        background: #e3f2fd;
        border-radius: 6px;
      }

      .use-cases-title {
        font-weight: 600;
        margin-bottom: 8px;
        color: #1976d2;
      }

      /* Loading State */
      .loading {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 40px;
        color: var(--text-muted);
      }

      .spinner {
        width: 20px;
        height: 20px;
        border: 2px solid var(--border);
        border-top: 2px solid var(--primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 8px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Responsive */
      @media (max-width: 768px) {
        .container {
          padding: 12px;
        }

        .header h1 {
          font-size: 1.8rem;
        }

        .cities-grid {
          grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        }

        .models-column {
          flex-direction: column;
        }

        .column-header {
          width: 100%;
          margin-bottom: 12px;
        }

        .model-card {
          flex: 1 1 100%;
        }

        .quick-actions {
          flex-direction: column;
          align-items: center;
        }

        .strategy-grid {
          grid-template-columns: 1fr;
          gap: 12px;
        }
      }

      /* Hover tooltip */
      .hover-info {
        position: absolute;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 0.875rem;
        pointer-events: none;
        z-index: 1000;
        white-space: nowrap;
      }

      .analysis-btn {
        background: #f1f5f9 !important;
        color: #374151 !important;
        border: 1px solid #cbd5e1 !important;
        font-size: 12px !important;
      }
      .analysis-btn.active {
        background: #3b82f6 !important;
        border-color: #2563eb !important;
        color: #ffffff !important;
      }
      .analysis-btn:hover {
        background: #e2e8f0 !important;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Header -->
      <header class="header">
        <h1>‚ö° Setup Dashboard M√©t√©o</h1>
        <p>Configuration avanc√©e des mod√®les et strat√©gies d'agr√©gation</p>
      </header>

      <!-- City Selector -->
      <section class="city-selector">
        <h2>üåç S√©lection de la ville</h2>
        <div class="cities-grid" id="citiesGrid">
          <!-- Cities will be populated by JavaScript -->
        </div>
        <div id="selectedCityInfo" style="display: none">
          <span id="cityName" style="display: none"></span><br />

          <span id="cityCoords" style="display: none"></span>
        </div>
      </section>

      <!-- Parameters Tabs -->
      <section class="parameters-section">
        <h2>üìä Configuration des param√®tres</h2>
        <div class="tabs-container">
          <nav class="tabs-nav" id="tabsNav">
            <!-- Tabs will be populated by JavaScript -->
          </nav>
        </div>
        <div id="tabsContent">
          <!-- Tab contents will be populated by JavaScript -->
        </div>

        <!-- Quick Actions -->
        <div class="quick-actions">
          <button class="quick-btn reset" id="resetBtn">
            üîÑ Reset param√®tres
          </button>
          <button class="quick-btn deselect" id="deselectBtn">
            ‚ùå D√©s√©lectionner tout
          </button>
          <button class="quick-btn progressive" id="progressiveBtn">
            üìà Algo progressif
          </button>
          <button class="quick-btn premium" id="premiumBtn">
            üíé Mod√®les Premium
          </button>
        </div>
      </section>

      <!-- Action Button -->
      <div class="action-buttons">
        <button class="btn btn-primary" id="updateGraphic">
          üìà Mettre √† jour le graphique
        </button>
      </div>

      <!-- Charts Section -->
      <section class="charts-section" id="chartsSection" style="display: none">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
          "
        >
          <h2 style="margin: 0">üìà Visualisation des donn√©es</h2>
          <div
            id="chartCityInfo"
            style="font-size: 0.9rem; color: var(--text-muted)"
          >
            <!-- City info will be populated by JavaScript -->
          </div>
        </div>
        <div class="chart-controls" id="chartControls">
          <!-- Model toggles will be populated by JavaScript -->
        </div>
        <div class="chart-container">
          <button class="zoom-reset-btn" id="zoomResetBtn">Reset Zoom</button>
          <button class="precipitation-mode-btn" id="precipitationModeBtn">
            Stacked
          </button>
          <button class="wind-direction-mode-btn" id="windDirectionModeBtn">
            Points
          </button>
          <canvas id="mainChart"></canvas>
        </div>

        <!-- Fine-Tune Rain Parameters Panel -->
        <div
          class="rain-params-section"
          id="rainParamsSection"
          style="display: none; margin-top: 24px"
        >
          <div class="rain-params-header">
            <h3>üéõÔ∏è Fine-Tune Rain Parameters</h3>
            <button class="rain-params-toggle" id="rainParamsToggle">
              ‚ñº Masquer
            </button>
          </div>

          <div class="rain-params-content" id="rainParamsContent">
            <!-- Param√®tres principaux -->
            <div class="params-grid">
              <div class="param-group">
                <h4>üîπ Param√®tres principaux</h4>

                <div class="param-item">
                  <h5>üîπ Pond√©ration par palliers de pr√©cipitation</h5>
                  <p
                    style="font-size: 0.8rem; color: #666; margin-bottom: 12px"
                  >
                    D√©finit l'influence de chaque niveau de pr√©cipitation sur la
                    probabilit√© finale. ‚â•0.4mm = toujours 100%.
                  </p>
                </div>

                <div class="param-item">
                  <label for="weightPallier01"
                    >Pond√©ration 0.1mm
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">
                          Poids des faibles pr√©cipitations
                        </div>
                        <div class="tooltip-effect">
                          Influence des mod√®les pr√©voyant exactement 0.1mm. Plus
                          haut = plus d'impact sur la probabilit√©.
                        </div>
                        <div class="tooltip-example">
                          Ex: 0.3 = mod√©r√©ment pris en compte, 0.8 = fortement
                          pris en compte. Id√©al pour d√©tecter signaux faibles
                          coh√©rents.
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="weightPallier01"
                      min="0.0"
                      max="1.0"
                      step="0.1"
                      value="0.3"
                    />
                    <span class="slider-value" id="weightPallier01Value"
                      >0.3</span
                    >
                  </div>
                </div>

                <div class="param-item">
                  <label for="weightPallier02"
                    >Pond√©ration 0.2mm
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">
                          Poids des pr√©cipitations l√©g√®res
                        </div>
                        <div class="tooltip-effect">
                          Influence des mod√®les pr√©voyant exactement 0.2mm.
                        </div>
                        <div class="tooltip-example">
                          Ex: 0.6 = pris en compte mod√©r√©ment fort. G√©n√©ralement
                          plus √©lev√© que 0.1mm.
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="weightPallier02"
                      min="0.0"
                      max="1.0"
                      step="0.1"
                      value="0.6"
                    />
                    <span class="slider-value" id="weightPallier02Value"
                      >0.6</span
                    >
                  </div>
                </div>

                <div class="param-item">
                  <label for="weightPallier03"
                    >Pond√©ration 0.3mm
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">
                          Poids des pr√©cipitations mod√©r√©es
                        </div>
                        <div class="tooltip-effect">
                          Influence des mod√®les pr√©voyant exactement 0.3mm.
                        </div>
                        <div class="tooltip-example">
                          Ex: 0.8 = fortement pris en compte. Proche du poids
                          maximum (1.0 pour ‚â•0.4mm).
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="weightPallier03"
                      min="0.0"
                      max="1.0"
                      step="0.1"
                      value="0.8"
                    />
                    <span class="slider-value" id="weightPallier03Value"
                      >0.8</span
                    >
                  </div>
                </div>

                <div class="param-item">
                  <label for="sigmaRef"
                    >Variance de r√©f√©rence (œÉ_ref)
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">R√©f√©rence de dispersion</div>
                        <div class="tooltip-effect">
                          D√©finit ce qui est consid√©r√© comme "normal" pour la
                          dispersion des mod√®les. Plus haut = plus tol√©rant.
                        </div>
                        <div class="tooltip-example">
                          Ex: 4.0 = standard, 2.0 = strict (p√©nalise forte
                          dispersion), 8.0 = permissif. Id√©al pour zones
                          orographiques complexes.
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="sigmaRef"
                      min="1.0"
                      max="10.0"
                      step="0.5"
                      value="4.0"
                    />
                    <span class="slider-value" id="sigmaRefValue">4.0</span>
                  </div>
                </div>

                <div class="param-item">
                  <label for="alphaAggressive"
                    >Agressivit√© de l'ajustement (Œ±)
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">Force des corrections</div>
                        <div class="tooltip-effect">
                          Contr√¥le l'intensit√© des ajustements de probabilit√©.
                          Plus bas = courbe plus lisse.
                        </div>
                        <div class="tooltip-example">
                          Ex: 0.1 = corrections douces, 0.3 = corrections
                          agressives. R√©duire si courbe trop "nerveuse".
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="alphaAggressive"
                      min="0.05"
                      max="0.5"
                      step="0.05"
                      value="0.2"
                    />
                    <span class="slider-value" id="alphaAggressiveValue"
                      >0.2</span
                    >
                  </div>
                </div>

                <div class="param-item">
                  <label for="gamma"
                    >Facteur d'agressivit√© variance (Œ≥)
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">
                          Sensibilit√© √† la variance
                        </div>
                        <div class="tooltip-effect">
                          D√©termine l'influence de la dispersion des mod√®les sur
                          les corrections. Plus haut = plus r√©actif.
                        </div>
                        <div class="tooltip-example">
                          Ex: 0.05 = peu d'influence, 0.2 = forte influence.
                          Augmenter en montagne, r√©duire en plaine.
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="gamma"
                      min="0.05"
                      max="0.3"
                      step="0.05"
                      value="0.1"
                    />
                    <span class="slider-value" id="gammaValue">0.1</span>
                  </div>
                </div>
              </div>

              <div class="param-group">
                <h4>üîπ Pond√©ration temporelle</h4>

                <div class="param-item">
                  <label
                    >Mode de pond√©ration temporelle
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">Lissage temporel avanc√©</div>
                        <div class="tooltip-effect">
                          Contr√¥le la r√©partition des poids sur les heures
                          adjacentes avec 2 sliders : centre + concentration.
                        </div>
                        <div class="tooltip-example">
                          Ex: Centre=80%, Concentration=50% ‚Üí [10%, 80%, 10%] en
                          mode 3j. Plus de concentration = plus focalis√© sur H.
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="temporal-mode-buttons">
                    <label class="radio-label">
                      <input
                        type="radio"
                        name="temporalMode"
                        value="none"
                        id="temporalModeNone"
                      />
                      <span>Aucun</span>
                    </label>
                    <label class="radio-label">
                      <input
                        type="radio"
                        name="temporalMode"
                        value="3days"
                        id="temporalMode3days"
                        checked
                      />
                      <span>3 jours</span>
                    </label>
                    <label class="radio-label">
                      <input
                        type="radio"
                        name="temporalMode"
                        value="5days"
                        id="temporalMode5days"
                      />
                      <span>5 jours</span>
                    </label>
                  </div>
                </div>

                <div class="param-item" id="temporalControls">
                  <label for="temporalCenterWeight"
                    >Valeur centrale (H)
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">
                          Poids de l'heure actuelle
                        </div>
                        <div class="tooltip-effect">
                          D√©finit le pourcentage de poids attribu√© √† l'heure
                          centrale H.
                        </div>
                        <div class="tooltip-example">
                          Ex: 80% ‚Üí l'heure H aura 80% du poids total, le reste
                          sera r√©parti sur H¬±1 ou H¬±1¬±2.
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="temporalCenterWeight"
                      min="20"
                      max="95"
                      step="5"
                      value="80"
                    />
                    <span class="slider-value" id="temporalCenterWeightValue"
                      >80%</span
                    >
                  </div>
                </div>

                <div class="param-item" id="temporalConcentrationControl">
                  <label for="temporalConcentration"
                    >Concentration autour de H
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">Focus temporal</div>
                        <div class="tooltip-effect">
                          Plus √©lev√© = poids plus concentr√©s pr√®s de H. Plus bas
                          = poids plus √©tal√©s.
                        </div>
                        <div class="tooltip-example">
                          Ex: 20% ‚Üí poids √©tal√©s [15%,70%,15%], 80% ‚Üí poids
                          concentr√©s [5%,90%,5%].
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="temporalConcentration"
                      min="10"
                      max="90"
                      step="10"
                      value="50"
                    />
                    <span class="slider-value" id="temporalConcentrationValue"
                      >50%</span
                    >
                  </div>
                </div>

                <div class="param-item" id="temporalWeightsDisplay">
                  <label>Pond√©rations calcul√©es :</label>
                  <div class="weights-display" id="weightsDisplay">
                    <span class="weight-badge" id="weightDisplay"
                      >10% - 80% - 10%</span
                    >
                  </div>
                </div>
              </div>

              <div class="param-group">
                <h4>üîπ Gestion des pics isol√©s</h4>

                <div class="param-item">
                  <label>
                    <input type="checkbox" id="detectIsolatedPeaks" checked />
                    Activer d√©tection de pic isol√©
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">
                          D√©tection des orages isol√©s
                        </div>
                        <div class="tooltip-effect">
                          Identifie les pics de pr√©cipitation entour√©s de
                          p√©riodes s√®ches (T > 2√ó(T-1+T+1)).
                        </div>
                        <div class="tooltip-example">
                          Ex: D√©tecte orage de 15h entre 2 p√©riodes sans pluie.
                          Utile pour averses convectives √©t√©.
                        </div>
                      </div>
                    </div>
                  </label>
                </div>

                <div class="param-item">
                  <label for="kFactor"
                    >Renforcement des pics isol√©s (k)
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">Force du boost de pic</div>
                        <div class="tooltip-effect">
                          Intensit√© de renforcement appliqu√©e aux pics isol√©s
                          d√©tect√©s. Plus haut = boost plus fort.
                        </div>
                        <div class="tooltip-example">
                          Ex: 0.2 = boost mod√©r√©, 0.5 = boost fort. Augmenter en
                          √©t√© (orages), r√©duire en hiver.
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="kFactor"
                      min="0.0"
                      max="1.0"
                      step="0.05"
                      value="0.35"
                    />
                    <span class="slider-value" id="kFactorValue">0.35</span>
                  </div>
                </div>

                <div class="param-item">
                  <label for="minWetModels"
                    >Seuil de mod√®les mouillants pour garder un pic
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">Validation de consensus</div>
                        <div class="tooltip-effect">
                          % minimum de mod√®les qui doivent pr√©voir de la pluie
                          pour valider un pic isol√©.
                        </div>
                        <div class="tooltip-example">
                          Ex: 30% = 3 mod√®les sur 10 minimum. Augmenter (50%)
                          pour √™tre plus strict, r√©duire (20%) pour plus de
                          sensibilit√©.
                        </div>
                      </div>
                    </div>
                  </label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="minWetModels"
                      min="0.0"
                      max="1.0"
                      step="0.1"
                      value="0.3"
                    />
                    <span class="slider-value" id="minWetModelsValue">30%</span>
                  </div>
                </div>
              </div>

              <div class="param-group">
                <h4>üîπ Param√®tres avanc√©s</h4>

                <div class="param-item">
                  <label for="boostMalus"
                    >Bonus/malus selon mod√®les mouillants
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">
                          Ajustement par consensus
                        </div>
                        <div class="tooltip-effect">
                          Augmente la probabilit√© si beaucoup de mod√®les
                          d'accord, la r√©duit si peu d'accord.
                        </div>
                        <div class="tooltip-example">
                          Ex: 8 mod√®les sur 10 d'accord = boost +10%, 2 mod√®les
                          sur 10 = malus -10%. Exp√©rimental.
                        </div>
                      </div>
                    </div>
                  </label>
                  <label>
                    <input type="checkbox" id="enableBoostMalus" />
                    Activer
                  </label>
                </div>

                <div class="param-item">
                  <label for="neutralModels"
                    >Seuil de neutralit√© (nb mod√®les)</label
                  >
                  <div class="slider-container">
                    <input
                      type="range"
                      id="neutralModels"
                      min="3"
                      max="10"
                      step="1"
                      value="6"
                    />
                    <span class="slider-value" id="neutralModelsValue">6</span>
                  </div>
                </div>

                <div class="param-item">
                  <label for="boostCoeff">Coefficient de boost/malus</label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="boostCoeff"
                      min="0.01"
                      max="0.05"
                      step="0.005"
                      value="0.02"
                    />
                    <span class="slider-value" id="boostCoeffValue">0.02</span>
                  </div>
                </div>

                <div class="param-item">
                  <label for="probCap"
                    >Cap de proba finale
                    <div class="param-tooltip">
                      <span class="tooltip-icon">?</span>
                      <div class="tooltip-content">
                        <div class="tooltip-title">Limite maximum</div>
                        <div class="tooltip-effect">
                          Limite la probabilit√© maximale que peut atteindre
                          l'algorithme, m√™me avec tous les mod√®les d'accord.
                        </div>
                        <div class="tooltip-example">
                          Ex: 90% √©vite sur-confiance, 100% garde pleine gamme.
                          Utiliser 90% si surestimation fr√©quente.
                        </div>
                      </div>
                    </div>
                  </label>
                  <select id="probCap">
                    <option value="0.9">90%</option>
                    <option value="1.0" selected>100%</option>
                    <option value="unlimited">Illimit√©</option>
                  </select>
                </div>
              </div>
            </div>

            <!-- Boutons d'action -->
            <div class="rain-params-actions">
              <button class="btn-primary" id="applyParams">
                üöÄ Appliquer param√®tres
              </button>
              <button class="btn-secondary" id="resetParams">
                üîÑ Reset d√©faut
              </button>
              <button class="btn-secondary" id="savePreset">
                üíæ Sauver preset
              </button>
              <button class="btn-secondary" id="loadPreset">
                üìÇ Charger preset
              </button>
            </div>

            <!-- Visualisation en temps r√©el -->
            <div class="param-visualization">
              <h4>üìä Visualisation param√®tres</h4>
              <div class="viz-stats">
                <div class="stat-item">
                  <span class="stat-label">Proba moyenne:</span>
                  <span class="stat-value" id="avgProba">--</span>
                </div>
                <div class="stat-item">
                  <span class="stat-label">Pics d√©tect√©s:</span>
                  <span class="stat-value" id="peaksDetected">--</span>
                </div>
                <div class="stat-item">
                  <span class="stat-label">Lissage appliqu√©:</span>
                  <span class="stat-value" id="smoothingApplied">--</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Wind Radar Chart Section -->
        <div
          class="wind-radar-section"
          id="windRadarSection"
          style="display: none"
        >
          <div
            style="
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 16px;
            "
          >
            <h3 style="margin: 0">üå™Ô∏è Rose des vents</h3>
          </div>
          <div
            class="radar-container"
            style="position: relative; height: 600px; margin-bottom: 20px"
          >
            <canvas id="windRadarChart"></canvas>
          </div>
          <div
            class="time-slider-container"
            style="
              padding: 16px;
              background: var(--background);
              border-radius: 8px;
            "
          >
            <label
              for="timeSlider"
              style="font-weight: 600; margin-bottom: 8px; display: block"
            >
              <span id="currentTimeLabel">Heure: 0H</span>
            </label>
            <input
              type="range"
              id="timeSlider"
              min="0"
              max="167"
              value="0"
              style="width: 100%; margin-bottom: 8px"
            />
            <div
              style="
                display: flex;
                justify-content: space-between;
                font-size: 0.8rem;
                color: var(--text-muted);
              "
            >
              <span>0H</span>
              <span>167H</span>
            </div>
          </div>
        </div>
      </section>

      <!-- Analysis Panel Section -->
      <div class="container">
        <section
          class="analysis-section"
          id="analysisSection"
          style="
            display: none;
            background: #ffffff;
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
            margin-bottom: 24px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
          "
        >
          <h2
            style="
              margin: 0 0 16px 0;
              color: #1f2937;
              font-size: 1.4rem;
              font-weight: 600;
              position: relative;
              display: inline-flex;
              align-items: center;
            "
          >
            üéØ Analyse de Corr√©lation des Mod√®les
            <span
              class="tooltip-trigger"
              style="margin-left: 6px; cursor: help; font-size: 16px"
              >‚ÑπÔ∏è</span
            >
            <div
              class="tooltip-content"
              style="
                position: absolute;
                top: 100%;
                left: 0;
                width: 400px;
                background: #1a1a1a;
                border: 1px solid #333;
                border-radius: 8px;
                padding: 16px;
                color: #fff;
                font-size: 14px;
                line-height: 1.4;
                z-index: 1000;
                display: none;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
              "
            >
              <!-- same explanatory content -->
              <strong
                >La proximit√© d'un mod√®le √† la moyenne des autres : un bon
                indicateur de fiabilit√© ?</strong
              ><br /><br />
              ‚úÖ <strong>Oui, mais avec pr√©cautions :</strong><br />
              Un mod√®le proche de la moyenne agr√©g√©e (quelle que soit la
              strat√©gie : m√©diane, pond√©r√©e, gaussienne‚Ä¶) est g√©n√©ralement plus
              "consensuel".<br /><br />

              Cela n'implique pas directement qu'il est "meilleur". Il peut √™tre
              proche de la moyenne par chance ou parce que tous les mod√®les se
              trompent ensemble.<br /><br />

              En m√©t√©o, certains mod√®les "d√©clencheurs" ou tr√®s r√©actifs (ex.
              ICON, AROME) peuvent sortir de la moyenne mais parfois captent une
              r√©alit√© que les autres lissent.<br /><br />

              üîç <strong>Limite :</strong> La moyenne peut elle-m√™me √™tre fausse
              si tous les mod√®les convergent vers une erreur (cas d'un front mal
              positionn√©, etc.).<br /><br />

              üß≠ <strong>Ce que √ßa mesure vraiment :</strong><br />
              Une proximit√© statistique, utile pour :<br />
              ‚Ä¢ Identifier les mod√®les stables<br />
              ‚Ä¢ Mesurer la coh√©rence temporelle<br />
              ‚Ä¢ √âliminer les mod√®les erratiques (grandes oscillations non
              justifi√©es)<br /><br />

              üü¢ Donc oui, utiliser l'√©cart-type moyen par rapport √† la moyenne
              est un bon crit√®re de "confiance relative".<br /><br />

              üìä
              <strong
                >Si un mod√®le domine 72 fois (8 param√®tres √ó 9 villes) : est-ce
                le n¬∞1 ?</strong
              ><br />
              ‚úÖ Oui, tu peux le valoriser fortement :<br />
              Cela montre une coh√©rence globale, multi-param√®tre et
              multi-locale.<br /><br />

              ‚ö†Ô∏è <strong>Mais attention :</strong><br />
              Ce score est corr√©l√© √† ta m√©thode de moyenne.<br />
              Si tu choisis une moyenne gaussienne, tu favorises les mod√®les
              centr√©s, parfois au d√©triment des mod√®les plus extr√™mes mais
              justes.<br />
              Ce mod√®le n'est pas forc√©ment le plus pr√©cis localement : il est
              le plus consensuel.
            </div>
          </h2>

          <!-- Panel d'analyse des gagnants/perdants 
          <div
            class="analysis-panel"
            style="
              padding: 16px;
              background: #f8fafc;
              border-radius: 8px;
              border: 1px solid #e2e8f0;
            "
          >-->
          <div
            style="
              display: flex;
              align-items: center;
              gap: 8px;
              margin-bottom: 16px;
            "
          ></div>

          <div id="analysisResults" style="color: #130535">
            <div style="margin-bottom: 12px; font-size: 14px">
              <strong style="color: #1f2937">Agr√©gation :</strong>
              <span
                id="aggregationName"
                style="color: #059669; font-weight: 500"
                >-</span
              >
              |
              <strong style="color: #1f2937">√âcart-type moyen :</strong>
              <span
                id="aggregationStdDev"
                style="color: #dc2626; font-weight: 500"
                >-</span
              >
            </div>

            <!-- Tableau de comparaison des valeurs -->
            <div
              style="
                background: #f8fafc;
                border-radius: 8px;
                padding: 16px;
                margin-bottom: 16px;
                border: 1px solid #e5e7eb;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
              "
            >
              <h4
                style="
                  margin: 0 0 12px 0;
                  color: #1f2937;
                  font-size: 16px;
                  font-weight: 600;
                "
              >
                üìä Comparaison des 28 valeurs
              </h4>
              <div id="comparisonTable" style="overflow-x: auto">
                <table
                  style="
                    width: 100%;
                    border-collapse: collapse;
                    font-size: 11px;
                    background: #ffffff;
                  "
                >
                  <thead>
                    <tr id="tableHeaders" style="background: #f1f5f9">
                      <th
                        style="
                          padding: 8px;
                          border: 1px solid #e2e8f0;
                          color: #475569;
                          text-align: left;
                          font-weight: 600;
                        "
                      >
                        Mod√®le
                      </th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr id="aggregationRow" style="background: #ecfdf5"></tr>
                    <tr id="winnerRow" style="background: #f0fdf4"></tr>
                    <tr id="loserRow" style="background: #fef2f2"></tr>
                  </tbody>
                </table>
              </div>
            </div>

            <div style="margin-bottom: 16px">
              <strong>Strat√©gie d'analyse :</strong>
              <div
                style="
                  display: flex;
                  gap: 8px;
                  margin-top: 8px;
                  flex-wrap: wrap;
                  justify-content: center;
                "
              >
                <button
                  class="analysis-btn active"
                  data-range="short"
                  style="
                    padding: 6px 12px;
                    background: #666;
                    color: #fff;
                    border: 1px solid #888;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                  "
                >
                  0-48h (Court terme)
                </button>
                <button
                  class="analysis-btn"
                  data-range="medium"
                  style="
                    padding: 6px 12px;
                    background: #333;
                    color: #fff;
                    border: 1px solid #555;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                  "
                >
                  48-96h (Moyen terme)
                </button>
                <button
                  class="analysis-btn"
                  data-range="long"
                  style="
                    padding: 6px 12px;
                    background: #333;
                    color: #fff;
                    border: 1px solid #555;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                  "
                >
                  96-168h (Long terme)
                </button>
                <button
                  class="analysis-btn"
                  data-range="prorated"
                  style="
                    padding: 6px 12px;
                    background: #444;
                    color: #fff;
                    border: 1px solid #666;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                  "
                >
                  Proratis√©
                </button>
                <button
                  class="analysis-btn"
                  data-range="weighted"
                  style="
                    padding: 6px 12px;
                    background: #444;
                    color: #fff;
                    border: 1px solid #666;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                  "
                >
                  Pond√©r√© temporel
                </button>
                <button
                  class="analysis-btn"
                  data-range="composite"
                  style="
                    padding: 6px 12px;
                    background: #444;
                    color: #fff;
                    border: 1px solid #666;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                  "
                >
                  Score mixte
                </button>
              </div>
            </div>

            <div
              id="analysisExplanation"
              style="
                font-size: 13px;
                color: #ccc;
                background: rgba(255, 255, 255, 0.03);
                padding: 12px;
                border-radius: 6px;
                margin-top: 12px;
              "
            >
              Pour utiliser ce panel :<br />
              1Ô∏è‚É£ S√©lectionnez des mod√®les m√©t√©o<br />
              2Ô∏è‚É£ Allez dans "üîß Strat√©gies d'agr√©gation"<br />
              3Ô∏è‚É£ Cliquez "‚ö° Appliquer la strat√©gie"<br />
              4Ô∏è‚É£ L'analyse s'affichera automatiquement ici !
            </div>
            <!-- </div> -->
          </div>
        </section>
      </div>

      <!-- Aggregation Section -->
      <section
        class="aggregation-section"
        id="aggregationSection"
        style="display: none"
      >
        <h2>üîß Strat√©gies d'agr√©gation</h2>
        <div class="strategy-grid" id="strategyGrid">
          <!-- Strategies will be populated by JavaScript -->
        </div>

        <!-- Didactic Mode -->
        <div class="didactic-mode">
          <div class="didactic-title">üìö Mode didactique</div>
          <div id="didacticContent">
            <!-- Content will be populated by JavaScript -->
          </div>
        </div>

        <div class="action-buttons">
          <button class="btn btn-primary" id="applyStrategy">
            ‚ö° Appliquer la strat√©gie
          </button>
        </div>
        <div class="chart-container" style="margin-top: 24px">
          <canvas id="aggregatedChart"></canvas>
        </div>
      </section>
    </div>

    <script>
      // Configuration des villes
      const CITIES = {
        Plomeur: { lat: 47.8322, lng: -4.3486 },
        Surzur: { lat: 47.5669, lng: -2.6219 },
        Biarritz: { lat: 43.4832, lng: -1.5586 },
        Paris: { lat: 48.8566, lng: 2.3522 },
        Colmar: { lat: 48.0793, lng: 7.355 },
        "Cap-Corse": { lat: 42.9667, lng: 9.4167 },
        Annecy: { lat: 45.8992, lng: 6.1289 },
        Brest: { lat: 48.3904, lng: -4.4861 },
        Cherbourg: { lat: 49.6337, lng: -1.6222 },
      };

      // Configuration des param√®tres
      const PARAMETERS = {
        temperature: {
          label: "üå°Ô∏è Temp√©rature",
          unit: "¬∞C",
          apiParams: ["temperature_2m"],
        },
        apparent_temperature: {
          label: "üå°Ô∏è Temp√©rature apparente",
          unit: "¬∞C",
          apiParams: ["apparent_temperature"],
        },
        humidity: {
          label: "üíß Humidit√©",
          unit: "%",
          apiParams: ["relative_humidity_2m"],
        },
        precipitation_probability: {
          label: "‚òî Pr√©cipitation %",
          unit: "%",
          apiParams: ["precipitation_probability"],
        },
        precipitation: {
          label: "üåßÔ∏è Pr√©cipitation mm",
          unit: "mm",
          apiParams: ["precipitation"],
        },
        wind_speed: {
          label: "üí® Force du vent",
          unit: "km/h",
          apiParams: ["wind_speed_10m"],
        },
        wind_gusts: {
          label: "üí® Rafales",
          unit: "km/h",
          apiParams: ["wind_gusts_10m"],
        },
        wind_direction: {
          label: "üß≠ Direction du vent",
          unit: "¬∞",
          apiParams: ["wind_direction_10m"],
        },
      };

      // Configuration des mod√®les par terme
      const MODEL_GROUPS = {
        "short-term": {
          label: "‚ö° Court terme",
          models: [
            "meteofrance_arome_france",
            "meteofrance_arome_france_hd",
            "knmi_harmonie_arome_europe",
            "ukmo_uk_deterministic_2km",
          ],
        },
        "medium-term": {
          label: "üå§Ô∏è Moyen terme",
          models: [
            "meteofrance_arpege_europe",
            "icon_eu",
            "ukmo_global_deterministic_10km",
          ],
        },
        "long-term": {
          label: "üåç Long terme",
          models: [
            "gfs_global",
            "gfs_graphcast025",
            "ecmwf_ifs025",
            "icon_global",
          ],
        },
      };

      // Configuration des mod√®les (base)
      const MODELS_BASE = [
        "icon_eu",
        "icon_global",
        "meteofrance_arome_france",
        "meteofrance_arome_france_hd",
        "meteofrance_arpege_europe",
        "ukmo_global_deterministic_10km",
        "ukmo_uk_deterministic_2km",
        "gfs_graphcast025",
        "gfs_global",
        "ecmwf_ifs025",
        "knmi_harmonie_arome_europe",
      ];

      // Mapping des noms de mod√®les courts
      const MODEL_DISPLAY_NAMES = {
        meteofrance_arome_france: "MF AROME FRANCE",
        meteofrance_arome_france_hd: "MF AROME FRANCE HD",
        knmi_harmonie_arome_europe: "KNMI HARMONIE AROME EU",
        ukmo_uk_deterministic_2km: "UKMO DETERM 2KM",
        meteofrance_arpege_europe: "MF ARPEGE EU",
        icon_eu: "ICON EU",
        ukmo_global_deterministic_10km: "UKMO GLOBAL DETERM 10KM",
        gfs_global: "GFS GLOBAL 0.11¬∞/0.25¬∞",
        gfs_graphcast025: "GFS GRAPHCAST",
        ecmwf_ifs025: "ECMWF IFS 0.25¬∞",
        icon_global: "ICON GLOBAL",
      };

      // Liste r√©ellement utilis√©e ; sera mise √† jour par ville
      let MODELS = [...MODELS_BASE];

      // Couleurs d√©di√©es par mod√®le (contraste √©lev√©)
      const MODEL_COLORS = {
        meteofrance_arome_france: "#3498DB", // AROME FRANCE
        meteofrance_arome_france_hd: "#A3C6FF", // AROME FRANCE HD
        meteofrance_arpege_europe: "#BBDEFB", // ARPEGE EUROPE
        icon_eu: "#FFFF6B", // ICON EU
        icon_global: "#F39C12", // ICON GLOBAL
        ukmo_global_deterministic_10km: "#58D68D", // UKMO GLOBAL 10KM
        ukmo_uk_deterministic_2km: "#A3E4D7", // UKMO UK 2KM
        gfs_graphcast025: "#FF7E79", // GFS GRAPHCAST025 - Rouge corail
        gfs_global: "#FFB3AB", // GFS GLOBAL - Rose clair
        ecmwf_ifs025: "#b17652", // ECMWF IFS025
        knmi_harmonie_arome_europe: "#CE93D8", // KNMI HARMONIE
      };

      function getTextColorForBg(hex) {
        // Calculate luminance to decide black or white text
        hex = hex.replace("#", "");
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
        return luminance > 0.6 ? "#000" : "#fff";
      }

      // Strat√©gies d'agr√©gation avec mode didactique
      const STRATEGIES = {
        mean: {
          label: "Moyenne arithm√©tique",
          color: "#e74c3c",
          description: "Moyenne simple, sensible aux valeurs extr√™mes.",
          formula:
            "(15+16+17)/3 = 16.0 | (10+12+50+13)/4 = 21.25 | (5+6+7+100+8)/5 = 25.2",
          explanation:
            "Tr√®s simple √† calculer mais peu robuste. D√®s qu'une valeur extr√™me est pr√©sente, la moyenne est fortement d√©form√©e.",
          useCases: [
            "Temp√©rature",
            "Humidit√©",
            "Pr√©cipitations mm",
            "Force du vent",
          ],
          examples: {
            values3: [15, 16, 17],
            values4: [10, 12, 50, 13],
            values5: [5, 6, 7, 100, 8],
          },
        },
        median: {
          label: "M√©diane",
          color: "#3498db",
          description:
            "Valeur centrale d'un ensemble tri√©, robuste aux extr√™mes.",
          formula: "16 | (12+13)/2 = 12.5 | 7",
          explanation:
            "Robuste face aux valeurs extr√™mes. Pertinente pour d√©crire une 'valeur typique' dans des distributions asym√©triques.",
          useCases: ["Temp√©rature", "Pr√©cipitations mm", "Rafale de vent"],
          examples: {
            values3: [15, 16, 17],
            values4: [10, 12, 50, 13],
            values5: [5, 6, 7, 100, 8],
          },
        },
        trimmed_mean: {
          label: "Moyenne tronqu√©e",
          color: "#f39c12",
          description: "On enl√®ve les extr√™mes avant de faire la moyenne.",
          formula: "16.0 | (12+13)/2 = 12.5 | (6+7+8)/3 = 7.0",
          explanation:
            "Bonne alternative √† la moyenne classique en pr√©sence d'outliers. N√©cessite un nombre suffisant de donn√©es pour fonctionner.",
          useCases: ["Temp√©rature", "Pr√©cipitations mm", "Rafales de vent"],
          examples: {
            values3: [15, 16, 17],
            values4: [10, 12, 50, 13],
            values5: [5, 6, 7, 100, 8],
          },
        },
        precipitation_algo: {
          label: "Algo Pr√©cipitation",
          color: "#9b59b6",
          description:
            "Algorithme sp√©cialis√© pour les pr√©cipitations avec probabilit√© corrig√©e et pond√©ration gaussienne.",
          formula:
            "P_corrected = P_raw √ó (1 + Œ± √ó (variance_ratio - 1) √ó log(1 + mm_moyenne))",
          explanation:
            "Algorithme avanc√© sp√©cialement con√ßu pour les pr√©cipitations. Calcule une probabilit√© corrig√©e bas√©e sur la variance des mod√®les et applique une pond√©ration gaussienne pour la pluviom√©trie avec traitement des pics isol√©s.",
          useCases: ["Pr√©cipitations %", "Pr√©cipitations mm"],
          examples: {
            values3: [0.1, 2.5, 0.8],
            values4: [0.0, 1.2, 15.0, 0.5],
            values5: [0.2, 0.8, 1.5, 25.0, 0.3],
          },
        },
        winsorized_mean: {
          label: "Winsorized Mean",
          color: "#1abc9c",
          description:
            "Remplace les extr√™mes par les valeurs les plus proches restantes.",
          formula: "16.0 | (10+12+13+13)/4 = 12.0 | (6+6+7+8+8)/5 = 7.0",
          explanation:
            "Utile si l'on souhaite garder toutes les donn√©es sans supprimer mais limiter l'effet des extr√™mes.",
          useCases: [
            "Temp√©rature",
            "Humidit√©",
            "Pr√©cipitations mm",
            "Rafales de vent",
          ],
          examples: {
            values3: [15, 16, 17],
            values4: [10, 12, 50, 13],
            values5: [5, 6, 7, 100, 8],
          },
        },
        gaussian_weighted: {
          label: "Pond√©ration gaussienne",
          color: "#34495e",
          description:
            "On pond√®re les valeurs selon leur proximit√© avec la moyenne.",
          formula: "‚âà 16.0 | ‚âà 13.4 | ‚âà 7.4",
          explanation:
            "M√©thode √©l√©gante et souple pour lisser les effets extr√™mes. Elle r√©duit l'influence des outliers sans les supprimer.",
          useCases: ["Temp√©rature", "Pr√©cipitation mm", "Rafale de vent"],
          examples: {
            values3: [15, 16, 17],
            values4: [10, 12, 50, 13],
            values5: [5, 6, 7, 100, 8],
          },
        },
      };

      // Variables globales
      let selectedCity = null;
      let weatherData = null;
      let weatherDataCache = {}; // Cache des donn√©es par ville
      let currentChart = null;
      let aggregatedChart = null;
      let selectedModels = {};
      let selectedStrategy = "mean";
      let isInitializing = false;
      let precipitationMode = "stacked"; // "stacked" or "behind"
      let windDirectionMode = "points"; // "points" or "lines"
      let windRadarChart = null;
      let currentTimeIndex = 0;
      let windChartType = "radar"; // Always radar now
      let maxWindSpeedInData = 50; // Will be calculated from the full dataset

      // Register Chart.js plugins - simplified version (no time scale)
      Chart.register(
        Chart.LineController,
        Chart.BarController,
        Chart.ScatterController,
        Chart.RadarController,

        Chart.LineElement,
        Chart.BarElement,
        Chart.PointElement,
        Chart.ArcElement,
        Chart.RadialLinearScale,
        Chart.LinearScale,
        Chart.CategoryScale,
        Chart.Title,
        Chart.Tooltip,
        Chart.Legend
      );

      // Register zoom plugin if available
      if (typeof ChartZoom !== "undefined") {
        Chart.register(ChartZoom);
      }

      // Initialisation
      document.addEventListener("DOMContentLoaded", async function () {
        initializeCities();
        initializeTabs();
        initializeStrategies();
        setupEventListeners();
        setupQuickActions();
        initRainParamsEventListeners();
        updateRainParamsUI();

        // Auto-s√©lectionner Plomeur et charger ses donn√©es
        await autoInitializeWithPlomeur();
      });

      function initializeCities() {
        const citiesGrid = document.getElementById("citiesGrid");

        Object.entries(CITIES).forEach(([cityName, coords]) => {
          const cityBtn = document.createElement("button");
          cityBtn.className = "city-btn";
          cityBtn.textContent = cityName;
          cityBtn.dataset.city = cityName;
          cityBtn.addEventListener(
            "click",
            async () => await selectCity(cityName, coords)
          );
          citiesGrid.appendChild(cityBtn);
        });
      }

      async function selectCity(cityName, coords) {
        selectedCity = { name: cityName, ...coords };

        /* Mettre √† jour la liste MODELS selon la ville (exclure UKMO 2 km hors Royaume-Uni) */
        if (["Biarritz", "Cap-Corse"].includes(cityName)) {
          MODELS = MODELS_BASE.filter((m) => m !== "ukmo_uk_deterministic_2km");
        } else {
          MODELS = [...MODELS_BASE];
        }

        // Update UI
        document.querySelectorAll(".city-btn").forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.city === cityName);
        });

        // Update city info in both locations
        const cityInfo = document.getElementById("selectedCityInfo");
        const chartCityInfo = document.getElementById("chartCityInfo");
        document.getElementById("cityName").textContent = cityName;
        document.getElementById(
          "cityCoords"
        ).textContent = `${coords.lat.toFixed(4)}, ${coords.lng.toFixed(4)}`;
        cityInfo.style.display = "block";

        // Update chart city info
        if (chartCityInfo) {
          chartCityInfo.innerHTML = `<strong>Ville s√©lectionn√©e:</strong> ${cityName} <strong>Coordonn√©es:</strong> ${coords.lat.toFixed(
            4
          )}, ${coords.lng.toFixed(4)}¬∞`;
        }

        // Si pas en cours d'initialisation et pas de donn√©es en cache, charger les donn√©es
        if (!isInitializing && !weatherDataCache[cityName]) {
          try {
            showLoading(`Chargement des donn√©es pour ${cityName}...`);
            await loadCityData(cityName);

            // Mettre √† jour le graphique si les donn√©es existent
            if (weatherData) {
              await populateModelSelections();
              updateChartControls();
              createMainChart();
              updateMainChart();

              // Afficher les sections
              document.getElementById("chartsSection").style.display = "block";
              document.getElementById("aggregationSection").style.display =
                "block";
            }
          } catch (error) {
            console.error(
              `Erreur lors du chargement des donn√©es pour ${cityName}:`,
              error
            );
            alert(`Erreur lors du chargement des donn√©es pour ${cityName}`);
          }
        } else if (weatherDataCache[cityName]) {
          // Utiliser les donn√©es du cache
          weatherData = weatherDataCache[cityName];

          if (!isInitializing) {
            await populateModelSelections();
            updateChartControls();
            createMainChart();
            updateMainChart();

            // Afficher les sections
            document.getElementById("chartsSection").style.display = "block";
            document.getElementById("aggregationSection").style.display =
              "block";
          }
        }
      }

      function initializeTabs() {
        const tabsNav = document.getElementById("tabsNav");
        const tabsContent = document.getElementById("tabsContent");

        Object.entries(PARAMETERS).forEach(([paramKey, paramConfig], index) => {
          // Create tab button
          const tabBtn = document.createElement("button");
          tabBtn.className = `tab-btn ${index === 0 ? "active" : ""}`;
          tabBtn.textContent = paramConfig.label;
          tabBtn.dataset.param = paramKey;
          tabBtn.addEventListener("click", () => switchTab(paramKey));
          tabsNav.appendChild(tabBtn);

          // Create tab content with new column layout
          const tabContent = document.createElement("div");
          tabContent.className = `tab-content ${index === 0 ? "active" : ""}`;
          tabContent.id = `tab-${paramKey}`;
          tabContent.innerHTML = createTabContent(paramKey, paramConfig);
          tabsContent.appendChild(tabContent);
        });

        // Initialize selected models
        Object.keys(PARAMETERS).forEach((paramKey) => {
          selectedModels[paramKey] = {};
        });
      }

      function createTabContent(paramKey, paramConfig) {
        return `
          <div class="models-columns" id="models-${paramKey}">
            <div class="loading">
              <div class="spinner"></div>
              Chargement des mod√®les disponibles...
            </div>
          </div>
        `;
      }

      function switchTab(paramKey) {
        // Update tab buttons
        document.querySelectorAll(".tab-btn").forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.param === paramKey);
        });

        // Update tab content
        document.querySelectorAll(".tab-content").forEach((content) => {
          content.classList.toggle("active", content.id === `tab-${paramKey}`);
        });

        // Update strategy didactic content
        updateDidacticContent();

        // Show/hide precipitation mode button
        const precipitationBtn = document.getElementById(
          "precipitationModeBtn"
        );
        if (precipitationBtn) {
          precipitationBtn.style.display =
            paramKey === "precipitation" ? "block" : "none";
        }

        // Show/hide rain parameters panel
        const isRainParam =
          paramKey === "precipitation" ||
          paramKey === "precipitation_probability";
        toggleRainParamsPanel(isRainParam);

        // Show/hide wind direction mode button
        const windDirectionBtn = document.getElementById(
          "windDirectionModeBtn"
        );
        if (windDirectionBtn) {
          windDirectionBtn.style.display =
            paramKey === "wind_direction" ? "block" : "none";
        }

        // Show/hide wind radar section
        const windRadarSection = document.getElementById("windRadarSection");
        if (windRadarSection) {
          const shouldShow =
            paramKey === "wind_speed" || paramKey === "wind_direction";
          windRadarSection.style.display = shouldShow ? "block" : "none";

          if (shouldShow) {
            createWindRadarChart(); // Always recreate to recalculate scale
          }
        }

        // Update chart controls and recreate chart for the new parameter (sans appel API)
        if (
          weatherData &&
          document.getElementById("chartsSection").style.display !== "none"
        ) {
          updateChartControls();
          createMainChart();
          updateMainChart();
        }
      }

      function initializeStrategies() {
        const strategyGrid = document.getElementById("strategyGrid");

        Object.entries(STRATEGIES).forEach(([strategyKey, strategyConfig]) => {
          const strategyCard = document.createElement("div");
          strategyCard.className = `strategy-card ${
            strategyKey === selectedStrategy ? "active" : ""
          }`;
          strategyCard.dataset.strategy = strategyKey;
          strategyCard.style.borderColor = strategyConfig.color;
          strategyCard.style.color = strategyConfig.color;
          strategyCard.textContent = strategyConfig.label;

          if (strategyKey === selectedStrategy) {
            strategyCard.style.backgroundColor = strategyConfig.color;
            strategyCard.style.color = "white";
          }

          strategyCard.addEventListener("click", () =>
            selectStrategy(strategyKey)
          );
          strategyGrid.appendChild(strategyCard);
        });

        // Initialize didactic content
        updateDidacticContent();
      }

      function selectStrategy(strategyKey) {
        selectedStrategy = strategyKey;
        document.querySelectorAll(".strategy-card").forEach((card) => {
          const isActive = card.dataset.strategy === strategyKey;
          const strategyData = STRATEGIES[card.dataset.strategy];

          card.classList.toggle("active", isActive);

          if (isActive) {
            card.style.backgroundColor = strategyData.color;
            card.style.color = "white";
          } else {
            card.style.backgroundColor = "var(--surface)";
            card.style.color = strategyData.color;
          }
        });

        // Update didactic content
        updateDidacticContent();

        // Mettre √† jour la ligne d'agr√©gation sur le graphique principal
        updateAggregateDataset();

        // Update wind radar if visible
        if (windRadarChart) {
          updateWindRadar();
        }

        // üéØ Mettre √† jour le panneau d'analyse automatiquement
        if (weatherData) {
          const aggregatedData = extractAggregationFromMainChart();
          if (aggregatedData) {
            updateAnalysisPanel(weatherData, aggregatedData);
            console.log(
              "üéØ Panel d'analyse mis √† jour suite au changement de strat√©gie"
            );
          }
        }
      }

      function updateDidacticContent() {
        const strategyData = STRATEGIES[selectedStrategy];
        const didacticContent = document.getElementById("didacticContent");

        if (!strategyData) return;

        // Calculate example results
        const examples = strategyData.examples;
        const activeParam =
          document.querySelector(".tab-btn.active")?.dataset.param;
        const isWindDirection = activeParam === "wind_direction";

        // Use circular examples for wind direction
        const exampleValues = isWindDirection
          ? {
              values3: [301, 9],
              values4: [350, 10, 20, 30],
              values5: [340, 350, 10, 20, 30],
            }
          : examples;

        const result3 = applyAggregationStrategy(
          exampleValues.values3,
          selectedStrategy,
          isWindDirection
        );
        const result4 = applyAggregationStrategy(
          exampleValues.values4,
          selectedStrategy,
          isWindDirection
        );
        const result5 = applyAggregationStrategy(
          exampleValues.values5,
          selectedStrategy,
          isWindDirection
        );

        didacticContent.innerHTML = `
          <div class="didactic-content active" style="border-left: 4px solid ${
            strategyData.color
          };">
            <h3 style="color: ${strategyData.color};">${strategyData.label}</h3>
            <p><strong>Description:</strong> ${strategyData.description}</p>

            <div class="math-formula" style="border-left-color: ${
              strategyData.color
            };">
              <strong>R√©sultats:</strong> ${strategyData.formula}
            </div>

            <div class="example-grid">
              <div class="example-card">
                <div class="example-title" style="color: ${
                  strategyData.color
                };">Set 1 (${isWindDirection ? "2" : "3"} valeurs)</div>
                <div class="example-values">Donn√©es: [${exampleValues.values3.join(
                  ", "
                )}]${isWindDirection ? "¬∞" : ""}</div>
                <div class="example-values"><strong>R√©sultat: ${result3.toFixed(
                  2
                )}${isWindDirection ? "¬∞" : ""}</strong></div>
              </div>

              <div class="example-card">
                <div class="example-title" style="color: ${
                  strategyData.color
                };">Set 2 (4 valeurs)</div>
                <div class="example-values">Donn√©es: [${exampleValues.values4.join(
                  ", "
                )}]${isWindDirection ? "¬∞" : ""}</div>
                <div class="example-values"><strong>R√©sultat: ${result4.toFixed(
                  2
                )}${isWindDirection ? "¬∞" : ""}</strong></div>
              </div>

              <div class="example-card">
                <div class="example-title" style="color: ${
                  strategyData.color
                };">Set 3 (5 valeurs)</div>
                <div class="example-values">Donn√©es: [${exampleValues.values5.join(
                  ", "
                )}]${isWindDirection ? "¬∞" : ""}</div>
                <div class="example-values"><strong>R√©sultat: ${result5.toFixed(
                  2
                )}${isWindDirection ? "¬∞" : ""}</strong></div>
              </div>
            </div>

            <div class="use-cases">
              <div class="use-cases-title" style="color: ${
                strategyData.color
              };">üìã Param√®tres pertinents:</div>
              <ul>
                ${strategyData.useCases
                  .map((useCase) => `<li>${useCase}</li>`)
                  .join("")}
              </ul>
            </div>

            <div class="use-cases" style="margin-top: 16px; background: ${
              strategyData.color
            }20; border: 1px solid ${strategyData.color};">
              <div class="use-cases-title" style="color: ${
                strategyData.color
              };">üéØ Conclusion:</div>
              <p style="margin: 8px 0; font-style: italic;">
                ${strategyData.explanation}
              </p>
              ${
                isWindDirection
                  ? `
                <div style="margin-top: 12px; padding: 8px; background: rgba(255, 193, 7, 0.2); border-radius: 4px; border-left: 4px solid #ffc107;">
                  <strong>üîÅ M√©thode circulaire adapt√©e:</strong> Les valeurs de direction du vent (0-360¬∞) sont trait√©es avec des m√©thodes circulaires.
                  La moyenne de 350¬∞ et 10¬∞ donne bien 0¬∞ (et non 180¬∞).
                </div>
              `
                  : ""
              }
            </div>
          </div>
        `;
      }

      function setupQuickActions() {
        document
          .getElementById("resetBtn")
          .addEventListener("click", resetParameters);
        document
          .getElementById("deselectBtn")
          .addEventListener("click", deselectAll);
        document
          .getElementById("progressiveBtn")
          .addEventListener("click", setProgressiveAlgo);
        document
          .getElementById("premiumBtn")
          .addEventListener("click", setPremiumModels);
      }

      function resetParameters() {
        // S√©lectionner tous les mod√®les avec toutes les √©ch√©ances
        selectAllModelsWithFullRange();
        syncInterfaceWithSelections();
        updateChartControls();
        if (currentChart) updateMainChart();
      }

      function deselectAll() {
        // D√©s√©lectionner tous les mod√®les
        Object.keys(PARAMETERS).forEach((paramKey) => {
          selectedModels[paramKey] = {};
        });
        syncInterfaceWithSelections();
        updateChartControls();
        if (currentChart) updateMainChart();
      }

      function setProgressiveAlgo() {
        // Configuration selon l'image 2 (algorithme progressif)
        const progressiveConfig = {
          meteofrance_arome_france: { start: 0, end: 60 },
          icon_eu: { start: 48, end: 134 },
          icon_global: { start: 96, end: 167 },
          meteofrance_arome_france_hd: { start: 0, end: 60 },
          meteofrance_arpege_europe: { start: 48, end: 116 },
          ukmo_global_deterministic_10km: { start: 48, end: 110 },
          ukmo_uk_deterministic_2km: { start: 0, end: 60 },
          gfs_graphcast025: { start: 96, end: 167 },
          gfs_global: { start: 96, end: 167 },
          ecmwf_ifs025: { start: 96, end: 167 },
          knmi_harmonie_arome_europe: { start: 0, end: 60 },
        };

        Object.keys(PARAMETERS).forEach((paramKey) => {
          selectedModels[paramKey] = {};
          Object.entries(progressiveConfig).forEach(([model, range]) => {
            if (
              MODELS.includes(model) &&
              checkModelHasData(model, PARAMETERS[paramKey].apiParams[0])
            ) {
              selectedModels[paramKey][model] = range;
            }
          });
        });

        syncInterfaceWithSelections();
        updateChartControls();
        if (currentChart) updateMainChart();
      }

      function setPremiumModels() {
        // Configuration Mod√®les Premium selon l'image 1
        const premiumConfig = {
          meteofrance_arome_france_hd: { start: 0, end: 60 },
          icon_eu: { start: 0, end: 134 },
          ukmo_global_deterministic_10km: { start: 0, end: 110 },
          gfs_graphcast025: { start: 0, end: 167 },
          ecmwf_ifs025: { start: 0, end: 167 },
          knmi_harmonie_arome_europe: { start: 0, end: 60 },
        };

        Object.keys(PARAMETERS).forEach((paramKey) => {
          selectedModels[paramKey] = {};
          Object.entries(premiumConfig).forEach(([model, range]) => {
            if (
              MODELS.includes(model) &&
              checkModelHasData(model, PARAMETERS[paramKey].apiParams[0])
            ) {
              selectedModels[paramKey][model] = range;
            }
          });
        });

        syncInterfaceWithSelections();
        updateChartControls();
        if (currentChart) updateMainChart();
      }

      function setupEventListeners() {
        document
          .getElementById("updateGraphic")
          .addEventListener("click", updateGraphic);
        document
          .getElementById("applyStrategy")
          .addEventListener("click", applyStrategy);
        document
          .getElementById("zoomResetBtn")
          .addEventListener("click", resetZoom);
        document
          .getElementById("precipitationModeBtn")
          .addEventListener("click", togglePrecipitationMode);
        document
          .getElementById("windDirectionModeBtn")
          .addEventListener("click", toggleWindDirectionMode);
        document
          .getElementById("timeSlider")
          .addEventListener("input", updateWindRadar);
      }

      function resetZoom() {
        if (currentChart) {
          currentChart.resetZoom();
          const zoomBtn = document.getElementById("zoomResetBtn");
          if (zoomBtn) {
            zoomBtn.style.display = "none";
          }
        }
      }

      function togglePrecipitationMode() {
        precipitationMode =
          precipitationMode === "stacked" ? "behind" : "stacked";
        const btn = document.getElementById("precipitationModeBtn");
        if (btn) {
          btn.textContent =
            precipitationMode === "stacked" ? "Stacked" : "Behind";
        }

        // Recreate chart with new mode
        const activeParam =
          document.querySelector(".tab-btn.active")?.dataset.param;
        if (activeParam === "precipitation") {
          createMainChart();
          updateMainChart();
        }
      }

      function toggleWindDirectionMode() {
        windDirectionMode = windDirectionMode === "points" ? "lines" : "points";
        const btn = document.getElementById("windDirectionModeBtn");
        if (btn) {
          btn.textContent =
            windDirectionMode === "points" ? "Points" : "Lignes";
        }

        // Recreate chart with new mode
        const activeParam =
          document.querySelector(".tab-btn.active")?.dataset.param;
        if (activeParam === "wind_direction") {
          createMainChart();
          updateMainChart();
        }
      }

      async function autoInitializeWithPlomeur() {
        try {
          console.log("üöÄ D√©but de l'initialisation automatique avec Plomeur");
          isInitializing = true;

          // S√©lectionner automatiquement Plomeur
          const plomeurCoords = CITIES["Plomeur"];
          await selectCity("Plomeur", plomeurCoords);

          // Charger les donn√©es pour Plomeur
          console.log("üì° Chargement des donn√©es pour Plomeur...");
          showLoading("Chargement initial des donn√©es pour Plomeur...");
          await loadCityData("Plomeur");
          console.log(
            "‚úÖ Donn√©es charg√©es pour Plomeur:",
            weatherData ? "OK" : "ERREUR"
          );

          // Initialiser tous les mod√®les pour tous les param√®tres
          console.log("üîß Population des s√©lections de mod√®les...");
          await populateModelSelections();

          // S√©lectionner TOUS les mod√®les avec TOUTES les √©ch√©ances
          console.log(
            "üìã S√©lection de tous les mod√®les avec √©ch√©ances maximales..."
          );
          selectAllModelsWithFullRange();

          // Synchroniser l'interface avec les s√©lections
          console.log("üîÑ Synchronisation de l'interface...");
          syncInterfaceWithSelections();

          isInitializing = false;

          // Cr√©er le graphique automatiquement
          console.log("üìä Cr√©ation du graphique...");
          updateChartControls();
          createMainChart();
          updateMainChart();

          // Afficher les sections
          document.getElementById("chartsSection").style.display = "block";
          document.getElementById("aggregationSection").style.display = "block";

          // Show/hide precipitation mode button
          const precipitationBtn = document.getElementById(
            "precipitationModeBtn"
          );
          if (precipitationBtn) {
            const activeParam =
              document.querySelector(".tab-btn.active")?.dataset.param;
            precipitationBtn.style.display =
              activeParam === "precipitation" ? "block" : "none";
          }

          console.log("‚ú® Initialisation automatique termin√©e pour Plomeur");
        } catch (error) {
          console.error(
            "‚ùå Erreur lors de l'initialisation automatique:",
            error
          );
          isInitializing = false;
        }
      }

      async function loadCityData(cityName) {
        if (!selectedCity) {
          throw new Error("Aucune ville s√©lectionn√©e");
        }

        // V√©rifier si les donn√©es sont d√©j√† en cache
        if (weatherDataCache[cityName]) {
          weatherData = weatherDataCache[cityName];
          console.log(`Donn√©es r√©cup√©r√©es du cache pour ${cityName}`);
          return weatherData;
        }

        // Charger les donn√©es depuis l'API
        weatherData = await fetchWeatherData();

        // Stocker dans le cache
        weatherDataCache[cityName] = weatherData;
        console.log(`Donn√©es mises en cache pour ${cityName}`);

        return weatherData;
      }

      function selectAllModelsWithFullRange() {
        console.log("üéØ D√©but de selectAllModelsWithFullRange");

        Object.keys(PARAMETERS).forEach((paramKey) => {
          console.log(`üîß Configuration pour param√®tre: ${paramKey}`);
          selectedModels[paramKey] = {};

          MODELS.forEach((model) => {
            const hasData = checkModelHasData(
              model,
              PARAMETERS[paramKey].apiParams[0]
            );
            if (hasData) {
              const timeRange = getModelTimeRange(
                model,
                PARAMETERS[paramKey].apiParams[0]
              );
              selectedModels[paramKey][model] = {
                start: 0,
                end: timeRange.end,
              };
              console.log(
                `‚úÖ ${model} configur√© pour ${paramKey}: 0H - ${timeRange.end}H`
              );
            } else {
              console.log(`‚ùå ${model} pas de donn√©es pour ${paramKey}`);
            }
          });

          console.log(
            `üìä ${paramKey} - mod√®les configur√©s:`,
            Object.keys(selectedModels[paramKey])
          );
        });

        console.log(
          "‚úÖ Tous les mod√®les s√©lectionn√©s avec √©ch√©ances compl√®tes"
        );
        console.log("üìã √âtat final de selectedModels:", selectedModels);
      }

      async function updateGraphic() {
        console.log("üîÑ updateGraphic - D√©but");
        if (!selectedCity) {
          alert("Veuillez s√©lectionner une ville");
          return;
        }

        try {
          console.log("üì° Chargement des donn√©es pour:", selectedCity.name);
          showLoading("Mise √† jour du graphique...");

          // Charger les donn√©es si n√©cessaire
          await loadCityData(selectedCity.name);

          // NE PAS repopuler les s√©lections, garder les choix de l'utilisateur
          console.log(
            "üìä √âtat actuel des mod√®les s√©lectionn√©s:",
            selectedModels
          );

          // Update chart controls after model selection
          updateChartControls();

          createMainChart();

          // Ensure chart controls are in sync with initial chart state
          updateMainChart();

          document.getElementById("chartsSection").style.display = "block";
          document.getElementById("aggregationSection").style.display = "block";

          // Show/hide precipitation mode button
          const precipitationBtn = document.getElementById(
            "precipitationModeBtn"
          );
          const windDirectionBtn = document.getElementById(
            "windDirectionModeBtn"
          );
          if (precipitationBtn || windDirectionBtn) {
            const activeParam =
              document.querySelector(".tab-btn.active")?.dataset.param;
            if (precipitationBtn) {
              precipitationBtn.style.display =
                activeParam === "precipitation" ? "block" : "none";
            }
            if (windDirectionBtn) {
              windDirectionBtn.style.display =
                activeParam === "wind_direction" ? "block" : "none";
            }

            // Show/hide wind radar section
            const windRadarSection =
              document.getElementById("windRadarSection");
            if (windRadarSection) {
              const shouldShow =
                activeParam === "wind_speed" ||
                activeParam === "wind_direction";
              windRadarSection.style.display = shouldShow ? "block" : "none";

              if (shouldShow) {
                createWindRadarChart(); // Always recreate to recalculate scale
              }
            }
          }

          console.log("‚úÖ updateGraphic termin√© avec succ√®s");
        } catch (error) {
          console.error(
            "‚ùå Erreur lors de la r√©cup√©ration des donn√©es:",
            error
          );
          alert("Erreur lors de la r√©cup√©ration des donn√©es m√©t√©o");
        }
      }

      async function fetchWeatherData() {
        const hourlyParams = [];
        Object.values(PARAMETERS).forEach((param) => {
          hourlyParams.push(...param.apiParams);
        });

        // Utiliser la liste MODELS (potentiellement filtr√©e) pour la requ√™te
        const modelsForApi = [...MODELS];

        const url = new URL("https://api.open-meteo.com/v1/forecast");
        url.searchParams.set("latitude", selectedCity.lat);
        url.searchParams.set("longitude", selectedCity.lng);
        url.searchParams.set("timezone", "Europe/Berlin");
        url.searchParams.set("models", modelsForApi.join(","));
        url.searchParams.set("hourly", hourlyParams.join(","));

        const response = await fetch(url);
        if (!response.ok) {
          // üîÑ Fallback : r√©essayer sans param√®tre "models" ou avec un sous-ensemble support√©
          console.warn("üåê API Open-Meteo a renvoy√©", response.status);
          // Liste blanche basique de mod√®les connus support√©s par Open-Meteo
          const SUPPORTED_MODELS = [
            "gfs_global",
            "icon_global",
            "icon_eu",
            "ecmwf_ifs025",
            "meteofrance_arome_france",
            "meteofrance_arpege_europe",
          ];

          const filtered = modelsForApi.filter((m) =>
            SUPPORTED_MODELS.includes(m)
          );
          console.log("üîç Mod√®les filtr√©s pour fallback:", filtered);

          const fallbackUrl = new URL(url);
          if (filtered.length > 0) {
            fallbackUrl.searchParams.set("models", filtered.join(","));
          } else {
            fallbackUrl.searchParams.delete("models");
          }
          const retry = await fetch(fallbackUrl);
          if (!retry.ok) {
            throw new Error(`HTTP error after retry! status: ${retry.status}`);
          }
          return await retry.json();
        }

        return await response.json();
      }

      function showLoading(message) {
        console.log(message);

        // Optionnel : afficher un indicateur visuel
        const button = document.getElementById("updateGraphic");
        if (button) {
          button.textContent = "‚è≥ " + message;
          button.disabled = true;

          // Remettre le texte original apr√®s 3 secondes
          setTimeout(() => {
            button.textContent = "üìà Mettre √† jour le graphique";
            button.disabled = false;
          }, 3000);
        }
      }

      async function populateModelSelections() {
        console.log(
          "üîß D√©but de populateModelSelections, isInitializing:",
          isInitializing
        );

        Object.entries(PARAMETERS).forEach(([paramKey, paramConfig]) => {
          console.log(`üìã Processing parameter: ${paramKey}`);
          const container = document.getElementById(`models-${paramKey}`);
          container.innerHTML = "";

          // Create the 3-row layout
          const rowsHtml = Object.entries(MODEL_GROUPS)
            .map(([groupKey, groupConfig]) => {
              return `
              <div class="models-column">
                <div class="column-header ${groupKey}">${groupConfig.label}</div>
                <div class="models-row" id="${paramKey}-${groupKey}-models"></div>
              </div>
            `;
            })
            .join("");

          container.innerHTML = `<div class="models-columns">${rowsHtml}</div>`;

          // Populate each row
          Object.entries(MODEL_GROUPS).forEach(([groupKey, groupConfig]) => {
            const rowContainer = document.getElementById(
              `${paramKey}-${groupKey}-models`
            );

            groupConfig.models.forEach((model) => {
              if (!MODELS.includes(model)) return; // Skip if model not available for this city

              const hasData = checkModelHasData(
                model,
                paramConfig.apiParams[0]
              );
              if (!hasData) return;

              const timeRange = getModelTimeRange(
                model,
                paramConfig.apiParams[0]
              );
              const modelCard = createModelCard(
                model,
                paramKey,
                timeRange,
                true,
                groupKey
              );
              rowContainer.appendChild(modelCard);
            });
          });
        });

        console.log("‚úÖ populateModelSelections termin√©e");
      }

      function syncInterfaceWithSelections() {
        console.log("üîÑ syncInterfaceWithSelections - D√©but");

        Object.entries(selectedModels).forEach(([paramKey, models]) => {
          console.log(
            `üîß Synchronisation pour ${paramKey}:`,
            Object.keys(models)
          );

          // D√©cocher toutes les checkboxes d'abord
          document
            .querySelectorAll(`input[data-param="${paramKey}"]`)
            .forEach((checkbox) => {
              checkbox.checked = false;
            });

          Object.entries(models).forEach(([model, range]) => {
            console.log(
              `üîÑ Synchronisation ${model}: ${range.start}H-${range.end}H`
            );

            // Trouver la checkbox correspondante
            const checkbox = document.querySelector(`#${model}-${paramKey}`);
            if (checkbox) {
              checkbox.checked = true;
              console.log(`‚úÖ Checkbox coch√©e pour ${model}-${paramKey}`);
            } else {
              console.log(`‚ùå Checkbox non trouv√©e pour ${model}-${paramKey}`);
            }

            // Trouver les selects correspondants
            const card = checkbox?.closest(".model-card");
            if (card) {
              const startSelect = card.querySelector('[data-type="start"]');
              const endSelect = card.querySelector('[data-type="end"]');

              if (startSelect) {
                startSelect.value = range.start;
                console.log(
                  `üìÖ Start select mis √† ${range.start}H pour ${model}`
                );
              }

              if (endSelect) {
                endSelect.value = range.end;
                console.log(`üìÖ End select mis √† ${range.end}H pour ${model}`);
              }
            }
          });
        });

        console.log("‚úÖ syncInterfaceWithSelections termin√©e");
      }

      function checkModelHasData(model, parameter) {
        const fullParamName = `${parameter}_${model}`;
        const data = weatherData.hourly[fullParamName];

        if (!data) return false;

        // Check if all values are null
        return data.some((value) => value !== null && value !== undefined);
      }

      function getModelTimeRange(model, parameter) {
        const fullParamName = `${parameter}_${model}`;
        const data = weatherData.hourly[fullParamName];

        if (!data) return { start: 0, end: 0 };

        let lastValidIndex = -1;
        for (let i = data.length - 1; i >= 0; i--) {
          if (data[i] !== null && data[i] !== undefined) {
            lastValidIndex = i;
            break;
          }
        }

        // Convertir en heures depuis le d√©but
        const maxHours = lastValidIndex > 0 ? lastValidIndex : 0;
        return { start: 0, end: maxHours };
      }

      function createModelCard(
        model,
        paramKey,
        timeRange,
        preSelect = false,
        groupKey = ""
      ) {
        const card = document.createElement("div");
        card.className = "model-card";

        // Apply model color to border
        const modelColor = MODEL_COLORS[model] || "#999";
        card.style.borderColor = modelColor;

        const modelDisplayName =
          MODEL_DISPLAY_NAMES[model] || model.replace(/_/g, " ").toUpperCase();

        card.innerHTML = `
                <div class="model-header">
                    <input type="checkbox" class="model-checkbox"
                           id="${model}-${paramKey}"
                           data-model="${model}"
                           data-param="${paramKey}"
                           ${preSelect ? "checked" : ""}>
                    <label for="${model}-${paramKey}" class="model-name" style="color: ${modelColor};">${modelDisplayName}</label>
                </div>
                <div class="time-range">
                    <select class="time-select" data-type="start">
                        ${generateTimeOptions(0, timeRange.end, 0)}
                    </select>
                    <span>√†</span>
                    <select class="time-select" data-type="end">
                        ${generateTimeOptions(
                          0,
                          timeRange.end,
                          timeRange.end // Toujours s√©lectionner l'√©ch√©ance maximale
                        )}
                    </select>
                </div>
            `;

        // Setup event listeners
        const checkbox = card.querySelector(".model-checkbox");
        const startSelect = card.querySelector('[data-type="start"]');
        const endSelect = card.querySelector('[data-type="end"]');

        // If pre-selected, initialize the model selection
        if (preSelect) {
          updateModelSelection(
            model,
            paramKey,
            true,
            startSelect.value,
            endSelect.value
          );
        }

        checkbox.addEventListener("change", () => {
          updateModelSelection(
            model,
            paramKey,
            checkbox.checked,
            startSelect.value,
            endSelect.value
          );
          // Mettre √† jour imm√©diatement le graphique si visible
          if (
            document.getElementById("chartsSection").style.display !== "none"
          ) {
            updateChartControls();
            updateMainChart();
          }
        });

        startSelect.addEventListener("change", () => {
          if (checkbox.checked) {
            updateModelSelection(
              model,
              paramKey,
              true,
              startSelect.value,
              endSelect.value
            );
            // Mettre √† jour imm√©diatement le graphique si visible
            if (
              document.getElementById("chartsSection").style.display !== "none"
            ) {
              updateChartControls();
              updateMainChart();
            }
          }
        });

        endSelect.addEventListener("change", () => {
          if (checkbox.checked) {
            updateModelSelection(
              model,
              paramKey,
              true,
              startSelect.value,
              endSelect.value
            );
            // Mettre √† jour imm√©diatement le graphique si visible
            if (
              document.getElementById("chartsSection").style.display !== "none"
            ) {
              updateChartControls();
              updateMainChart();
            }
          }
        });

        return card;
      }

      function generateTimeOptions(min, max, selected = min) {
        console.log(
          `‚è∞ generateTimeOptions: min=${min}, max=${max}, selected=${selected}`
        );
        let options = "";

        // G√©n√©rer les √©ch√©ances : 0H, 24H, 36H, 48H, 60H, 96H, puis de 24 en 24H jusqu'√† 240H
        const timeSteps = [0, 24, 36, 48, 60, 96];

        // Ajouter les √©ch√©ances de 24 en 24H apr√®s 96H
        for (let h = 120; h <= 240; h += 24) {
          timeSteps.push(h);
        }

        // Ajouter aussi la valeur max si elle n'est pas dans les timeSteps
        if (!timeSteps.includes(max) && max > 0) {
          timeSteps.push(max);
          timeSteps.sort((a, b) => a - b);
        }

        console.log(
          `‚è∞ √âch√©ances disponibles: ${timeSteps.filter(
            (h) => h >= min && h <= max
          )}`
        );

        timeSteps.forEach((hours) => {
          if (hours >= min && hours <= max) {
            // Chang√© < en <= pour inclure max
            const isSelected = hours === selected ? "selected" : "";
            options += `<option value="${hours}" ${isSelected}>${hours}H</option>`;
          }
        });

        console.log(
          `‚è∞ Options g√©n√©r√©es: ${
            options.split("</option>").length - 1
          } options`
        );
        return options;
      }

      function updateModelSelection(
        model,
        paramKey,
        enabled,
        startHours,
        endHours
      ) {
        console.log(
          `üîÑ updateModelSelection: ${model}, ${paramKey}, enabled:${enabled}, ${startHours}H-${endHours}H`
        );

        if (!selectedModels[paramKey]) {
          selectedModels[paramKey] = {};
        }

        if (enabled) {
          selectedModels[paramKey][model] = {
            start: parseInt(startHours),
            end: parseInt(endHours),
          };
          console.log(
            `‚úÖ Mod√®le ${model} activ√© pour ${paramKey}:`,
            selectedModels[paramKey][model]
          );
        } else {
          delete selectedModels[paramKey][model];
          console.log(`‚ùå Mod√®le ${model} d√©sactiv√© pour ${paramKey}`);
        }

        console.log(
          `üìä Mod√®les s√©lectionn√©s pour ${paramKey}:`,
          Object.keys(selectedModels[paramKey] || {})
        );

        // Only update controls if we're on the current active parameter
        const activeParam =
          document.querySelector(".tab-btn.active")?.dataset.param;
        if (activeParam === paramKey) {
          console.log(
            `üéØ Mise √† jour des contr√¥les pour param√®tre actif: ${activeParam}`
          );
          updateChartControls();
        }
      }

      function updateChartControls() {
        console.log("üéÆ updateChartControls - D√©but");
        const controls = document.getElementById("chartControls");
        controls.innerHTML = "";

        // Get current active parameter
        const activeParam =
          document.querySelector(".tab-btn.active")?.dataset.param;
        console.log(`üéØ Param√®tre actif: ${activeParam}`);

        if (!activeParam) {
          console.log("‚ùå Aucun param√®tre actif trouv√©");
          return;
        }

        const models = selectedModels[activeParam] || {};
        console.log(`üîç Mod√®les pour ${activeParam}:`, Object.keys(models));

        // Add aggregation control button first
        const aggregationToggle = document.createElement("button");
        aggregationToggle.className = "model-toggle active";
        aggregationToggle.textContent = "AGR√âGATION";
        aggregationToggle.style.backgroundColor = "#000000";
        aggregationToggle.style.borderColor = "#000000";
        aggregationToggle.style.color = "#ffffff";
        aggregationToggle.dataset.model = "aggregation";

        aggregationToggle.addEventListener("click", () => {
          if (aggregationToggle.classList.contains("active")) {
            if (aggregationToggle.classList.contains("emphasized")) {
              // If emphasized, hide it
              aggregationToggle.classList.remove("active");
              aggregationToggle.classList.remove("emphasized");
              aggregationToggle.classList.add("hidden");
            } else {
              // If normal active, go to emphasized
              aggregationToggle.classList.add("emphasized");
            }
          } else {
            // If inactive, activate it
            aggregationToggle.classList.add("active");
            aggregationToggle.classList.remove("emphasized");
            aggregationToggle.classList.remove("hidden");
          }
          updateMainChart();
        });

        controls.appendChild(aggregationToggle);

        Object.keys(models).forEach((model, index) => {
          console.log(`üîò Cr√©ation du contr√¥le pour: ${model}`);
          const toggle = document.createElement("button");
          toggle.className = "model-toggle active";
          toggle.textContent =
            MODEL_DISPLAY_NAMES[model] ||
            model.replace(/_/g, " ").toUpperCase();

          // Appliquer la couleur d√©di√©e
          const bgColor = MODEL_COLORS[model] || "#999";
          toggle.style.backgroundColor = bgColor;
          toggle.style.borderColor = bgColor;
          toggle.style.color = getTextColorForBg(bgColor);
          toggle.dataset.model = model;

          toggle.addEventListener("click", () => {
            console.log(`üñ±Ô∏è Clic sur contr√¥le: ${model}`);
            if (toggle.classList.contains("active")) {
              if (toggle.classList.contains("emphasized")) {
                // If emphasized, hide it
                toggle.classList.remove("active");
                toggle.classList.remove("emphasized");
                toggle.classList.add("hidden");
                console.log(`üëÅÔ∏è ${model} masqu√©`);
              } else {
                // If normal active, go to emphasized
                toggle.classList.add("emphasized");
                console.log(`‚≠ê ${model} mis en √©vidence`);
              }
            } else {
              // If inactive, activate it
              toggle.classList.add("active");
              toggle.classList.remove("emphasized");
              toggle.classList.remove("hidden");
              console.log(`‚úÖ ${model} activ√©`);
            }
            updateMainChart();
          });

          controls.appendChild(toggle);
        });

        console.log(`‚úÖ ${Object.keys(models).length} contr√¥les cr√©√©s`);
      }

      function createMainChart() {
        console.log("üìä createMainChart - D√©but");
        try {
          const canvas = document.getElementById("mainChart");
          if (!canvas) {
            throw new Error("Canvas mainChart non trouv√©");
          }

          // Destroy existing chart properly
          if (currentChart) {
            console.log("üóëÔ∏è Destruction de l'ancien graphique");
            currentChart.destroy();
            currentChart = null;
          }

          // Clear canvas context
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const activeParam =
            document.querySelector(".tab-btn.active")?.dataset.param;

          console.log(`üéØ Param√®tre actif pour cr√©ation: ${activeParam}`);

          if (!activeParam) {
            throw new Error("Aucun param√®tre actif trouv√©");
          }

          console.log("üîß Cr√©ation des datasets...");
          const datasets = createDatasets(activeParam);

          if (!datasets || datasets.length === 0) {
            throw new Error("Aucun dataset disponible");
          }

          console.log(`‚úÖ ${datasets.length} datasets cr√©√©s`);

          // Create simple time labels
          console.log("üè∑Ô∏è Cr√©ation des labels de temps...");
          const timeLabels = weatherData.hourly.time.map((time, index) => {
            const date = new Date(time);
            if (index % 12 === 0) {
              // Show every 12 hours for date + 12h format
              const day = date.getDate();
              const month = date.toLocaleDateString("fr-FR", {
                month: "short",
              });
              return `${day} ${month}`;
            } else if (index % 12 === 6) {
              // Show just date for mid-day points
              const day = date.getDate();
              const month = date.toLocaleDateString("fr-FR", {
                month: "short",
              });
              return `${day} ${month}`;
            }
            return "";
          });

          console.log(`üè∑Ô∏è ${timeLabels.filter((l) => l).length} labels cr√©√©s`);

          // Determine chart type based on parameter
          let chartType = "line";
          if (activeParam === "precipitation") {
            chartType = "bar"; // Base type for precipitation combo chart
          } else if (
            activeParam === "wind_direction" &&
            windDirectionMode === "points"
          ) {
            chartType = "scatter";
          }
          console.log(`üìä Type de graphique: ${chartType}`);

          // Sort datasets for precipitation to create stacked effect (smallest to largest)
          if (activeParam === "precipitation") {
            console.log("üîÑ Tri des datasets pour effet de superposition...");
            // Sort datasets by average value (excluding aggregation)
            const modelDatasets = datasets.filter((ds) => !ds.isAggregate);
            const aggregateDataset = datasets.find((ds) => ds.isAggregate);

            modelDatasets.sort((a, b) => {
              const avgA = a.data
                .filter((v) => v !== null)
                .reduce((sum, v, _, arr) => sum + v / arr.length, 0);
              const avgB = b.data
                .filter((v) => v !== null)
                .reduce((sum, v, _, arr) => sum + v / arr.length, 0);
              return avgA - avgB; // Smallest to largest
            });

            // Reconstruct datasets array with sorted models + aggregation at the end
            if (aggregateDataset) {
              datasets.length = 0;
              datasets.push(...modelDatasets, aggregateDataset);
            } else {
              datasets.length = 0;
              datasets.push(...modelDatasets);
            }
          }

          console.log("üìà Cr√©ation du graphique Chart.js...");
          currentChart = new Chart(ctx, {
            type: chartType,
            data: {
              labels: timeLabels,
              datasets: datasets,
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                x: {
                  stacked:
                    activeParam === "precipitation" &&
                    precipitationMode === "stacked",
                  type: "category",
                  title: {
                    display: false,
                  },
                },
                y: {
                  stacked:
                    activeParam === "precipitation" &&
                    precipitationMode === "stacked",
                  title: {
                    display: true,
                    text: PARAMETERS[activeParam].unit,
                  },
                  position: "left",
                },
                // ‚û§ COMBO : Ajouter axe Y secondaire pour la probabilit√© lors des pr√©cipitations
                ...(activeParam === "precipitation" && {
                  y1: {
                    type: "linear",
                    display: true,
                    position: "right",
                    title: {
                      display: true,
                      text: "Probabilit√© (%)",
                    },
                    min: 0,
                    max: 100,
                    // grid lines only want to show for one axis to avoid clutter
                    grid: {
                      drawOnChartArea: false,
                    },
                  },
                }),
              },
              plugins: {
                legend: {
                  display: false,
                },
                tooltip: {
                  mode: "index",
                  intersect: false,
                  backgroundColor: "rgba(248, 249, 250, 0.95)",
                  titleColor: "#000000",
                  bodyColor: "#333333",
                  borderColor: "#dee2e6",
                  borderWidth: 1,
                  itemSort: (a, b) => {
                    // Trier du plus grand au plus petit
                    return b.parsed.y - a.parsed.y;
                  },
                  callbacks: {
                    title: function (context) {
                      const index = context[0].dataIndex;
                      const time = weatherData.hourly.time[index];
                      const date = new Date(time);
                      return date.toLocaleDateString("fr-FR", {
                        day: "2-digit",
                        month: "2-digit",
                        year: "numeric",
                        hour: "2-digit",
                        minute: "2-digit",
                      });
                    },
                    label: function (context) {
                      const modelName = context.dataset.label;
                      const value = context.parsed.y;
                      const color = context.dataset.borderColor;

                      if (value === null || value === undefined) return null;

                      // Skip precipitation models with 0.0mm in tooltip
                      const activeParam =
                        document.querySelector(".tab-btn.active")?.dataset
                          .param;
                      if (activeParam === "precipitation" && value === 0.0)
                        return null;

                      // Format with bold value
                      return `${modelName}: ${value.toFixed(2)} ${
                        PARAMETERS[activeParam].unit
                      }`;
                    },
                    labelColor: function (context) {
                      return {
                        backgroundColor: context.dataset.borderColor,
                        borderColor: context.dataset.borderColor,
                        borderWidth: 2,
                        borderRadius: 0, // Square instead of circle
                      };
                    },
                    labelTextColor: function (context) {
                      return context.dataset.borderColor;
                    },
                  },
                },
                zoom: {
                  zoom: {
                    wheel: {
                      enabled: false,
                    },
                    pinch: {
                      enabled: true,
                    },
                    drag: {
                      enabled: true,
                      backgroundColor: "rgba(37, 99, 235, 0.2)",
                    },
                    mode: "x",
                    onZoomComplete: function ({ chart }) {
                      const zoomBtn = document.getElementById("zoomResetBtn");
                      if (zoomBtn) {
                        zoomBtn.style.display = "block";
                      }
                    },
                  },
                  pan: {
                    enabled: true,
                    mode: "x",
                  },
                },
              },
              interaction: {
                intersect: false,
                mode: "index",
              },
            },
          });

          console.log("‚úÖ Graphique principal cr√©√© avec succ√®s");

          // Mettre √† jour le panel d'analyse avec l'agr√©gation automatique
          setTimeout(() => {
            console.log("üéØ DEBUG PANEL - Trigger depuis createMainChart");
            updateAnalysisPanel(weatherData, null);
          }, 100);
        } catch (error) {
          console.error("‚ùå Erreur cr√©ation graphique principal:", error);
          alert("Erreur lors de la cr√©ation du graphique: " + error.message);
        }
      }

      function createDatasets(paramKey) {
        console.log(`üìä createDatasets pour param√®tre: ${paramKey}`);
        const datasets = [];
        const models = selectedModels[paramKey] || {};
        const parameter = PARAMETERS[paramKey].apiParams[0];

        console.log(
          `üîç Mod√®les disponibles pour ${paramKey}:`,
          Object.keys(models)
        );
        console.log(`üìã Configuration des mod√®les:`, models);

        Object.entries(models).forEach(([model, range], index) => {
          console.log(`üîß Traitement du mod√®le: ${model}, range:`, range);
          const fullParamName = `${parameter}_${model}`;
          const data = weatherData.hourly[fullParamName];

          console.log(
            `üì° Donn√©es pour ${fullParamName}:`,
            data ? `${data.length} valeurs` : "PAS DE DONN√âES"
          );

          if (!data) {
            console.log(`‚ùå Pas de donn√©es pour ${fullParamName}`);
            return;
          }

          const color = MODEL_COLORS[model] || "#999";

          let processedData;
          const activeParam =
            document.querySelector(".tab-btn.active")?.dataset.param;

          if (
            activeParam === "wind_direction" &&
            windDirectionMode === "points"
          ) {
            // For scatter plot, create {x, y} objects
            processedData = data
              .map((value, i) => {
                const currentHour = i;
                if (currentHour < range.start || currentHour >= range.end)
                  return null;
                if (value === null || value === undefined) return null;
                return { x: i, y: value };
              })
              .filter((point) => point !== null);
          } else {
            // For line/bar charts, use simple array
            processedData = data.map((value, i) => {
              // Convertir l'index en heures depuis le d√©but
              const currentHour = i;
              if (currentHour < range.start || currentHour >= range.end)
                return null;
              return value;
            });
          }

          console.log(
            `üìà Dataset cr√©√© pour ${model}: ${
              processedData.filter((v) => v !== null).length
            } points valides`
          );

          // Special case for Biarritz and Cap-Corse - make line bold
          const isBoldCity = ["Biarritz", "Cap-Corse"].includes(
            selectedCity?.name
          );

          // Different styling for bar vs line charts
          const isBarChart = paramKey === "precipitation";

          const datasetConfig = {
            label:
              MODEL_DISPLAY_NAMES[model] ||
              model.replace(/_/g, " ").toUpperCase(),
            data: processedData,
            borderColor: color,
            backgroundColor: isBarChart ? color + "80" : color + "20",
            hidden: false, // Explicitement pas cach√©
          };

          if (isBarChart) {
            // Bar chart specific options
            datasetConfig.borderWidth = 1;
            datasetConfig.barPercentage = 0.9;
            datasetConfig.categoryPercentage = 0.8;

            if (precipitationMode === "stacked") {
              datasetConfig.stack = "precipitation"; // Stack all precipitation bars together
            } else {
              // Behind mode: different stacks for layering effect
              datasetConfig.stack = `precipitation-${index}`;
              datasetConfig.barPercentage = 1.0;
              datasetConfig.categoryPercentage = 1.0;
            }
          } else if (
            activeParam === "wind_direction" &&
            windDirectionMode === "points"
          ) {
            // Scatter chart specific options
            datasetConfig.showLine = false;
            datasetConfig.pointRadius = 3;
            datasetConfig.pointHoverRadius = 6;
            datasetConfig.borderWidth = 0;
            datasetConfig.pointBorderColor = color;
            datasetConfig.pointBackgroundColor = color;
          } else {
            // Line chart specific options
            datasetConfig.fill = false;
            datasetConfig.tension = 0.1;
            datasetConfig.pointRadius = 0;
            datasetConfig.pointHoverRadius = 4;
            datasetConfig.borderWidth = isBoldCity ? 3 : 1; // Bold line for specific cities
          }

          datasets.push(datasetConfig);
        });

        console.log(`‚úÖ ${datasets.length} datasets cr√©√©s pour ${paramKey}`);

        /* ‚ûï COMBO : Ajout de la courbe de probabilit√© pour les pr√©cipitations */
        if (paramKey === "precipitation") {
          // ‚úÖ CORRECTION : Calculer la probabilit√© √† partir des donn√©es mm des mod√®les de pr√©cipitation
          // Utiliser les M√äMES mod√®les et √©ch√©ances que pour les pr√©cipitations mm
          const precipitationProbabilityData = calculatePrecipitationAlgorithm(
            "precipitation_probability",
            models, // Utiliser les mod√®les de pr√©cipitation, pas ceux de precipitation_probability
            "precipitation", // Utiliser les donn√©es mm, pas precipitation_probability
            weatherData.hourly.time.length
          );

          if (
            precipitationProbabilityData &&
            precipitationProbabilityData.some((v) => v !== null)
          ) {
            const probabilityDataset = {
              label: "Probabilit√© de pr√©cipitation",
              data: precipitationProbabilityData,
              type: "line", // Line sur un graphique de base en barres = combo
              borderColor: "#8B0000", // Rouge fonc√©
              backgroundColor: "transparent",
              borderWidth: 3,
              fill: false,
              tension: 0.1,
              pointRadius: 0,
              pointHoverRadius: 4,
              yAxisID: "y1", // Utiliser l'axe Y secondaire
              order: 0, // Afficher au premier plan
              hidden: false,
            };

            datasets.push(probabilityDataset);
            console.log(
              "‚úÖ Courbe de probabilit√© ajout√©e au graphique combo (bas√©e sur donn√©es mm)"
            );
          }
        }

        /* ‚ûï Ajout de la courbe d'agr√©gation */
        let aggregatedData = calculateAggregatedData(paramKey);
        const isBarChart = paramKey === "precipitation";
        const isScatterChart =
          paramKey === "wind_direction" && windDirectionMode === "points";

        // Convert aggregated data for scatter plot
        if (isScatterChart) {
          aggregatedData = aggregatedData
            .map((value, i) => {
              if (value === null || value === undefined) return null;
              return { x: i, y: value };
            })
            .filter((point) => point !== null);
        }

        const aggregateConfig = {
          label: STRATEGIES[selectedStrategy].label,
          data: aggregatedData,
          borderColor: "#000000",
          backgroundColor: isBarChart ? "#00000080" : "#00000020",
          hidden: false,
          isAggregate: true,
        };

        if (isBarChart) {
          // Bar chart specific options for aggregation
          aggregateConfig.borderWidth = 2;
          aggregateConfig.barPercentage = 0.9;
          aggregateConfig.categoryPercentage = 0.8;
          aggregateConfig.stack = "aggregation"; // Always separate stack for aggregation
          aggregateConfig.order = -1; // Render behind other bars

          if (precipitationMode === "behind") {
            aggregateConfig.barPercentage = 1.0;
            aggregateConfig.categoryPercentage = 1.0;
          }
        } else if (isScatterChart) {
          // Scatter chart specific options for aggregation
          aggregateConfig.showLine = false;
          aggregateConfig.pointRadius = 5;
          aggregateConfig.pointHoverRadius = 8;
          aggregateConfig.borderWidth = 0;
          aggregateConfig.pointBorderColor = "#000000";
          aggregateConfig.pointBackgroundColor = "#000000";
          aggregateConfig.pointBorderWidth = 2;
        } else {
          // Line chart specific options for aggregation
          aggregateConfig.borderWidth = 3;
          aggregateConfig.fill = false;
          aggregateConfig.tension = 0.1;
          aggregateConfig.pointRadius = 0;
          aggregateConfig.pointHoverRadius = 4;
        }

        datasets.push(aggregateConfig);

        return datasets;
      }

      // Met √† jour uniquement la courbe d'agr√©gation lorsque la strat√©gie change
      function updateAggregateDataset() {
        if (!currentChart) return;

        const activeParam =
          document.querySelector(".tab-btn.active")?.dataset.param;
        if (!activeParam) return;

        let aggregatedData = calculateAggregatedData(activeParam);
        const label = STRATEGIES[selectedStrategy].label;
        const isBarChart = activeParam === "precipitation";
        const isScatterChart =
          activeParam === "wind_direction" && windDirectionMode === "points";

        // Convert aggregated data for scatter plot
        if (isScatterChart) {
          aggregatedData = aggregatedData
            .map((value, i) => {
              if (value === null || value === undefined) return null;
              return { x: i, y: value };
            })
            .filter((point) => point !== null);
        }

        let aggregateDs = currentChart.data.datasets.find(
          (ds) => ds.isAggregate
        );

        if (aggregateDs) {
          aggregateDs.data = aggregatedData;
          aggregateDs.label = label;
          // Update styling based on chart type
          aggregateDs.backgroundColor = isBarChart ? "#00000080" : "#00000020";

          if (isBarChart) {
            aggregateDs.borderWidth = 2;
            delete aggregateDs.fill;
            delete aggregateDs.tension;
            delete aggregateDs.pointRadius;
            delete aggregateDs.pointHoverRadius;
            delete aggregateDs.showLine;
            delete aggregateDs.pointBorderColor;
            delete aggregateDs.pointBackgroundColor;
            delete aggregateDs.pointBorderWidth;
            aggregateDs.barPercentage = 0.9;
            aggregateDs.categoryPercentage = 0.8;
            aggregateDs.stack = "aggregation"; // Always separate stack for aggregation
            aggregateDs.order = -1; // Render behind other bars

            if (precipitationMode === "behind") {
              aggregateDs.barPercentage = 1.0;
              aggregateDs.categoryPercentage = 1.0;
            }
          } else if (isScatterChart) {
            aggregateDs.borderWidth = 0;
            delete aggregateDs.fill;
            delete aggregateDs.tension;
            delete aggregateDs.barPercentage;
            delete aggregateDs.categoryPercentage;
            delete aggregateDs.stack;
            delete aggregateDs.order;
            aggregateDs.showLine = false;
            aggregateDs.pointRadius = 5;
            aggregateDs.pointHoverRadius = 8;
            aggregateDs.pointBorderColor = "#000000";
            aggregateDs.pointBackgroundColor = "#000000";
            aggregateDs.pointBorderWidth = 2;
          } else {
            aggregateDs.borderWidth = 3;
            delete aggregateDs.barPercentage;
            delete aggregateDs.categoryPercentage;
            delete aggregateDs.stack;
            delete aggregateDs.order;
            delete aggregateDs.showLine;
            delete aggregateDs.pointBorderColor;
            delete aggregateDs.pointBackgroundColor;
            delete aggregateDs.pointBorderWidth;
            aggregateDs.fill = false;
            aggregateDs.tension = 0.1;
            aggregateDs.pointRadius = 0;
            aggregateDs.pointHoverRadius = 4;
          }
        } else {
          const aggregateConfig = {
            label,
            data: aggregatedData,
            borderColor: "#000000",
            backgroundColor: isBarChart ? "#00000080" : "#00000020",
            hidden: false,
            isAggregate: true,
          };

          if (isBarChart) {
            aggregateConfig.borderWidth = 2;
            aggregateConfig.barPercentage = 0.9;
            aggregateConfig.categoryPercentage = 0.8;
            aggregateConfig.stack = "aggregation"; // Always separate stack for aggregation
            aggregateConfig.order = -1; // Render behind other bars

            if (precipitationMode === "behind") {
              aggregateConfig.barPercentage = 1.0;
              aggregateConfig.categoryPercentage = 1.0;
            }
          } else if (isScatterChart) {
            aggregateConfig.borderWidth = 0;
            aggregateConfig.showLine = false;
            aggregateConfig.pointRadius = 5;
            aggregateConfig.pointHoverRadius = 8;
            aggregateConfig.pointBorderColor = "#000000";
            aggregateConfig.pointBackgroundColor = "#000000";
            aggregateConfig.pointBorderWidth = 2;
          } else {
            aggregateConfig.borderWidth = 3;
            aggregateConfig.fill = false;
            aggregateConfig.tension = 0.1;
            aggregateConfig.pointRadius = 0;
            aggregateConfig.pointHoverRadius = 4;
          }

          currentChart.data.datasets.push(aggregateConfig);
        }

        currentChart.update();
      }

      function updateMainChart() {
        console.log("üîÑ updateMainChart - D√©but");
        if (!currentChart) {
          console.log("‚ùå Pas de graphique currentChart");
          return;
        }

        try {
          const activeParam =
            document.querySelector(".tab-btn.active")?.dataset.param;
          console.log(`üéØ Param√®tre actif pour mise √† jour: ${activeParam}`);

          if (!activeParam) {
            console.log("‚ùå Aucun param√®tre actif pour la mise √† jour");
            return;
          }

          const models = selectedModels[activeParam] || {};
          console.log(`üîç Mod√®les pour mise √† jour:`, Object.keys(models));

          currentChart.data.datasets.forEach((dataset, index) => {
            const modelKeys = Object.keys(models);
            console.log(`üìä Dataset ${index}: ${dataset.label}`);

            // Handle aggregation dataset
            if (dataset.isAggregate) {
              const controlsContainer =
                document.getElementById("chartControls");
              const aggregationToggle = controlsContainer
                ? controlsContainer.querySelector(`[data-model="aggregation"]`)
                : null;

              if (aggregationToggle) {
                const wasHidden = dataset.hidden;
                const oldBorderWidth = dataset.borderWidth;

                dataset.hidden = aggregationToggle.classList.contains("hidden");

                // Handle border width based on state
                if (aggregationToggle.classList.contains("emphasized")) {
                  dataset.borderWidth = 6;
                } else if (aggregationToggle.classList.contains("active")) {
                  dataset.borderWidth = 3;
                } else {
                  dataset.borderWidth = 3;
                }

                console.log(
                  `üìà AGR√âGATION: hidden ${wasHidden} ‚Üí ${dataset.hidden}, borderWidth ${oldBorderWidth} ‚Üí ${dataset.borderWidth}`
                );
              }
            } else {
              // Find model by matching dataset label with model display names
              let matchedModel = null;
              const models = selectedModels[activeParam] || {};

              for (const model of Object.keys(models)) {
                const displayName =
                  MODEL_DISPLAY_NAMES[model] ||
                  model.replace(/_/g, " ").toUpperCase();
                if (dataset.label === displayName) {
                  matchedModel = model;
                  break;
                }
              }

              if (matchedModel) {
                const controlsContainer =
                  document.getElementById("chartControls");
                const toggle = controlsContainer
                  ? controlsContainer.querySelector(
                      `[data-model="${matchedModel}"]`
                    )
                  : null;

                console.log(
                  `üîò Contr√¥le trouv√© pour ${matchedModel}:`,
                  toggle ? "OUI" : "NON"
                );

                if (toggle) {
                  const wasHidden = dataset.hidden;
                  const oldBorderWidth = dataset.borderWidth;

                  dataset.hidden = toggle.classList.contains("hidden");

                  // Handle border width based on state
                  if (toggle.classList.contains("emphasized")) {
                    dataset.borderWidth = 4;
                  } else if (toggle.classList.contains("active")) {
                    dataset.borderWidth = 1;
                  } else {
                    dataset.borderWidth = 1;
                  }

                  console.log(
                    `üìà ${matchedModel}: hidden ${wasHidden} ‚Üí ${dataset.hidden}, borderWidth ${oldBorderWidth} ‚Üí ${dataset.borderWidth}`
                  );
                }
              } else {
                console.log(
                  `‚ö†Ô∏è Dataset ${index} sans mod√®le correspondant: ${dataset.label}`
                );
              }
            }
          });

          console.log("üîÑ Mise √† jour du graphique...");
          currentChart.update();
          console.log("‚úÖ Graphique mis √† jour");
        } catch (error) {
          console.error("‚ùå Erreur mise √† jour graphique:", error);
        }
      }

      async function applyStrategy() {
        console.log("üöÄ D√©but applyStrategy");
        if (!weatherData || !selectedModels) {
          alert("Veuillez d'abord mettre √† jour le graphique");
          return;
        }

        const activeParam =
          document.querySelector(".tab-btn.active").dataset.param;
        console.log("üìä Param√®tre actif:", activeParam);
        const aggregatedData = calculateAggregatedData(activeParam);
        console.log(
          "üìà Donn√©es agr√©g√©es calcul√©es:",
          aggregatedData ? aggregatedData.length : 0,
          "points"
        );
        createAggregatedChart(aggregatedData, activeParam);
        console.log("‚úÖ Fin applyStrategy");
      }

      // Fonctions utilitaires pour l'algorithme de pr√©cipitation
      function clamp(min, max, value) {
        return Math.min(max, Math.max(min, value));
      }

      function calculateVariance(values) {
        if (values.length <= 1) return 0;
        const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
        const variance =
          values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) /
          values.length;
        return Math.sqrt(variance);
      }

      function calculateMean(values) {
        if (values.length === 0) return 0;
        return values.reduce((sum, val) => sum + val, 0) / values.length;
      }

      function applyGaussianWeighting(values, beta = 1.618) {
        if (values.length === 0) return 0;
        if (values.length === 1) return values[0];

        const mu = calculateMean(values);
        const sigma = calculateVariance(values);

        if (sigma === 0) return mu;

        // Calculer les poids gaussiens
        const weights = values.map((val) => {
          return Math.exp(
            -Math.pow(val - mu, 2) / (2 * Math.pow(beta * sigma, 2))
          );
        });

        // Normaliser les poids
        const weightSum = weights.reduce((sum, w) => sum + w, 0);
        if (weightSum === 0) return mu;

        // Moyenne pond√©r√©e
        return (
          values.reduce((sum, val, i) => sum + val * weights[i], 0) / weightSum
        );
      }

      function isIsolatedPeak(
        currentValue,
        prevValue,
        nextValue,
        threshold = 2.0
      ) {
        if (prevValue === null && nextValue === null) return false;
        if (prevValue === null) prevValue = 0;
        if (nextValue === null) nextValue = 0;

        const avgNeighbors = (prevValue + nextValue) / 2;
        return currentValue > threshold * avgNeighbors;
      }

      function getSeasonalAlpha() {
        const now = new Date();
        const month = now.getMonth() + 1; // 1-12
        // Plus fort en √©t√© (juin-ao√ªt = 6-8)
        if (month >= 6 && month <= 8) {
          return 0.3;
        } else {
          return 0.1;
        }
      }

      function getSeasonalK() {
        const now = new Date();
        const month = now.getMonth() + 1; // 1-12
        // Plus fort en √©t√©
        if (month >= 6 && month <= 8) {
          return 0.35;
        } else {
          return 0.2;
        }
      }

      function calculateAggregatedData(paramKey) {
        const models = selectedModels[paramKey] || {};
        const parameter = PARAMETERS[paramKey].apiParams[0];

        if (Object.keys(models).length === 0) {
          return [];
        }

        const timeLength = weatherData.hourly.time.length;

        // Cas sp√©cial pour l'algorithme de pr√©cipitation
        if (
          selectedStrategy === "precipitation_algo" &&
          (paramKey === "precipitation" ||
            paramKey === "precipitation_probability")
        ) {
          // ‚úÖ CORRECTION : Pour precipitation_probability, utiliser les mod√®les et donn√©es de precipitation mm
          if (paramKey === "precipitation_probability") {
            const precipitationModels = selectedModels["precipitation"] || {};
            return calculatePrecipitationAlgorithm(
              paramKey,
              precipitationModels, // Utiliser les mod√®les de pr√©cipitation mm
              "precipitation", // Utiliser les donn√©es de pr√©cipitation mm
              timeLength
            );
          } else {
            return calculatePrecipitationAlgorithm(
              paramKey,
              models,
              parameter,
              timeLength
            );
          }
        }

        const aggregatedData = [];

        for (let i = 0; i < timeLength; i++) {
          const values = [];

          Object.entries(models).forEach(([model, range]) => {
            // Convertir l'index en heures depuis le d√©but
            const currentHour = i;
            if (currentHour >= range.start && currentHour < range.end) {
              const fullParamName = `${parameter}_${model}`;
              const paramArray = weatherData.hourly[fullParamName];
              if (!paramArray) return; // Pas de donn√©es pour ce mod√®le
              const value = paramArray[i];
              if (value !== null && value !== undefined) {
                values.push(value);
              }
            }
          });

          if (values.length > 0) {
            // D√©tecter si c'est la direction du vent pour utiliser les m√©thodes circulaires
            const isWindDirection = paramKey === "wind_direction";
            const aggregatedValue = applyAggregationStrategy(
              values,
              selectedStrategy,
              isWindDirection
            );
            aggregatedData.push(aggregatedValue);
          } else {
            aggregatedData.push(null);
          }
        }

        return aggregatedData;
      }

      // ===== CONFIGURATION PANNEAU DE CONTR√îLE PLUIE =====
      let rainParams = {
        // Nouvelle approche : pond√©ration par palliers
        weightPallier01: 0.3, // Pond√©ration pour 0.1mm
        weightPallier02: 0.6, // Pond√©ration pour 0.2mm
        weightPallier03: 0.8, // Pond√©ration pour 0.3mm
        // >= 0.4mm = automatiquement 1.0

        sigmaRef: 4.0,
        alphaAggressive: 0.2,
        gamma: 0.1,

        // Nouvelle pond√©ration temporelle
        temporalMode: "3days", // "none", "3days", "5days"
        temporalCenterWeight: 80, // 0-100% pour le poids central H
        temporalConcentration: 50, // 0-100% pour la concentration autour de H

        detectIsolatedPeaks: true,
        kFactor: 0.35,
        minWetModels: 0.3,
        enableBoostMalus: false,
        neutralModels: 6,
        boostCoeff: 0.02,
        probCap: 1.0,
      };

      // Debounce timer pour √©viter trop de mises √† jour
      let updateChartTimer = null;

      // Gestion de l'affichage du panneau
      function toggleRainParamsPanel(show) {
        const panel = document.getElementById("rainParamsSection");
        if (panel) {
          panel.style.display = show ? "block" : "none";
        }
      }

      // Fonction pour mettre √† jour la courbe de probabilit√© dans le graphique principal
      function updateProbabilityDatasetInMainChart(probabilityData) {
        if (!currentChart || !probabilityData) return;

        console.log(
          "üîÑ Mise √† jour de la courbe de probabilit√© dans le graphique principal"
        );

        // Chercher le dataset de probabilit√© (courbe rouge)
        const datasets = currentChart.data.datasets;
        let probabilityDataset = null;
        let probabilityIndex = -1;

        for (let i = 0; i < datasets.length; i++) {
          const dataset = datasets[i];
          if (
            dataset.label &&
            dataset.label.includes("Probabilit√© de pr√©cipitation")
          ) {
            probabilityDataset = dataset;
            probabilityIndex = i;
            break;
          }
        }

        if (probabilityDataset && probabilityIndex >= 0) {
          console.log(
            `üìä Dataset de probabilit√© trouv√© √† l'index ${probabilityIndex}`
          );

          // Mettre √† jour les donn√©es
          probabilityDataset.data = probabilityData;

          // Mettre √† jour le graphique
          currentChart.update("none");
          console.log("‚úÖ Courbe de probabilit√© mise √† jour");
        } else {
          console.log("‚ö†Ô∏è Courbe de probabilit√© non trouv√©e");
        }
      }

      // Fonction pour mettre √† jour seulement le dataset d'agr√©gation dans le graphique principal
      function updateAggregationDatasetInMainChart(aggregatedData, paramKey) {
        if (!currentChart || !aggregatedData) return;

        console.log(
          "üîÑ Mise √† jour du dataset d'agr√©gation dans le graphique principal"
        );

        // Trouver le dataset d'agr√©gation (g√©n√©ralement le dernier)
        const datasets = currentChart.data.datasets;
        let aggregationDataset = null;
        let aggregationIndex = -1;

        // Chercher le dataset d'agr√©gation par son label ou par sa position
        for (let i = datasets.length - 1; i >= 0; i--) {
          const dataset = datasets[i];
          if (
            dataset.label &&
            (dataset.label.includes("Algo Pr√©cipitation") ||
              dataset.label.includes("Moyenne") ||
              dataset.label.includes("M√©diane") ||
              dataset.label.includes("Pond√©ration") ||
              dataset.order === 0) // Les datasets d'agr√©gation ont g√©n√©ralement order: 0
          ) {
            aggregationDataset = dataset;
            aggregationIndex = i;
            break;
          }
        }

        if (aggregationDataset && aggregationIndex >= 0) {
          console.log(
            `üìä Dataset d'agr√©gation trouv√© √† l'index ${aggregationIndex}: ${aggregationDataset.label}`
          );

          // Mettre √† jour les donn√©es
          aggregationDataset.data = aggregatedData;

          // Mettre √† jour le graphique
          currentChart.update("none"); // 'none' pour pas d'animation
          console.log("‚úÖ Dataset d'agr√©gation mis √† jour");
        } else {
          console.log("‚ö†Ô∏è Dataset d'agr√©gation non trouv√©");
        }
      }

      // Fonction pour d√©clencher la mise √† jour du graphique avec d√©lai
      function triggerChartUpdate() {
        console.log("üéõÔ∏è triggerChartUpdate() appel√©e");
        if (updateChartTimer) {
          clearTimeout(updateChartTimer);
        }
        updateChartTimer = setTimeout(() => {
          console.log("‚è∞ D√©lai de 150ms √©coul√©, mise √† jour du graphique...");
          if (currentChart) {
            // Recalculer les donn√©es d'agr√©gation avec les nouveaux param√®tres
            const activeParam =
              document.querySelector(".tab-btn.active")?.dataset.param;
            console.log(`üéØ Param√®tre actif d√©tect√©: ${activeParam}`);

            if (
              activeParam &&
              (activeParam === "precipitation" ||
                activeParam === "precipitation_probability")
            ) {
              console.log(
                "üîÑ Recalcul des donn√©es de pr√©cipitation avec nouveaux param√®tres"
              );

              // TOUJOURS recalculer la probabilit√© (m√™me si on est sur l'onglet mm)
              const probabilityData = calculateAggregatedData(
                "precipitation_probability"
              );

              // Si on est sur l'onglet mm, recalculer aussi les mm
              if (activeParam === "precipitation") {
                const mmData = calculateAggregatedData("precipitation");
                updateAggregationDatasetInMainChart(mmData, "precipitation");
              }

              // Toujours mettre √† jour la courbe de probabilit√©
              updateProbabilityDatasetInMainChart(probabilityData);
            }

            updateMainChart();
            updateParamVisualization();
          } else {
            console.log("‚ö†Ô∏è currentChart n'existe pas");
          }
        }, 150);
      }

      // Mise √† jour des valeurs affich√©es
      function updateSliderValue(sliderId, value, unit = "") {
        const valueElement = document.getElementById(sliderId + "Value");
        if (valueElement) {
          valueElement.textContent = value + unit;
        }
      }

      // Initialisation des event listeners pour le panneau
      function initRainParamsEventListeners() {
        // Toggle du panneau
        const toggle = document.getElementById("rainParamsToggle");
        const content = document.getElementById("rainParamsContent");
        if (toggle && content) {
          toggle.addEventListener("click", () => {
            const isVisible = content.style.display !== "none";
            content.style.display = isVisible ? "none" : "block";
            toggle.textContent = isVisible ? "‚ñº Afficher" : "‚ñ≤ Masquer";
          });
        }

        // Sliders principaux
        [
          "weightPallier01",
          "weightPallier02",
          "weightPallier03",
          "sigmaRef",
          "alphaAggressive",
          "gamma",
          "kFactor",
          "minWetModels",
          "neutralModels",
          "boostCoeff",
          "temporalCenterWeight",
          "temporalConcentration",
        ].forEach((param) => {
          const slider = document.getElementById(param);
          if (slider) {
            slider.addEventListener("input", (e) => {
              const value = parseFloat(e.target.value);
              console.log(
                `üéõÔ∏è Slider ${param} chang√©: ${rainParams[param]} ‚Üí ${value}`
              );
              rainParams[param] = value;

              let unit = "";
              let displayValue = value;

              if (param === "minWetModels") {
                unit = "%";
                displayValue = Math.round(value * 100);
              } else if (
                param === "temporalCenterWeight" ||
                param === "temporalConcentration"
              ) {
                unit = "%";
              }

              updateSliderValue(param, displayValue, unit);

              // Mise √† jour en temps r√©el de l'affichage des pond√©rations temporelles
              if (
                param === "temporalCenterWeight" ||
                param === "temporalConcentration"
              ) {
                updateTemporalWeightsDisplay();
              }

              // Mise √† jour automatique du graphique
              triggerChartUpdate();
            });
          }
        });

        // Checkboxes
        ["detectIsolatedPeaks", "enableBoostMalus"].forEach((param) => {
          const checkbox = document.getElementById(param);
          if (checkbox) {
            checkbox.addEventListener("change", (e) => {
              rainParams[param] = e.target.checked;
              triggerChartUpdate();
            });
          }
        });

        // Selects
        ["probCap"].forEach((param) => {
          const select = document.getElementById(param);
          if (select) {
            select.addEventListener("change", (e) => {
              rainParams[param] =
                e.target.value === "unlimited"
                  ? Infinity
                  : parseFloat(e.target.value) || e.target.value;
              triggerChartUpdate();
            });
          }
        });

        // Boutons radio pour mode temporel
        document
          .querySelectorAll('input[name="temporalMode"]')
          .forEach((radio) => {
            radio.addEventListener("change", (e) => {
              rainParams.temporalMode = e.target.value;
              updateTemporalControlsVisibility();
              updateTemporalWeightsDisplay();
              triggerChartUpdate();
            });
          });

        // Initialiser la visibilit√© des contr√¥les temporels
        updateTemporalControlsVisibility();
        updateTemporalWeightsDisplay();

        // Boutons d'action
        const applyBtn = document.getElementById("applyParams");
        if (applyBtn) {
          applyBtn.addEventListener("click", () => {
            triggerChartUpdate();
          });
        }

        const resetBtn = document.getElementById("resetParams");
        if (resetBtn) {
          resetBtn.addEventListener("click", () => {
            resetRainParamsToDefault();
            triggerChartUpdate();
          });
        }

        const saveBtn = document.getElementById("savePreset");
        if (saveBtn) {
          saveBtn.addEventListener("click", saveRainParamsPreset);
        }

        const loadBtn = document.getElementById("loadPreset");
        if (loadBtn) {
          loadBtn.addEventListener("click", loadRainParamsPreset);
        }
      }

      // Fonctions pour la gestion temporelle
      function updateTemporalControlsVisibility() {
        const controls = document.getElementById("temporalControls");
        const concentrationControl = document.getElementById(
          "temporalConcentrationControl"
        );
        const weightsDisplay = document.getElementById(
          "temporalWeightsDisplay"
        );

        const isActive = rainParams.temporalMode !== "none";

        if (controls) controls.style.display = isActive ? "block" : "none";
        if (concentrationControl)
          concentrationControl.style.display = isActive ? "block" : "none";
        if (weightsDisplay)
          weightsDisplay.style.display = isActive ? "block" : "none";
      }

      function calculateTemporalWeights() {
        if (rainParams.temporalMode === "none") {
          return { T: 1.0 };
        }

        const centerWeight = rainParams.temporalCenterWeight / 100; // Convertir en d√©cimal
        const concentration = rainParams.temporalConcentration / 100;

        if (rainParams.temporalMode === "3days") {
          // R√©partir le reste (1 - centerWeight) entre T-1 et T+1
          const sideWeight = (1 - centerWeight) / 2;
          return {
            "T-1": sideWeight,
            T: centerWeight,
            "T+1": sideWeight,
          };
        } else if (rainParams.temporalMode === "5days") {
          // R√©partir le reste entre T-2, T-1, T+1, T+2
          const totalSideWeight = 1 - centerWeight;

          // La concentration d√©termine comment r√©partir entre les c√¥t√©s proches et √©loign√©s
          const nearWeight = totalSideWeight * (0.3 + concentration * 0.4); // 30-70% pour T¬±1
          const farWeight = totalSideWeight - nearWeight; // Le reste pour T¬±2

          return {
            "T-2": farWeight / 2,
            "T-1": nearWeight / 2,
            T: centerWeight,
            "T+1": nearWeight / 2,
            "T+2": farWeight / 2,
          };
        }

        return { T: 1.0 };
      }

      function updateTemporalWeightsDisplay() {
        const weights = calculateTemporalWeights();
        const display = document.getElementById("weightDisplay");

        if (display) {
          if (rainParams.temporalMode === "none") {
            display.textContent = "Aucun lissage";
          } else {
            const weightStrings = Object.entries(weights)
              .map(([key, value]) => `${Math.round(value * 100)}%`)
              .join(" - ");
            display.textContent = weightStrings;
          }
        }
      }

      // Reset des param√®tres par d√©faut
      function resetRainParamsToDefault() {
        rainParams = {
          weightPallier01: 0.3,
          weightPallier02: 0.6,
          weightPallier03: 0.8,
          sigmaRef: 4.0,
          alphaAggressive: 0.2,
          gamma: 0.1,
          temporalMode: "3days",
          temporalCenterWeight: 80,
          temporalConcentration: 50,
          detectIsolatedPeaks: true,
          kFactor: 0.35,
          minWetModels: 0.3,
          enableBoostMalus: false,
          neutralModels: 6,
          boostCoeff: 0.02,
          probCap: 1.0,
        };

        // Mettre √† jour les contr√¥les UI
        updateRainParamsUI();
        updateTemporalControlsVisibility();
        updateTemporalWeightsDisplay();
      }

      // Mise √† jour de l'UI avec les valeurs actuelles
      function updateRainParamsUI() {
        Object.keys(rainParams).forEach((param) => {
          if (param === "temporalMode") {
            // Gestion sp√©ciale pour les boutons radio
            const radio = document.getElementById(
              `temporalMode${
                rainParams[param].charAt(0).toUpperCase() +
                rainParams[param].slice(1)
              }`
            );
            if (radio) radio.checked = true;
            return;
          }

          const element = document.getElementById(param);
          if (element) {
            if (element.type === "checkbox") {
              element.checked = rainParams[param];
            } else if (element.type === "range" || element.type === "number") {
              element.value = rainParams[param];
              let unit = "";
              let displayValue = rainParams[param];

              if (param === "minWetModels") {
                unit = "%";
                displayValue = Math.round(rainParams[param] * 100);
              } else if (
                param === "temporalCenterWeight" ||
                param === "temporalConcentration"
              ) {
                unit = "%";
              }

              updateSliderValue(param, displayValue, unit);
            } else if (element.tagName === "SELECT") {
              element.value =
                rainParams[param] === Infinity
                  ? "unlimited"
                  : rainParams[param];
            }
          }
        });
      }

      // Sauvegarde/chargement de presets
      function saveRainParamsPreset() {
        const presetName = prompt("Nom du preset:");
        if (presetName) {
          localStorage.setItem(
            `rainParams_${presetName}`,
            JSON.stringify(rainParams)
          );
          alert(`Preset "${presetName}" sauvegard√©!`);
        }
      }

      function loadRainParamsPreset() {
        const presetName = prompt("Nom du preset √† charger:");
        if (presetName) {
          const saved = localStorage.getItem(`rainParams_${presetName}`);
          if (saved) {
            rainParams = JSON.parse(saved);
            updateRainParamsUI();
            triggerChartUpdate();
            alert(`Preset "${presetName}" charg√©!`);
          } else {
            alert("Preset non trouv√©!");
          }
        }
      }

      // Fonction helper pour la pond√©ration temporelle
      // Nouvelle fonction de pond√©ration par palliers
      function getWeight(mm) {
        if (mm === 0) return 0;
        if (mm >= 0.4) return 1.0;

        // Pond√©ration exacte par pallier
        if (Math.abs(mm - 0.1) < 0.001) return rainParams.weightPallier01;
        if (Math.abs(mm - 0.2) < 0.001) return rainParams.weightPallier02;
        if (Math.abs(mm - 0.3) < 0.001) return rainParams.weightPallier03;

        // Interpolation lin√©aire pour les valeurs interm√©diaires
        if (mm < 0.1) return rainParams.weightPallier01 * (mm / 0.1);
        if (mm < 0.2)
          return (
            rainParams.weightPallier01 +
            (rainParams.weightPallier02 - rainParams.weightPallier01) *
              ((mm - 0.1) / 0.1)
          );
        if (mm < 0.3)
          return (
            rainParams.weightPallier02 +
            (rainParams.weightPallier03 - rainParams.weightPallier02) *
              ((mm - 0.2) / 0.1)
          );
        if (mm < 0.4)
          return (
            rainParams.weightPallier03 +
            (1.0 - rainParams.weightPallier03) * ((mm - 0.3) / 0.1)
          );

        return 1.0; // fallback
      }

      // Fonction pour appliquer la pond√©ration temporelle
      function applyTemporalSmoothing(P_raw, i, allPrecipData, timeLength) {
        if (rainParams.temporalMode === "none") {
          return P_raw;
        }

        const weights = calculateTemporalWeights();
        let totalWeight = 0;
        let weightedSum = 0;

        Object.entries(weights).forEach(([timeOffset, weight]) => {
          let targetIndex = i;

          if (timeOffset === "T-2") targetIndex = i - 2;
          else if (timeOffset === "T-1") targetIndex = i - 1;
          else if (timeOffset === "T") targetIndex = i;
          else if (timeOffset === "T+1") targetIndex = i + 1;
          else if (timeOffset === "T+2") targetIndex = i + 2;

          if (
            targetIndex >= 0 &&
            targetIndex < timeLength &&
            allPrecipData[targetIndex] &&
            allPrecipData[targetIndex].length > 0
          ) {
            const values = allPrecipData[targetIndex];
            // NOUVEAU : Utiliser la pond√©ration par palliers au lieu du seuil unique
            const P_t =
              values.reduce((sum, v) => sum + getWeight(v), 0) / values.length;
            weightedSum += P_t * weight;
            totalWeight += weight;
          }
        });

        return totalWeight > 0 ? weightedSum / totalWeight : P_raw;
      }

      // Fonction pour d√©tecter les pics isol√©s
      function detectIsolatedPeak(
        currentValues,
        currentIndex,
        allPrecipData,
        timeLength
      ) {
        if (currentIndex === 0 || currentIndex === timeLength - 1) {
          return false; // Pas de d√©tection en bordure
        }

        const prevValues = allPrecipData[currentIndex - 1] || [];
        const nextValues = allPrecipData[currentIndex + 1] || [];

        if (prevValues.length === 0 || nextValues.length === 0) {
          return false;
        }

        // Calculer les intensit√©s moyennes
        const currentIntensity =
          currentValues.reduce((sum, v) => sum + v, 0) / currentValues.length;
        const prevIntensity =
          prevValues.reduce((sum, v) => sum + v, 0) / prevValues.length;
        const nextIntensity =
          nextValues.reduce((sum, v) => sum + v, 0) / nextValues.length;

        // Crit√®re : T > 2 √ó (T-1 + T+1) ET intensit√© significative
        const threshold = 2 * (prevIntensity + nextIntensity);
        return (
          currentIntensity > threshold && currentIntensity > 0.1 // Seuil minimum pour consid√©rer un pic significatif
        );
      }

      // Mise √† jour des statistiques de visualisation
      function updateParamVisualization() {
        // Trouver le param√®tre actuellement s√©lectionn√© depuis l'interface
        const currentParam = getCurrentParameterFromUI();

        // Calculer des statistiques sur les donn√©es actuelles
        if (
          currentParam === "precipitation" ||
          currentParam === "precipitation_probability"
        ) {
          const data = calculateAggregatedData(currentParam);
          if (data && data.length > 0) {
            const validData = data.filter((v) => v !== null && v !== undefined);
            if (validData.length > 0) {
              const avgProba =
                validData.reduce((sum, v) => sum + v, 0) / validData.length;
              const avgElement = document.getElementById("avgProba");
              if (avgElement) {
                avgElement.textContent = avgProba.toFixed(1) + "%";
              }
            }
          }
        }

        const smoothingElement = document.getElementById("smoothingApplied");
        if (smoothingElement) {
          smoothingElement.textContent = rainParams.temporalSmoothing;
        }
      }

      // Fonction helper pour trouver le param√®tre actuellement s√©lectionn√©
      function getCurrentParameterFromUI() {
        // Chercher quel onglet est actuellement actif
        const activeTabs = document.querySelectorAll(".parameter-tab.active");
        if (activeTabs.length > 0) {
          return activeTabs[0].dataset.parameter;
        }
        return null;
      }

      function calculatePrecipitationAlgorithm(
        paramKey,
        models,
        parameter,
        timeLength
      ) {
        const aggregatedData = [];
        const alpha = rainParams.alphaAggressive;
        const k = rainParams.kFactor;
        const sigmaRef = rainParams.sigmaRef;
        const epsilon = 1e-6;

        // Pr√©-calculer toutes les donn√©es de pr√©cipitation par timestamp
        const allPrecipData = [];
        for (let i = 0; i < timeLength; i++) {
          const values = [];
          Object.entries(models).forEach(([model, range]) => {
            const currentHour = i;
            if (currentHour >= range.start && currentHour < range.end) {
              const fullParamName = `${parameter}_${model}`;
              const paramArray = weatherData.hourly[fullParamName];
              if (paramArray) {
                const value = paramArray[i];
                if (value !== null && value !== undefined) {
                  values.push(value);
                }
              }
            }
          });
          allPrecipData.push(values);
        }

        for (let i = 0; i < timeLength; i++) {
          const values = allPrecipData[i];

          if (values.length === 0) {
            aggregatedData.push(null);
            continue;
          }

          let result;

          if (paramKey === "precipitation_probability") {
            // ‚û§ NOUVEAU : Algorithme de probabilit√© selon nouvelle m√©thodologie

            // 1. NOUVELLE formule : P_raw = Œ£(poids_i) / N_total avec pond√©ration par palliers
            const P_raw =
              values.reduce((sum, v) => sum + getWeight(v), 0) / values.length;

            // 2. Lissage temporel configurable
            const P_smooth = applyTemporalSmoothing(
              P_raw,
              i,
              allPrecipData,
              timeLength
            );

            // 3. Ajouter boost/p√©nalit√© ¬±10% selon la variance (uniquement sur valeurs significatives)
            const significantValues = values.filter((v) => v > 0);
            let P_corrected = P_smooth;

            if (significantValues.length > 1) {
              const sigma_T = calculateVariance(significantValues);
              const sigma_ref = rainParams.sigmaRef;
              const gamma = rainParams.gamma; // facteur d'agressivit√©

              const variance_ratio = sigma_ref / (sigma_T + epsilon);
              const correction_factor = clamp(
                -0.1,
                0.1,
                gamma * Math.log(variance_ratio)
              );
              P_corrected = clamp(0.0, 1.0, P_smooth * (1 + correction_factor));
            }

            // 4. Boost/malus selon poids total des mod√®les
            if (rainParams.enableBoostMalus) {
              const totalWeight = values.reduce(
                (sum, v) => sum + getWeight(v),
                0
              );
              const avgWeight = totalWeight / values.length;
              // Comparer le poids moyen √† un seuil de neutralit√© (ex: 0.5)
              const boost = clamp(
                -0.1,
                0.1,
                rainParams.boostCoeff * (avgWeight - 0.5) * 2 // Normaliser autour de 0.5
              );
              P_corrected = clamp(0.0, 1.0, P_corrected * (1 + boost));
            }

            // 5. Gestion des pics isol√©s
            if (rainParams.detectIsolatedPeaks && values.length > 0) {
              const hasIsolatedPeak = detectIsolatedPeak(
                values,
                i,
                allPrecipData,
                timeLength
              );
              if (hasIsolatedPeak) {
                const avgWeight =
                  values.reduce((sum, v) => sum + getWeight(v), 0) /
                  values.length;
                if (avgWeight >= rainParams.minWetModels) {
                  // Renforcer le pic
                  const avgIntensity =
                    values.reduce((sum, v) => sum + v, 0) / values.length;
                  const sigma_T = calculateVariance(
                    values.filter((v) => v > 0)
                  );
                  const peakBoost =
                    rainParams.kFactor * (avgIntensity / (sigma_T + epsilon));
                  P_corrected = clamp(0.0, 1.0, P_corrected * (1 + peakBoost));
                } else {
                  // Neutraliser le pic si pas assez de poids total
                  P_corrected = 0;
                }
              }
            }

            // 6. Appliquer le cap de probabilit√© finale
            if (rainParams.probCap !== Infinity) {
              P_corrected = clamp(0.0, rainParams.probCap, P_corrected);
            }

            result = P_corrected * 100; // Convertir en pourcentage

            // üß™ LOG DEBUG : Tracer index et result avant push (dans la branche PROBA)
            console.log(
              `üß™ index ${i} (PROBA)`,
              "P_corrected:",
              P_corrected,
              "result:",
              result
            );
          } else {
            // Calcul de la pluviom√©trie pond√©r√©e pour precipitation (mm)
            // ‚û§ CORRECTION : Filtrer UNIQUEMENT les mod√®les √† 0mm (pas de seuil complexe pour les mm)
            const wettingValues = values.filter((v) => v > 0);
            console.log("ü•Ω values", values);
            console.log("ü•Ωü•Ω wettingValues", wettingValues);
            let mm_weighted;

            if (wettingValues.length === 0) {
              // Aucun mod√®le ne mouille, r√©sultat = 0
              mm_weighted = 0;
            } else {
              // Utiliser seulement les mod√®les mouillants (>0mm) pour la pond√©ration gaussienne
              mm_weighted = applyGaussianWeighting(wettingValues);
              console.log("ü•Ωü•Ωü•Ω mm_weighted", mm_weighted);
            }

            // Pond√©ration temporelle T-1, T, T+1
            let mm_final = mm_weighted;

            // V√©rifier si T-1 et T+1 existent et ont des donn√©es
            const prevValues = i > 0 ? allPrecipData[i - 1] : [];
            const nextValues = i < timeLength - 1 ? allPrecipData[i + 1] : [];

            let temporalWeights = [0.8]; // Poids pour T
            let temporalValues = [mm_weighted];
            console.log("ü•Ωü•Ωü•Ω temporalWeights", temporalWeights);
            console.log("ü•Ωü•Ωü•Ω temporalValues", temporalValues);
            if (prevValues.length > 0) {
              const prevWettingValues = prevValues.filter((v) => v > 0);
              const mm_prev =
                prevWettingValues.length > 0
                  ? applyGaussianWeighting(prevWettingValues)
                  : 0;
              console.log("ü•Ωü•Ωü•Ω mm_prev", mm_prev);
              temporalWeights.unshift(0.1); // Ajouter poids pour T-1
              temporalValues.unshift(mm_prev);
            }

            if (nextValues.length > 0) {
              const nextWettingValues = nextValues.filter((v) => v > 0);
              const mm_next =
                nextWettingValues.length > 0
                  ? applyGaussianWeighting(nextWettingValues)
                  : 0;
              console.log("ü•Ωü•Ωü•Ω mm_next", mm_next);
              temporalWeights.push(0.1); // Ajouter poids pour T+1
              temporalValues.push(mm_next);
            }

            // Normaliser les poids si T-1 ou T+1 manquent
            const totalWeight = temporalWeights.reduce((sum, w) => sum + w, 0);
            const normalizedWeights = temporalWeights.map(
              (w) => w / totalWeight
            );
            console.log("ü•Ωü•Ωü•Ωü•Ω normalizedWeights", normalizedWeights);
            console.log("ü•Ωü•Ωü•Ωü•Ω temporalValues", temporalValues);
            console.log(
              "ü•Ωü•Ωü•Ωü•Ωü•Ωü•Ωü•Ωü•Ω mm_t-1",
              normalizedWeights[0] * temporalValues[0]
            );
            console.log(
              "ü•Ωü•Ωü•Ωü•Ωü•Ωü•Ωü•Ωü•Ω mm_t",
              normalizedWeights[1] * temporalValues[1]
            );
            console.log(
              "ü•Ωü•Ωü•Ωü•Ωü•Ωü•Ωü•Ωü•Ω mm_t+1",
              normalizedWeights[2] * temporalValues[2]
            );
            mm_final = temporalValues.reduce(
              (sum, val, idx) => sum + val * normalizedWeights[idx],
              0
            );
            console.log("ü•Ωü•Ωü•Ωü•Ωü•Ωü•Ωü•Ωü•Ωü•Ωü•Ωü•Ωü•Ω mm_final", mm_final);

            // ‚û§ SUPPRESSION : Plus de traitement des pics isol√©s pour les mm (gard√© seulement pour proba)
            // Le calcul s'arr√™te ici avec mm_final du lissage temporel
            result = Math.max(0, mm_final);

            // üß™ LOG DEBUG : Tracer index, mm_final et result avant push (dans la branche MM)
            console.log(
              `üß™ index ${i} (MM)`,
              "mm_final:",
              mm_final,
              "result:",
              result
            );
          }

          // üß™ LOG DEBUG : Tracer index et result avant push (commun)
          console.log(`üß™ index ${i}`, "result:", result);
          aggregatedData.push(result);
        }

        // üß™ LOG DEBUG : Afficher le tableau final pour comparaison avec le graphe
        console.log(
          "üß™üß™ aggregatedData FINAL pour",
          paramKey,
          ":",
          aggregatedData
        );
        return aggregatedData;
      }

      // Fonction pour g√©rer les valeurs circulaires (direction du vent)
      function applyCircularAggregationStrategy(values, strategy) {
        if (values.length === 0) return 0;
        if (values.length === 1) return values[0];

        // √âtape 1 : Choix du pivot
        let pivot;
        const sorted = [...values].sort((a, b) => a - b);

        if (values.length === 2) {
          const [a, b] = sorted;
          const directDiff = Math.abs(b - a);
          const circularDiff = 360 - directDiff;
          pivot = (a + (directDiff < circularDiff ? b : b + 360)) / 2;
          if (pivot >= 360) pivot -= 360;
        } else {
          const mid = Math.floor(sorted.length / 2);
          pivot =
            sorted.length % 2 === 0
              ? (sorted[mid - 1] + sorted[mid]) / 2
              : sorted[mid];
        }

        // √âtape 2 : Centrage dans [-180, +180] autour du pivot
        const centered = values.map((angle) => {
          let delta = angle - pivot;
          while (delta > 180) delta -= 360;
          while (delta <= -180) delta += 360;
          return delta;
        });

        const sortedCentered = [...centered].sort((a, b) => a - b);

        // √âtape 3 : Application de la strat√©gie
        let result;
        switch (strategy) {
          case "mean":
            result =
              centered.reduce((sum, val) => sum + val, 0) / centered.length;
            break;

          case "median":
            const mid = Math.floor(sortedCentered.length / 2);
            result =
              sortedCentered.length % 2 === 0
                ? (sortedCentered[mid - 1] + sortedCentered[mid]) / 2
                : sortedCentered[mid];
            break;

          case "trimmed_mean":
            if (centered.length <= 2) {
              result =
                centered.reduce((sum, val) => sum + val, 0) / centered.length;
            } else {
              const trimmed = sortedCentered.slice(1, -1); // Enl√®ve min & max
              result =
                trimmed.reduce((sum, val) => sum + val, 0) / trimmed.length;
            }
            break;

          case "weighted_mean":
            const mean =
              centered.reduce((sum, val) => sum + val, 0) / centered.length;
            const stdDev = Math.sqrt(
              centered.reduce((sum, val) => sum + (val - mean) ** 2, 0) /
                centered.length
            );
            if (stdDev === 0) {
              result = mean;
            } else {
              const weights = centered.map(
                (val) => 1 / (1 + Math.abs(val - mean) / stdDev)
              );
              const weightSum = weights.reduce((sum, w) => sum + w, 0);
              result =
                centered.reduce((sum, val, i) => sum + val * weights[i], 0) /
                weightSum;
            }
            break;

          case "winsorized_mean":
            if (centered.length <= 2) {
              result =
                centered.reduce((sum, val) => sum + val, 0) / centered.length;
            } else {
              const lower = sortedCentered[1];
              const upper = sortedCentered[sortedCentered.length - 2];
              const winsorized = centered.map((val) =>
                Math.min(Math.max(val, lower), upper)
              );
              result =
                winsorized.reduce((sum, val) => sum + val, 0) /
                winsorized.length;
            }
            break;

          case "gaussian_weighted":
            const gMean =
              centered.reduce((sum, val) => sum + val, 0) / centered.length;
            const gStdDev = Math.sqrt(
              centered.reduce((sum, val) => sum + (val - gMean) ** 2, 0) /
                centered.length
            );
            if (gStdDev === 0) {
              result = gMean;
            } else {
              const gWeights = centered.map((val) => {
                const z = (val - gMean) / gStdDev;
                return Math.exp(-0.5 * z * z);
              });
              const gWeightSum = gWeights.reduce((sum, w) => sum + w, 0);
              result =
                centered.reduce((sum, val, i) => sum + val * gWeights[i], 0) /
                gWeightSum;
            }
            break;

          default:
            result =
              centered.reduce((sum, val) => sum + val, 0) / centered.length;
        }

        // √âtape 4 : D√©calage du pivot + normalisation [0, 360)
        let final = result + pivot;
        while (final < 0) final += 360;
        while (final >= 360) final -= 360;

        return final;
      }

      function applyAggregationStrategy(values, strategy, isCircular = false) {
        if (isCircular) {
          return applyCircularAggregationStrategy(values, strategy);
        }

        const sortedValues = [...values].sort((a, b) => a - b);

        switch (strategy) {
          case "mean":
            return values.reduce((sum, val) => sum + val, 0) / values.length;

          case "median":
            const mid = Math.floor(sortedValues.length / 2);
            return sortedValues.length % 2 === 0
              ? (sortedValues[mid - 1] + sortedValues[mid]) / 2
              : sortedValues[mid];

          case "trimmed_mean":
            if (sortedValues.length <= 2)
              return applyAggregationStrategy(values, "mean");
            // Retirer la plus basse et la plus haute
            const trimmed = sortedValues.slice(1, -1);
            return trimmed.reduce((sum, val) => sum + val, 0) / trimmed.length;

          case "precipitation_algo":
            // L'algorithme de pr√©cipitation est complexe et n√©cessite des donn√©es contextuelles
            // Pour l'instant, on retourne la moyenne gaussienne pond√©r√©e comme fallback
            // L'impl√©mentation compl√®te sera g√©r√©e au niveau de calculateAggregatedData
            return applyAggregationStrategy(values, "gaussian_weighted");

          case "winsorized_mean":
            const p = 1; // nombre de valeurs extr√™mes √† "√©craser"
            if (sortedValues.length <= 2 * p)
              return applyAggregationStrategy(values, "mean");

            const lowerBound = sortedValues[p];
            const upperBound = sortedValues[sortedValues.length - 1 - p];

            const winsorized = values.map((val) => {
              if (val < lowerBound) return lowerBound;
              if (val > upperBound) return upperBound;
              return val;
            });
            return (
              winsorized.reduce((sum, val) => sum + val, 0) / winsorized.length
            );

          case "gaussian_weighted":
            const gMean = applyAggregationStrategy(values, "mean");
            const gStdDev = Math.sqrt(
              values.reduce((sum, val) => sum + Math.pow(val - gMean, 2), 0) /
                values.length
            );
            if (gStdDev === 0) return gMean;

            const gWeights = values.map((val) => {
              const z = (val - gMean) / gStdDev;
              return Math.exp(-0.5 * z * z);
            });
            const gWeightSum = gWeights.reduce((sum, w) => sum + w, 0);
            return (
              values.reduce((sum, val, i) => sum + val * gWeights[i], 0) /
              gWeightSum
            );

          default:
            return values.reduce((sum, val) => sum + val, 0) / values.length;
        }
      }

      function createAggregatedChart(data, paramKey) {
        const canvas = document.getElementById("aggregatedChart");

        // Destroy existing chart properly
        if (aggregatedChart) {
          aggregatedChart.destroy();
          aggregatedChart = null;
        }

        // Clear canvas context
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Create simple time labels for aggregated chart
        const timeLabels = weatherData.hourly.time.map((time, index) => {
          const date = new Date(time);
          if (index % 12 === 0) {
            // Show every 12 hours for date + 12h format
            const day = date.getDate();
            const month = date.toLocaleDateString("fr-FR", { month: "short" });
            return `${day} ${month} 12h`;
          } else if (index % 12 === 6) {
            // Show just date for mid-day points
            const day = date.getDate();
            const month = date.toLocaleDateString("fr-FR", { month: "short" });
            return `${day} ${month}`;
          }
          return "";
        });

        aggregatedChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: timeLabels,
            datasets: [
              {
                label: `${PARAMETERS[paramKey].label} (${STRATEGIES[selectedStrategy].label})`,
                data: data,
                borderColor: "#059669",
                backgroundColor: "#05966920",
                fill: true,
                tension: 0.1,
                pointRadius: 1,
                pointHoverRadius: 4,
                borderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              tooltip: {
                callbacks: {
                  title: function (context) {
                    const index = context[0].dataIndex;
                    const time = weatherData.hourly.time[index];
                    const date = new Date(time);
                    return date.toLocaleDateString("fr-FR", {
                      day: "2-digit",
                      month: "2-digit",
                      year: "numeric",
                      hour: "2-digit",
                      minute: "2-digit",
                    });
                  },
                },
              },
            },
            scales: {
              x: {
                type: "category",
                title: {
                  display: false,
                },
              },
              y: {
                title: {
                  display: true,
                  text: PARAMETERS[paramKey].unit,
                },
              },
            },
          },
        });

        // Stocker les donn√©es agr√©g√©es et afficher le panel d'analyse
        currentAggregatedData = data;
        console.log(
          "üéØ Appel updateAnalysisPanel depuis createAggregatedChart"
        );
        console.log("üìä Donn√©es:", {
          weatherData: !!weatherData,
          data: data ? data.length : 0,
          selectedStrategy,
        });

        // Mettre √† jour l'analyse avec les nouvelles donn√©es
        console.log("üéØ DEBUG PANEL - Trigger depuis createAggregatedChart", {
          hasData: !!(data && data.length > 0),
          dataLength: data ? data.length : 0,
        });
        updateAnalysisPanel(weatherData, data);
      }

      // Wind directions - 16 sectors based on the image
      const WIND_DIRECTIONS = [
        { name: "N", angle: 0, min: 348.75, max: 11.25 },
        { name: "NNE", angle: 22.5, min: 11.25, max: 33.75 },
        { name: "NE", angle: 45, min: 33.75, max: 56.25 },
        { name: "ENE", angle: 67.5, min: 56.25, max: 78.75 },
        { name: "E", angle: 90, min: 78.75, max: 101.25 },
        { name: "ESE", angle: 112.5, min: 101.25, max: 123.75 },
        { name: "SE", angle: 135, min: 123.75, max: 146.25 },
        { name: "SSE", angle: 157.5, min: 146.25, max: 168.75 },
        { name: "S", angle: 180, min: 168.75, max: 191.25 },
        { name: "SSO", angle: 202.5, min: 191.25, max: 213.75 },
        { name: "SO", angle: 225, min: 213.75, max: 236.25 },
        { name: "OSO", angle: 247.5, min: 236.25, max: 258.75 },
        { name: "O", angle: 270, min: 258.75, max: 281.25 },
        { name: "ONO", angle: 292.5, min: 281.25, max: 303.75 },
        { name: "NO", angle: 315, min: 303.75, max: 326.25 },
        { name: "NNO", angle: 337.5, min: 326.25, max: 348.75 },
      ];

      // Beaufort scale colors based on wind speed
      const BEAUFORT_COLORS = [
        { min: 0, max: 1, color: "#00BFFF", name: "Calme" },
        { min: 1, max: 11, color: "#7FFF00", name: "Tr√®s l√©g√®re brise" },
        { min: 11, max: 19, color: "#32CD32", name: "L√©g√®re brise" },
        { min: 19, max: 28, color: "#FFFF00", name: "Petite brise" },
        { min: 28, max: 38, color: "#FFD700", name: "Jolie brise" },
        { min: 38, max: 49, color: "#FFA500", name: "Bonne brise" },
        { min: 49, max: 61, color: "#FF4500", name: "Vent frais" },
        { min: 61, max: 74, color: "#FF0000", name: "Grand frais" },
        { min: 74, max: 88, color: "#DC143C", name: "Coup de vent" },
        { min: 88, max: 102, color: "#8B008B", name: "Fort coup de vent" },
        { min: 102, max: 117, color: "#4B0082", name: "Temp√™te" },
        {
          min: 117,
          max: 999,
          color: "#2F2F2F",
          name: "Violente temp√™te/Ouragan",
        },
      ];

      function getBeaufortColor(windSpeed) {
        for (let scale of BEAUFORT_COLORS) {
          if (windSpeed >= scale.min && windSpeed < scale.max) {
            return scale.color;
          }
        }
        return BEAUFORT_COLORS[BEAUFORT_COLORS.length - 1].color; // Fallback to strongest
      }

      function getWindDirectionSector(degrees) {
        // Handle the special case of North (crosses 0¬∞)
        if (degrees >= 348.75 || degrees < 11.25) {
          return WIND_DIRECTIONS[0]; // N
        }

        // Find the sector for other directions
        for (let i = 1; i < WIND_DIRECTIONS.length; i++) {
          const sector = WIND_DIRECTIONS[i];
          if (degrees >= sector.min && degrees < sector.max) {
            return sector;
          }
        }

        // Fallback to North if no match
        return WIND_DIRECTIONS[0];
      }

      function createWindRadarChart() {
        const canvas = document.getElementById("windRadarChart");
        if (!canvas) return;

        // Destroy existing chart
        if (windRadarChart) {
          windRadarChart.destroy();
          windRadarChart = null;
        }

        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Calculate maximum wind speed from the entire dataset for fixed scale
        const windSpeedData = calculateAggregatedData("wind_speed");
        maxWindSpeedInData = Math.max(
          ...windSpeedData.filter((v) => v !== null && v !== undefined)
        );
        const fixedMaxScale = Math.ceil((maxWindSpeedInData + 10) / 10) * 10; // Round up to nearest 10 + margin

        // Get current wind data for color calculation
        const windDirectionData = calculateAggregatedData("wind_direction");
        const currentSpeed = windSpeedData[currentTimeIndex] || 0;
        const beaufortColor = getBeaufortColor(currentSpeed);

        const chartConfig = {
          type: "radar",
          data: {
            labels: WIND_DIRECTIONS.map((d) => d.name),
            datasets: [
              {
                label: `Direction & Force (${STRATEGIES[selectedStrategy].label})`,
                data: new Array(16).fill(0),
                borderColor: beaufortColor,
                backgroundColor: beaufortColor + "80",
                borderWidth: 3,
                pointBackgroundColor: "#059669",
                pointBorderColor: "#ffffff",
                pointRadius: 0, // Hide individual points
                pointHoverRadius: 6,
                fill: true,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: {
              duration: 0, // Disable all animations
            },
            plugins: {
              legend: {
                position: "top",
              },
              tooltip: {
                callbacks: {
                  label: function (context) {
                    const direction = WIND_DIRECTIONS[context.dataIndex].name;
                    const speed = context.parsed.r.toFixed(1);

                    // Find Beaufort scale info
                    const beaufortInfo = BEAUFORT_COLORS.find(
                      (scale) =>
                        parseFloat(speed) >= scale.min &&
                        parseFloat(speed) < scale.max
                    );
                    const beaufortName = beaufortInfo
                      ? beaufortInfo.name
                      : "Inconnu";

                    return [
                      `${direction}: ${speed} km/h`,
                      `Beaufort: ${beaufortName}`,
                    ];
                  },
                },
              },
            },
            scales: {
              r: {
                beginAtZero: true,
                max: fixedMaxScale, // Fixed scale based on dataset maximum
                ticks: {
                  stepSize: Math.max(5, Math.ceil(fixedMaxScale / 10)),
                  // Custom callback to display actual wind speeds instead of transformed values
                  callback: function (value, index, values) {
                    // Convert back from display value to actual wind speed
                    // displayValue = sqrt(speed/max) * max
                    // So: speed = (displayValue/max)¬≤ * max = displayValue¬≤ / max
                    const actualSpeed = (value * value) / maxWindSpeedInData;

                    // Only show ticks at meaningful intervals
                    const meaningfulSpeeds = [
                      0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 60, 70, 80, 90,
                      100,
                    ];
                    const closest = meaningfulSpeeds.find(
                      (speed) => Math.abs(actualSpeed - speed) < 2
                    );

                    if (closest !== undefined) {
                      return closest + " km/h";
                    }
                    return "";
                  },
                },
                grid: {
                  color: "rgba(0, 0, 0, 0.1)",
                },
                angleLines: {
                  color: "rgba(0, 0, 0, 0.1)",
                },
                pointLabels: {
                  font: {
                    size: 12,
                    weight: "bold",
                  },
                },
              },
            },
          },
        };

        windRadarChart = new Chart(ctx, chartConfig);

        // Initialize with first time index
        updateWindRadar();
      }

      function updateWindRadar() {
        if (!windRadarChart || !weatherData) return;

        const timeSlider = document.getElementById("timeSlider");
        const currentTimeLabel = document.getElementById("currentTimeLabel");

        currentTimeIndex = parseInt(timeSlider.value);

        // Update time label
        const currentTime = weatherData.hourly.time[currentTimeIndex];
        if (currentTime) {
          const date = new Date(currentTime);
          const timeStr = date.toLocaleDateString("fr-FR", {
            day: "2-digit",
            month: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
          });
          currentTimeLabel.textContent = `Heure: ${timeStr} (${currentTimeIndex}H)`;
        }

        // Get aggregated wind data for current time
        const windSpeedData = calculateAggregatedData("wind_speed");
        const windDirectionData = calculateAggregatedData("wind_direction");

        if (
          !windSpeedData[currentTimeIndex] ||
          !windDirectionData[currentTimeIndex]
        ) {
          // No data for this time, set all sectors to 0
          windRadarChart.data.datasets[0].data = new Array(16).fill(0);
          windRadarChart.update();
          return;
        }

        const currentSpeed = windSpeedData[currentTimeIndex];
        const currentDirection = windDirectionData[currentTimeIndex];

        // Find the sector for current wind direction
        const sector = getWindDirectionSector(currentDirection);

        // Function to calculate display value for logarithmic scale
        // Surface of triangle proportional to wind speed
        function getDisplayValue(windSpeed) {
          if (windSpeed <= 0) return 0;
          // Use square root to make surface proportional to speed
          // Surface = base * height, if we control height by sqrt(speed), surface becomes proportional to speed
          return Math.sqrt(windSpeed / maxWindSpeedInData) * maxWindSpeedInData;
        }

        // Create triangular sector for radar chart
        const chartData = new Array(16).fill(0);
        const sectorIndex = WIND_DIRECTIONS.findIndex(
          (d) => d.name === sector.name
        );

        if (sectorIndex !== -1) {
          // Calculate display value for logarithmic scale
          const displayValue = getDisplayValue(currentSpeed);

          // Set the main sector and its immediate neighbors to create a triangle effect
          // The triangle base should be in the direction the wind comes FROM
          chartData[sectorIndex] = displayValue; // Center of the sector

          // Add the two adjacent sectors to form the triangle base
          const leftIndex = (sectorIndex - 1 + 16) % 16;
          const rightIndex = (sectorIndex + 1) % 16;

          chartData[leftIndex] = displayValue;
          chartData[rightIndex] = displayValue;
        }

        // Update chart data
        windRadarChart.data.datasets[0].data = chartData;
        windRadarChart.data.datasets[0].label = `Direction & Force (${
          STRATEGIES[selectedStrategy].label
        }) - ${currentSpeed.toFixed(1)} km/h`;

        // Update colors based on current wind speed
        const beaufortColor = getBeaufortColor(currentSpeed);
        windRadarChart.data.datasets[0].borderColor = beaufortColor;
        windRadarChart.data.datasets[0].backgroundColor = beaufortColor + "80";

        // Keep the fixed scale - no dynamic adjustment

        windRadarChart.update({ duration: 0 }); // Disable animation on update
      }
    </script>
    <script>
      /* Masquer bouton "Appliquer la strat√©gie" et le 2·µâ graphique */
      document.addEventListener("DOMContentLoaded", () => {
        const btnApply = document.getElementById("applyStrategy");
        if (btnApply) btnApply.style.display = "none";

        const aggregatedCanvas = document.getElementById("aggregatedChart");
        if (aggregatedCanvas && aggregatedCanvas.parentElement) {
          aggregatedCanvas.parentElement.style.display = "none";
        }
      });

      /* Ajustement visuel : boutons de strat√©gie plus compacts */
      const styleTag = document.createElement("style");
      styleTag.textContent = `
        .strategy-card {
          padding: 6px 10px;
          font-size: 0.8rem;
          min-width: 120px;
        }
        
        .tooltip-trigger:hover + .tooltip-content,
        .tooltip-content:hover {
          display: block !important;
        }
        
        .analysis-btn:hover {
          background: #555 !important;
        }
        
        .analysis-btn.active {
          background: #666 !important;
          border-color: #888 !important;
        }
      `;
      document.head.appendChild(styleTag);

      // Variables globales pour l'analyse
      let currentAnalysisRange = "short";
      let cachedModelAnalysis = {};
      let currentAggregatedData = null;

      // Fonctions pour l'analyse des mod√®les
      function calculateStandardDeviation(values) {
        if (values.length === 0) return 0;
        const mean = values.reduce((a, b) => a + b, 0) / values.length;
        const variance =
          values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
        return Math.sqrt(variance);
      }

      function calculateModelDeviations(
        weatherData,
        aggregatedData,
        timeRange = [0, 48]
      ) {
        const modelDeviations = {};
        const [startHour, endHour] = timeRange;
        const currentParam = getActiveParam();

        console.log(
          `üîç Calcul des d√©viations pour ${currentParam} sur la plage ${startHour}-${endHour}h`
        );

        // Extraire les donn√©es des mod√®les depuis le graphique principal
        if (
          !currentChart ||
          !currentChart.data ||
          !currentChart.data.datasets
        ) {
          console.log("‚ùå DEBUG PANEL - Pas de graphique principal disponible");
          return { models: [], standardDeviation: 0 };
        }

        // Pour chaque mod√®le (exclure l'agr√©gation)
        currentChart.data.datasets.forEach((dataset, index) => {
          // Filtrer: ignorer agr√©gation et mod√®les non autoris√©s selon la plage
          if (dataset.isAggregate || !isModelAllowed(dataset.label)) {
            return;
          }

          const modelData = dataset.data;
          const deviations = [];

          console.log(
            `üîç DEBUG PANEL - Traitement mod√®le: ${dataset.label}, donn√©es: ${
              modelData ? modelData.length : "null"
            }`
          );

          // Calculer les d√©viations pour chaque point dans la plage temporelle
          for (
            let i = startHour;
            i < Math.min(endHour, aggregatedData.length, modelData.length);
            i++
          ) {
            if (
              modelData[i] !== null &&
              modelData[i] !== undefined &&
              aggregatedData[i] !== null &&
              aggregatedData[i] !== undefined
            ) {
              const deviation = Math.abs(modelData[i] - aggregatedData[i]);
              deviations.push(deviation);
            }
          }

          modelDeviations[dataset.label] = {
            deviations: deviations,
            avgDeviation:
              deviations.length > 0
                ? deviations.reduce((a, b) => a + b, 0) / deviations.length
                : 0,
            stdDev: calculateStandardDeviation(deviations),
            values: deviations.slice(0, 28), // 28 premi√®res valeurs
          };

          console.log(
            `üìä ${dataset.label}: ${
              deviations.length
            } d√©viations, moyenne: ${modelDeviations[
              dataset.label
            ].avgDeviation.toFixed(2)}`
          );
        });

        return modelDeviations;
      }

      function updateAnalysisPanel(weatherData, aggregatedData) {
        console.log("üéØ DEBUG PANEL - updateAnalysisPanel called", {
          hasWeatherData: !!weatherData,
          hasAggregatedData: !!aggregatedData,
          aggregatedDataLength: aggregatedData ? aggregatedData.length : 0,
          aggregatedDataSample: aggregatedData
            ? aggregatedData.slice(0, 5)
            : null,
        });

        // Toujours afficher le panel d'analyse
        const analysisSection = document.getElementById("analysisSection");
        if (analysisSection) {
          analysisSection.style.display = "block";
        }

        // Si pas de donn√©es d'agr√©gation, essayer de r√©cup√©rer celles du graphique principal
        if (!aggregatedData && weatherData) {
          console.log(
            "üîç DEBUG PANEL - Tentative r√©cup√©ration agr√©gation du graphique principal"
          );
          aggregatedData = extractAggregationFromMainChart();
          console.log("üîç DEBUG PANEL - Agr√©gation extraite:", {
            success: !!aggregatedData,
            length: aggregatedData ? aggregatedData.length : 0,
          });
        }

        if (!weatherData || !aggregatedData) {
          console.log("‚ùå DEBUG PANEL - Donn√©es insuffisantes", {
            weatherData: !!weatherData,
            aggregatedData: !!aggregatedData,
          });

          // Afficher un message d'instruction
          const explanationEl = document.getElementById("analysisExplanation");
          if (explanationEl) {
            explanationEl.innerHTML = `
              <strong style="color: #ff6b6b;">‚ö†Ô∏è Aucune donn√©e d'agr√©gation disponible</strong><br><br>
              Pour utiliser ce panel :<br>
              1Ô∏è‚É£ S√©lectionnez des mod√®les m√©t√©o dans la section visualisation<br>
              2Ô∏è‚É£ Allez dans "üîß Strat√©gies d'agr√©gation"<br>
              3Ô∏è‚É£ Cliquez "‚ö° Appliquer la strat√©gie"<br>
              4Ô∏è‚É£ L'analyse s'affichera automatiquement ici !
            `;
          }
          return;
        }

        console.log(
          "üéØ DEBUG PANEL - updateAnalysisPanel avec donn√©es valides"
        );

        const timeRanges = {
          short: [0, 48],
          medium: [48, 96],
          long: [96, 168],
          prorated: [0, 168],
          weighted: [0, 168],
          composite: [0, 168],
        };

        const range = timeRanges[currentAnalysisRange];
        const modelDeviations = calculateModelDeviations(
          weatherData,
          aggregatedData,
          range
        );

        // Trier les mod√®les par d√©viation moyenne
        const sortedModels = Object.entries(modelDeviations)
          .filter(([name, data]) => data.deviations.length > 0)
          .sort((a, b) => a[1].avgDeviation - b[1].avgDeviation);

        if (sortedModels.length === 0) {
          console.log("‚ùå Aucun mod√®le trouv√© pour l'analyse");
          return;
        }

        const winner = sortedModels[0];
        const loser = sortedModels[sortedModels.length - 1];

        // Calculer l'√©cart-type de l'agr√©gation
        const aggregationStdDev = calculateStandardDeviation(
          aggregatedData.slice(range[0], range[1])
        );

        // Mettre √† jour l'affichage
        const aggregationNameEl = document.getElementById("aggregationName");
        const aggregationStdDevEl =
          document.getElementById("aggregationStdDev");
        const winnerModelEl = document.getElementById("winnerModel");
        const winnerStdDevEl = document.getElementById("winnerStdDev");
        const loserModelEl = document.getElementById("loserModel");
        const loserStdDevEl = document.getElementById("loserStdDev");

        console.log(
          `üéØ DEBUG PANEL - Mise √† jour affichage: gagnant=${winner[0]}, perdant=${loser[0]}`
        );
        console.log(
          `üéØ DEBUG PANEL - √âl√©ments trouv√©s: aggregationName=${!!aggregationNameEl}, winnerModel=${!!winnerModelEl}, loserModel=${!!loserModelEl}`
        );

        // Utiliser "Moyenne arithm√©tique" par d√©faut si selectedStrategy n'est pas d√©finie
        const strategyName =
          selectedStrategy && STRATEGIES[selectedStrategy]
            ? STRATEGIES[selectedStrategy].label
            : "Moyenne arithm√©tique";

        if (aggregationNameEl) aggregationNameEl.textContent = strategyName;
        if (aggregationStdDevEl)
          aggregationStdDevEl.textContent = aggregationStdDev.toFixed(2);
        if (winnerModelEl) winnerModelEl.textContent = winner[0];
        if (winnerStdDevEl)
          winnerStdDevEl.textContent = winner[1].avgDeviation.toFixed(2);
        if (loserModelEl) loserModelEl.textContent = loser[0];
        if (loserStdDevEl)
          loserStdDevEl.textContent = loser[1].avgDeviation.toFixed(2);

        console.log(
          `‚úÖ DEBUG PANEL - Affichage mis √† jour: ${strategyName}, gagnant: ${
            winner[0]
          } (${winner[1].avgDeviation.toFixed(2)}), perdant: ${
            loser[0]
          } (${loser[1].avgDeviation.toFixed(2)})`
        );

        // Mettre √† jour le tableau de comparaison
        updateComparisonTable(
          weatherData,
          aggregatedData,
          winner,
          loser,
          range
        );

        // Mettre √† jour l'explication
        updateAnalysisExplanation();

        console.log("‚úÖ DEBUG PANEL - Panel d'analyse mis √† jour avec", {
          vainqueur: winner[0],
          perdant: loser[0],
          ecartTypeAgg: aggregationStdDev.toFixed(2),
        });
      }

      function updateComparisonTable(
        weatherData,
        aggregatedData,
        winner,
        loser,
        range
      ) {
        const tableHeaders = document.getElementById("tableHeaders");
        const aggregationRow = document.getElementById("aggregationRow");
        const winnerRow = document.getElementById("winnerRow");
        const loserRow = document.getElementById("loserRow");

        if (!tableHeaders || !aggregationRow || !winnerRow || !loserRow) {
          console.log("‚ùå √âl√©ments du tableau introuvables");
          return;
        }

        // Cr√©er les en-t√™tes avec dates courtes - 28 valeurs toutes les 6 heures
        const headers = ["Mod√®le"];
        const aggregationValues = ["Agr√©gation"];
        const winnerLabel = `üèÜ ${winner[0]} (œÉ ${winner[1].stdDev.toFixed(
          2
        )})`;
        const loserLabel = `üìâ ${loser[0]} (œÉ ${loser[1].stdDev.toFixed(2)})`;
        const winnerValues = [winnerLabel];
        const loserValues = [loserLabel];

        // G√©n√©rer exactement 28 valeurs toutes les 6 heures (28 * 6 = 168h = 7 jours)
        for (let i = 0; i < 28; i++) {
          const dataIndex = i * 6; // Toutes les 6 heures
          const date = new Date(
            weatherData.hourly.time[
              Math.min(dataIndex, weatherData.hourly.time.length - 1)
            ]
          );
          const day = String(date.getDate()).padStart(2, "0");
          const hour = String(date.getHours()).padStart(2, "0");
          const shortDate = `${day}-${hour}h`;

          if (dataIndex < range[0] || dataIndex >= range[1]) {
            headers.push(shortDate);
            aggregationValues.push("X");
            winnerValues.push("X");
            loserValues.push("X");
            continue;
          }

          if (dataIndex < weatherData.hourly.time.length) {
            headers.push(shortDate);

            // Valeur agr√©g√©e
            let aggRaw = aggregatedData[dataIndex];
            if (aggRaw && typeof aggRaw === "object") {
              aggRaw = aggRaw.y !== undefined ? aggRaw.y : null;
            }
            aggregationValues.push(
              aggRaw !== null && aggRaw !== undefined ? aggRaw.toFixed(1) : "X"
            );

            // Valeur du gagnant (extraire du graphique)
            const winnerDataset = currentChart.data.datasets.find(
              (dataset) => dataset.label === winner[0]
            );
            const winnerValue =
              winnerDataset &&
              winnerDataset.data[dataIndex] !== null &&
              winnerDataset.data[dataIndex] !== undefined
                ? winnerDataset.data[dataIndex]
                : null;
            winnerValues.push(
              winnerValue !== null ? winnerValue.toFixed(1) : "X"
            );

            // Valeur du perdant (extraire du graphique)
            const loserDataset = currentChart.data.datasets.find(
              (dataset) => dataset.label === loser[0]
            );
            const loserValue =
              loserDataset &&
              loserDataset.data[dataIndex] !== null &&
              loserDataset.data[dataIndex] !== undefined
                ? loserDataset.data[dataIndex]
                : null;
            loserValues.push(loserValue !== null ? loserValue.toFixed(1) : "X");
          } else {
            // Si on d√©passe les donn√©es disponibles, mettre "X"
            headers.push("--");
            aggregationValues.push("X");
            winnerValues.push("X");
            loserValues.push("X");
          }
        }

        // Construire le tableau avec le nouveau style moderne
        tableHeaders.innerHTML = headers
          .map(
            (header) =>
              `<th style="padding: 6px 4px; border: 1px solid #e2e8f0; color: #475569; text-align: center; min-width: 45px; font-size: 10px; font-weight: 600;">${header}</th>`
          )
          .join("");

        aggregationRow.innerHTML = aggregationValues
          .map(
            (value, index) =>
              `<td style="padding: 6px 4px; border: 1px solid #e2e8f0; color: ${
                index === 0 ? "#059669" : "#374151"
              }; text-align: center;  ${
                index === 0
                  ? "font-weight: bold; font-size: 10px;"
                  : "font-weight: bold; font-size: 10px;"
              } ${value === "X" ? "color: #9ca3af;" : ""}">${value}</td>`
          )
          .join("");

        winnerRow.innerHTML = winnerValues
          .map(
            (value, index) =>
              `<td style="padding: 6px 4px; border: 1px solid #e2e8f0; color: ${
                index === 0 ? "#16a34a" : "#374151"
              }; text-align: center;  ${
                index === 0
                  ? "font-weight: bold; font-size: 10px;"
                  : "font-weight: bold; font-size: 10px;"
              } ${value === "X" ? "color: #9ca3af;" : ""}">${value}</td>`
          )
          .join("");

        loserRow.innerHTML = loserValues
          .map(
            (value, index) =>
              `<td style="padding: 6px 4px; border: 1px solid #e2e8f0; color: ${
                index === 0 ? "#dc2626" : "#374151"
              }; text-align: center;  ${
                index === 0
                  ? "font-weight: bold; font-size: 10px;"
                  : "font-weight: bold; font-size: 10px;"
              } ${value === "X" ? "color: #9ca3af;" : ""}">${value}</td>`
          )
          .join("");
      }

      function getActiveParam() {
        const activeTab = document.querySelector(".tab-btn.active");
        return activeTab ? activeTab.dataset.param : "temperature_2m";
      }

      function extractAggregationFromMainChart() {
        console.log("üîç DEBUG PANEL - extractAggregationFromMainChart start");

        try {
          // V√©rifier si le graphique principal existe
          if (
            !currentChart ||
            !currentChart.data ||
            !currentChart.data.datasets
          ) {
            console.log("‚ùå DEBUG PANEL - Pas de graphique principal");
            return null;
          }

          // Chercher le dataset d'agr√©gation (g√©n√©ralement le dernier avec "Moyenne" dans le nom)
          const datasets = currentChart.data.datasets;
          console.log(
            "üîç DEBUG PANEL - Datasets disponibles:",
            datasets.map((d) => d.label)
          );

          let aggregationDataset = datasets.find((ds) => ds.isAggregate);
          if (!aggregationDataset) {
            aggregationDataset = datasets.find(
              (dataset) => dataset.label === STRATEGIES[selectedStrategy].label
            );
          }
          if (!aggregationDataset) {
            aggregationDataset = datasets.find(
              (dataset) =>
                dataset.label &&
                (dataset.label.includes("Moyenne") ||
                  dataset.label.includes("moyenne") ||
                  dataset.label.includes("Agr√©gation") ||
                  dataset.label.includes("agr√©gation"))
            );
          }

          if (!aggregationDataset) {
            console.log("‚ùå DEBUG PANEL - Pas de dataset d'agr√©gation trouv√©");
            return null;
          }

          console.log(
            "‚úÖ DEBUG PANEL - Dataset d'agr√©gation trouv√©:",
            aggregationDataset.label
          );
          console.log("üîç DEBUG PANEL - Donn√©es:", {
            length: aggregationDataset.data
              ? aggregationDataset.data.length
              : 0,
            sample: aggregationDataset.data
              ? aggregationDataset.data.slice(0, 10)
              : null,
          });

          // Filtrer les valeurs null/undefined
          const cleanData = aggregationDataset.data.filter(
            (value) => value !== null && value !== undefined
          );
          console.log(
            "‚úÖ DEBUG PANEL - Donn√©es nettoy√©es:",
            cleanData.length,
            "valeurs"
          );

          return cleanData;
        } catch (error) {
          console.error("‚ùå DEBUG PANEL - Erreur extraction:", error);
          return null;
        }
      }

      function updateAnalysisExplanation() {
        const explanations = {
          short:
            "Analyse 0-48h : Comparaison des mod√®les court terme (GFS, ECMWF, ICON) pour les pr√©visions imm√©diates.",
          medium:
            "Analyse 48-96h : Comparaison des mod√®les moyen terme, p√©riode critique pour la fiabilit√© des pr√©visions.",
          long: "Analyse 96-168h : Comparaison long terme (7 jours), seuls certains mod√®les globaux sont disponibles.",
          prorated:
            "Analyse proratis√©e : √âcart-type divis√© par le nombre de points disponibles pour neutraliser la dur√©e.",
          weighted:
            "Analyse pond√©r√©e temporelle : Points proches du T0 = poids 1, points lointains = poids r√©duit.",
          composite:
            "Score mixte : Combinaison de la moyenne des √©carts-types, stabilit√© temporelle et couverture normalis√©e.",
        };

        document.getElementById("analysisExplanation").textContent =
          explanations[currentAnalysisRange] ||
          "S√©lectionnez une strat√©gie d'analyse pour voir les d√©tails.";
      }

      // Event listeners pour les boutons d'analyse
      document.addEventListener("DOMContentLoaded", function () {
        const analysisButtons = document.querySelectorAll(".analysis-btn");

        analysisButtons.forEach((button) => {
          button.addEventListener("click", function () {
            // Retirer la classe active de tous les boutons
            analysisButtons.forEach((btn) => btn.classList.remove("active"));

            // Ajouter la classe active au bouton cliqu√©
            this.classList.add("active");

            // Mettre √† jour la plage d'analyse
            currentAnalysisRange = this.getAttribute("data-range");

            // Mettre √† jour l'analyse avec strat√©gie chang√©e
            console.log(
              "üéØ DEBUG PANEL - Bouton cliqu√©:",
              currentAnalysisRange
            );

            // Toujours essayer de mettre √† jour, m√™me sans currentAggregatedData
            if (typeof weatherData !== "undefined") {
              updateAnalysisPanel(weatherData, currentAggregatedData);
            } else {
              console.log("‚ùå DEBUG PANEL - Pas de weatherData");
            }
          });
        });

        // Initialiser l'explication par d√©faut
        updateAnalysisExplanation();

        // Afficher le panel d'analyse avec les instructions d√®s le chargement
        console.log("üéØ DEBUG PANEL - Initialisation du panel");
        updateAnalysisPanel(null, null);

        // Fonction de diagnostic du panel d'analyse
        window.debugAnalysisPanel = function () {
          console.log("üîß DEBUG PANEL - √âtat complet:", {
            analysisSection: !!document.getElementById("analysisSection"),
            currentChart: !!currentChart,
            currentChartDatasets: currentChart
              ? currentChart.data.datasets.length
              : 0,
            weatherData: !!weatherData,
            currentAggregatedData: !!currentAggregatedData,
            currentAnalysisRange,
            selectedStrategy,
          });

          if (currentChart) {
            console.log(
              "üîß DEBUG PANEL - Datasets du graphique:",
              currentChart.data.datasets.map((d) => ({
                label: d.label,
                dataLength: d.data.length,
              }))
            );
          }

          // Test d'extraction d'agr√©gation
          const extracted = extractAggregationFromMainChart();
          console.log(
            "üîß DEBUG PANEL - Test extraction:",
            !!extracted,
            extracted ? extracted.length : 0
          );

          // Test de mise √† jour forc√©e
          updateAnalysisPanel(weatherData, extracted);
        };

        console.log(
          "üéØ DEBUG PANEL - Tapez debugAnalysisPanel() dans la console pour diagnostiquer"
        );

        // Gestion du tooltip
        const tooltipTrigger = document.querySelector(".tooltip-trigger");
        const tooltipContent = document.querySelector(".tooltip-content");

        if (tooltipTrigger && tooltipContent) {
          tooltipTrigger.addEventListener("mouseenter", () => {
            tooltipContent.style.display = "block";
          });

          tooltipTrigger.addEventListener("mouseleave", () => {
            setTimeout(() => {
              if (!tooltipContent.matches(":hover")) {
                tooltipContent.style.display = "none";
              }
            }, 100);
          });

          tooltipContent.addEventListener("mouseleave", () => {
            tooltipContent.style.display = "none";
          });
        }
      });

      // üîç Helper: check if a model should be included for current analysis range
      function isModelAllowed(modelLabel) {
        const disallowedMedium = [
          "MF AROME FRANCE",
          "MF AROME FRANCE HD",
          "KNMI HARMONIE AROME EU",
          "UKMO DETERM 2KM",
        ];
        const allowedLong = [
          "GFS GLOBAL 0.11¬∞/0.25¬∞",
          "GFS GRAPHCAST",
          "ECMWF IFS 0.25¬∞",
          "ICON GLOBAL",
        ];
        if (currentAnalysisRange === "medium") {
          return !disallowedMedium.includes(modelLabel);
        }
        if (currentAnalysisRange === "long") {
          return allowedLong.includes(modelLabel);
        }
        return true; // short or other
      }
    </script>
  </body>
</html>
